{"version":3,"file":"art-yPh0NcMI.mjs","sources":["../src/compute/radiance/brdf.ts","../src/compute/radiance/response.ts","../src/compute/radiance/directional-response.ts","../src/compute/raytracer/bvh/BVHNode.ts","../src/compute/raytracer/bvh/BVHVector3.ts","../src/compute/raytracer/bvh/BVH.ts","../src/compute/raytracer/bvh/BVHBuilder.ts","../src/compute/radiance/patch.ts","../src/compute/radiance/form-factor.ts","../src/compute/radiance/art.ts"],"sourcesContent":["import { Float32BufferAttribute, IcosahedronGeometry, Vector3 } from 'three';\n\nconst DEFAULT_BRDF_DETAIL = 1;\n\nexport class BRDF {\n  /** Number of icosahedron subdivisions */\n  public detail: number;\n  /** Unit direction vectors for each hemisphere bin (in local frame, z-up) */\n  public directions: Vector3[];\n  /** Number of hemisphere direction bins */\n  public nSlots: number;\n  /**\n   * Reflection coefficient matrix [incomingSlot][outgoingSlot].\n   * coefficients[i][j] = fraction of energy arriving in direction i\n   * that is reflected into direction j.\n   */\n  public coefficients: Float32Array[];\n\n  constructor(detail: number = DEFAULT_BRDF_DETAIL) {\n    this.detail = detail;\n\n    // Generate hemisphere sample directions from icosahedron\n    const geometry = new IcosahedronGeometry(1, this.detail);\n    const positions = geometry.getAttribute('position') as Float32BufferAttribute;\n\n    // Collect unique upper-hemisphere points\n    const seen = new Set<string>();\n    const hemiPoints: Vector3[] = [];\n    for (let i = 0; i < positions.count; i++) {\n      const x = positions.getX(i);\n      const y = positions.getY(i);\n      const z = positions.getZ(i);\n      if (z >= 0) {\n        const v = new Vector3(x, y, z).normalize();\n        const key = `${v.x.toFixed(6)},${v.y.toFixed(6)},${v.z.toFixed(6)}`;\n        if (!seen.has(key)) {\n          seen.add(key);\n          hemiPoints.push(v);\n        }\n      }\n    }\n\n    this.directions = hemiPoints;\n    this.nSlots = hemiPoints.length;\n    this.coefficients = [];\n    for (let i = 0; i < this.nSlots; i++) {\n      this.coefficients[i] = new Float32Array(this.nSlots);\n    }\n  }\n\n  /**\n   * Compute BRDF coefficients for a given absorption and scattering.\n   * Specular component goes into the mirror-reflection bin.\n   * Diffuse component is distributed uniformly across all bins.\n   */\n  computeCoefficients(absorption: number, scattering: number): void {\n    // Clamp inputs to [0,1] to handle interpolated values outside valid range\n    const a = Math.max(0, Math.min(1, Number.isFinite(absorption) ? absorption : 0));\n    const s = Math.max(0, Math.min(1, Number.isFinite(scattering) ? scattering : 0));\n    const reflectance = 1 - a;\n    const diffuseWeight = reflectance * s / this.nSlots;\n    const specularWeight = reflectance * (1 - s);\n\n    for (let incoming = 0; incoming < this.nSlots; incoming++) {\n      // Mirror reflection direction: reflect incoming across z-axis (normal)\n      // If incoming direction is d = (dx, dy, dz), mirror is (-dx, -dy, dz)\n      const d = this.directions[incoming];\n      const mirror = new Vector3(-d.x, -d.y, d.z).normalize();\n      const mirrorSlot = this.findNearestSlot(mirror);\n\n      for (let outgoing = 0; outgoing < this.nSlots; outgoing++) {\n        this.coefficients[incoming][outgoing] = diffuseWeight;\n      }\n      this.coefficients[incoming][mirrorSlot] += specularWeight;\n    }\n  }\n\n  /**\n   * Find the nearest hemisphere bin for a direction in local frame (z-up).\n   */\n  findNearestSlot(localDir: Vector3): number {\n    let bestIdx = 0;\n    let bestDot = -Infinity;\n    for (let i = 0; i < this.nSlots; i++) {\n      const dot = localDir.dot(this.directions[i]);\n      if (dot > bestDot) {\n        bestDot = dot;\n        bestIdx = i;\n      }\n    }\n    return bestIdx;\n  }\n\n  /**\n   * Get the direction slot index for a world-space direction relative to a patch normal.\n   * Transforms the direction into the local frame where the patch normal is z-up.\n   */\n  getDirectionIndex(worldDir: Vector3, patchNormal: Vector3): number {\n    const localDir = worldToLocal(worldDir, patchNormal);\n    // Clamp to hemisphere (direction should face outward from surface)\n    if (localDir.z < 0) localDir.z = 0;\n    if (localDir.lengthSq() < 1e-10) return 0;\n    localDir.normalize();\n    return this.findNearestSlot(localDir);\n  }\n\n  /**\n   * Get the outgoing reflection coefficients for a given incoming direction slot.\n   * Returns array of length nSlots with the weight for each outgoing direction.\n   */\n  getOutgoingWeights(incomingSlot: number): Float32Array {\n    return this.coefficients[incomingSlot];\n  }\n}\n\n/**\n * Transform a world-space direction into a local frame where `normal` is the z-axis.\n */\nfunction worldToLocal(dir: Vector3, normal: Vector3): Vector3 {\n  // Build a rotation matrix that takes normal -> (0,0,1)\n  const z = normal.clone().normalize();\n  // Choose a tangent not parallel to z\n  let tangent = new Vector3(1, 0, 0);\n  if (Math.abs(z.dot(tangent)) > 0.9) {\n    tangent = new Vector3(0, 1, 0);\n  }\n  const x = new Vector3().crossVectors(z, tangent).normalize();\n  const y = new Vector3().crossVectors(z, x).normalize();\n\n  // Project direction onto local axes\n  return new Vector3(dir.dot(x), dir.dot(y), dir.dot(z));\n}\n\nexport default BRDF;\n","export class Response {\n  buffer: Float32Array;\n  constructor(length: number){\n    this.buffer = new Float32Array(length);\n  }\n  clear(start: number = 0, stop: number = this.buffer.length, value: number = 0){\n    this.buffer.fill(value, start, stop);\n  }\n  extend(n: number){\n    const newBuffer = new Float32Array(n);\n    for(let i = 0; i<this.buffer.length; i++){\n      newBuffer[i] = this.buffer[i];\n    }\n    this.buffer = newBuffer;\n  }\n  add(index: number, value: number){\n    this.buffer[index] += value;\n  }\n  sum(){\n    let sum = 0;\n    for (let i=0; i<this.buffer.length; i++){\n      sum += this.buffer[i];\n    }\n    return sum;\n  }\n  delayMultiplyAdd(source: Response, delay: number, multiplier: number){\n    delay = Math.round(delay);\n    const newLen = source.buffer.length + delay;\n    if (newLen > this.buffer.length) {\n        this.extend(newLen);\n    }\n    for (let i=0; i<source.buffer.length; i++) {\n        this.buffer[i+delay] += (source.buffer[i] * multiplier);\n    }\n  }\n}\n\nexport default Response;","import { Response } from './response';\nexport class DirectionalResponse{\n  /* number of directions */\n  n: number;\n  /* response in each direction */\n  responses: Response[];\n\n  /**\n   * constructs a new DirectionalResponse\n   * @param n number of directions\n   * @param length length of the response\n   */\n  constructor(n: number, length: number) {\n    this.n = n;\n    this.responses = [];\n    for (let i=0; i<n; i++) {\n      this.responses[i] = new Response(length);\n    }\n  }\n  clear(){\n    this.responses.forEach(response=>response.clear());\n  }\n\n  sum(){\n    return this.responses.reduce((a, b)=>a + b.sum(), 0);\n  }\n\n  delayMultiplyAdd(source: Response, delay: number, multPerDirection: number[], constScaler: number) {\n    for (let i=0; i<this.n; i++) {\n        this.responses[i].delayMultiplyAdd(source, delay, multPerDirection[i]*constScaler);\n    }\n  }\n  accumulateFrom(source: DirectionalResponse) {\n    for (let i=0; i<this.n; i++) {\n      this.responses[i].buffer[0] = source.responses[i].sum();\n    }\n  }\n}\n\n","export class BVHNode {\n\textentsMin: XYZ;\n\textentsMax: XYZ;\n\tstartIndex: number;\n\tendIndex: number;\n\tlevel: number;\n\tnode0: BVHNode | null;\n\tnode1: BVHNode | null;\n\tconstructor(extentsMin: XYZ, extentsMax: XYZ, startIndex: number, endIndex: number, level: number) {\n\t\tthis.extentsMin = extentsMin;\n\t\tthis.extentsMax = extentsMax;\n\t\tthis.startIndex = startIndex;\n\t\tthis.endIndex = endIndex;\n\t\tthis.level = level;\n\t\tthis.node0 = null;\n\t\tthis.node1 = null;\n\t}\n\tstatic fromObj({extentsMin, extentsMax, startIndex, endIndex, level, node0, node1}:any) {\n\t\tconst tempNode = new BVHNode(extentsMin, extentsMax, startIndex, endIndex, level);\n\t\tif(node0) tempNode.node0 = BVHNode.fromObj(node0);\n\t\tif(node1) tempNode.node1 = BVHNode.fromObj(node1);\n\t\treturn tempNode;\n\t}\n\telementCount() {\n\t\treturn this.endIndex - this.startIndex;\n\t}\n\n\tcenterX() {\n\t\treturn (this.extentsMin[0] + this.extentsMax[0]) * 0.5;\n\t}\n\n\tcenterY() {\n\t\treturn (this.extentsMin[1] + this.extentsMax[1]) * 0.5;\n\t}\n\n\tcenterZ() {\n\t\treturn (this.extentsMin[2] + this.extentsMax[2]) * 0.5;\n\t}\n\n\tclearShapes() {\n\t\tthis.startIndex = -1;\n\t\tthis.endIndex = -1;\n\t}\n\tget children(): (BVHNode | null)[] {\n\t\treturn [this.node0, this.node1];\n\t}\n\t\n}\n","export class BVHVector3  {\n\tx: number = 0;\n\ty: number = 0;\n\tz: number = 0;\n\tconstructor(x:number = 0, y:number = 0, z:number = 0) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n\tcopy(v:BVHVector3) {\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\treturn this;\n\t}\n\tsetFromArray(array:Float32Array, firstElementPos:number) {\n\t\tthis.x = array[firstElementPos];\n\t\tthis.y = array[firstElementPos+1];\n\t\tthis.z = array[firstElementPos+2];\n\t}\n\tsetFromArrayNoOffset(array:number[]) {\n\t\tthis.x = array[0];\n\t\tthis.y = array[1];\n\t\tthis.z = array[2];\n\t}\n\n\tsetFromArgs(a:number, b:number, c:number) {\n\t\tthis.x = a;\n\t\tthis.y = b;\n\t\tthis.z = c;\n\t}\n\tadd(v:BVHVector3) {\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\treturn this;\n\t}\n\tmultiplyScalar(scalar:number) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\treturn this;\n\t}\n\tsubVectors(a:BVHVector3, b:BVHVector3) {\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\treturn this;\n\t}\n\tdot(v:BVHVector3) {\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t}\n\tcross(v:BVHVector3) {\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\t\treturn this;\n\t}\n\tcrossVectors(a:BVHVector3, b:BVHVector3) {\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\t\treturn this;\n\t}\n\tclone() {\n\t\treturn new BVHVector3(this.x, this.y, this.z);\n\t}\n\tstatic fromAny(potentialVector:any):BVHVector3 {\n\t\tif(potentialVector instanceof BVHVector3) {\n\t\t\treturn potentialVector;\n\t\t} else if (potentialVector.x !== undefined && potentialVector.x !== null) {\n\t\t\treturn new BVHVector3(potentialVector.x, potentialVector.y, potentialVector.z);\n\t\t} else {\n\t\t\tthrow new TypeError(\"Couldn't convert to BVHVector3.\");\n\t\t}\n\t}\n}\n","import { BVHVector3 } from './BVHVector3';\nimport { BVHNode } from './BVHNode';\n\nexport class BVH {\n\trootNode: BVHNode;\n\tbboxArray: Float32Array;\n\ttrianglesArray: Float32Array;\n\tconstructor(rootNode:BVHNode, boundingBoxArray:Float32Array, triangleArray:Float32Array) {\n\t\tthis.rootNode = rootNode;\n\t\tthis.bboxArray = boundingBoxArray;\n\t\tthis.trianglesArray = triangleArray;\n\t}\n\tintersectRay(rayOrigin:any, rayDirection:any, backfaceCulling:boolean = true):any[] {\n\t\ttry {\n\t\t\trayOrigin = BVHVector3.fromAny(rayOrigin);\n\t\t\trayDirection = BVHVector3.fromAny(rayDirection);\n\t\t} catch(error) {\n\t\t\tthrow new TypeError(\"Origin or Direction couldn't be converted to a BVHVector3.\");\n\t\t}\n\t\tconst nodesToIntersect:BVHNode[] = [this.rootNode];\n\t\tconst trianglesInIntersectingNodes:number[] = []; // a list of nodes that intersect the ray (according to their bounding box)\n\t\tconst intersectingTriangles:object[] = [];\n\n\t\tconst invRayDirection = new BVHVector3(\n\t\t\t1.0 / rayDirection.x,\n\t\t\t1.0 / rayDirection.y,\n\t\t\t1.0 / rayDirection.z\n\t\t);\n\n\t\t// go over the BVH tree, and extract the list of triangles that lie in nodes that intersect the ray.\n\t\t// note: these triangles may not intersect the ray themselves\n\t\twhile(nodesToIntersect.length > 0) {\n\t\t\tconst node:BVHNode | undefined = nodesToIntersect.pop();\n\t\t\tif(!node) continue;\n\t\t\tif(BVH.intersectNodeBox(rayOrigin, invRayDirection, node)) {\n\t\t\t\tif(node.node0) {\n\t\t\t\t\tnodesToIntersect.push(node.node0);\n\t\t\t\t}\n\t\t\t\tif(node.node1) {\n\t\t\t\t\tnodesToIntersect.push(node.node1);\n\t\t\t\t}\n\t\t\t\tfor(let i = node.startIndex; i < node.endIndex; i++) {\n\t\t\t\t\ttrianglesInIntersectingNodes.push(this.bboxArray[i*7]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// go over the list of candidate triangles, and check each of them using ray triangle intersection\n\t\tlet a:BVHVector3 = new BVHVector3();\n\t\tlet b:BVHVector3 = new BVHVector3();\n\t\tlet c:BVHVector3 = new BVHVector3();\n\n\t\tfor(let i = 0; i < trianglesInIntersectingNodes.length; i++) {\n\t\t\tconst triIndex = trianglesInIntersectingNodes[i];\n\n\t\t\ta.setFromArray(this.trianglesArray, triIndex*9);\n\t\t\tb.setFromArray(this.trianglesArray, triIndex*9+3);\n\t\t\tc.setFromArray(this.trianglesArray, triIndex*9+6);\n\n\t\t\tconst intersectionPoint = BVH.intersectRayTriangle(a, b, c, rayOrigin, rayDirection, backfaceCulling);\n\n\t\t\tif(!intersectionPoint) continue;\n\t\t\tintersectingTriangles.push({\n\t\t\t\t//triangle: [a.clone(), b.clone(), c.clone()],\n\t\t\t\ttriangleIndex: triIndex,\n\t\t\t\tintersectionPoint: intersectionPoint\n\t\t\t});\n\t\t}\n\n\t\treturn intersectingTriangles;\n\t}\n\tstatic calcTValues(minVal:number, maxVal:number, rayOriginCoord:number, invdir: number):number[] {\n\t\tif(invdir >= 0) {\n\t\t\treturn [(minVal - rayOriginCoord) * invdir, (maxVal - rayOriginCoord) * invdir];\n\t\t} else {\n\t\t\treturn [(maxVal - rayOriginCoord) * invdir, (minVal - rayOriginCoord) * invdir];\n\t\t}\n\t}\n\n\tstatic intersectNodeBox(rayOrigin: BVHVector3, invRayDirection: BVHVector3, node: BVHNode):boolean {\n\t\tlet [tmin, tmax]:number[] = BVH.calcTValues(node.extentsMin[0], node.extentsMax[0], rayOrigin.x, invRayDirection.x);\n\t\tlet [tymin, tymax]:number[] = BVH.calcTValues(node.extentsMin[1], node.extentsMax[1], rayOrigin.y, invRayDirection.y);\n\n\t\tif(tmin > tymax || tymin > tmax) return false;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\tif(tymin > tmin || tmin !== tmin) {\n\t\t\ttmin = tymin;\n\t\t}\n\n\t\tif(tymax < tmax || tmax !== tmax) {\n\t\t\ttmax = tymax;\n\t\t}\n\n\t\tlet [tzmin, tzmax]:number[] = BVH.calcTValues(node.extentsMin[2], node.extentsMax[2], rayOrigin.z, invRayDirection.z);\n\n\t\tif(tmin > tzmax || tzmin > tmax) return false;\n\n\t\tif(tzmax < tmax || tmax !== tmax) {\n\t\t\ttmax = tzmax;\n\t\t}\n\n\t\t//return point closest to the ray (positive side)\n\t\tif(tmax < 0) return false;\n\n\t\treturn true;\n\t}\n\n\tstatic intersectRayTriangle(a:BVHVector3, b:BVHVector3, c:BVHVector3, rayOrigin:BVHVector3, rayDirection:BVHVector3, backfaceCulling:boolean):BVHVector3 | null {\n\t\tvar diff:BVHVector3 = new BVHVector3();\n\t\tvar edge1:BVHVector3 = new BVHVector3();\n\t\tvar edge2:BVHVector3 = new BVHVector3();\n\t\tvar normal:BVHVector3 = new BVHVector3();\n\n\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\n\t\tedge1.subVectors(b, a);\n\t\tedge2.subVectors(c, a);\n\t\tnormal.crossVectors(edge1, edge2);\n\n\t\t// Solve Q + t*D = b1*E1 + bL*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN:number = rayDirection.dot(normal);\n\t\tif(DdN === 0) return null;\n\t\tif(DdN > 0 && backfaceCulling) return null;\n\t\tlet sign:number = Math.sign(DdN);\n\t\tDdN *= sign;\n\n\t\tdiff.subVectors(rayOrigin, a);\n\t\tvar DdQxE2 = sign * rayDirection.dot(edge2.crossVectors(diff, edge2));\n\n\t\t// b1 < 0, no intersection\n\t\tif(DdQxE2 < 0) return null;\n\n\t\tvar DdE1xQ = sign * rayDirection.dot(edge1.cross(diff));\n\n\t\t// b2 < 0, no intersection\n\t\tif(DdE1xQ < 0) return null;\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif(DdQxE2 + DdE1xQ > DdN) return null;\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN:number = -sign * diff.dot(normal);\n\n\t\t// t < 0, no intersection\n\t\tif(QdN < 0) return null;\n\n\t\t// Ray intersects triangle.\n\t\treturn rayDirection.clone().multiplyScalar(QdN / DdN).add(rayOrigin);\n\t}\n}\n","import { BVHNode } from \"./BVHNode\";\nimport { BVH } from \"./BVH\";\nimport { asyncWork } from './utils'\n\ndeclare global {\n\tinterface XYZ {\n\t\t0: number,\n\t\t1: number,\n\t\t2: number\n\t}\n\t\n\tinterface Vector {\n\t\tx: number;\n\t\ty: number;\n\t\tz: number;\n\t}\n\n\ttype Evaluator = () => number;\n\ttype Work = () => void;\n\ttype WorkProgress = {nodesSplit: number};\n\ttype WorkProgressCallback = (progressObj:WorkProgress) => void;\n\ttype BVHProgress = {nodesSplit: number, trianglesLeafed: number};\n\ttype AsyncifyParams = {ms?: number, steps?: number};\n}\n\nconst EPSILON = 1e-6;\n\nexport function BVHBuilder(triangles:unknown | Vector[][] | number[] | Float32Array, maxTrianglesPerNode:number = 10) {\n\tif(typeof maxTrianglesPerNode !== 'number') throw new Error(`maxTrianglesPerNode must be of type number, got: ${typeof maxTrianglesPerNode}`);\n\tif(maxTrianglesPerNode < 1) throw new Error(`maxTrianglesPerNode must be greater than or equal to 1, got: ${maxTrianglesPerNode}`);\n\tif(Number.isNaN(maxTrianglesPerNode)) throw new Error(`maxTrianglesPerNode is NaN`);\n\tif(!Number.isInteger(maxTrianglesPerNode)) console.warn(`maxTrianglesPerNode is expected to be an integer, got: ${maxTrianglesPerNode}`);\n\tlet trianglesArray:Float32Array;\n\t//Vector[][] | number[] | Float32Array\n\tif(Array.isArray(triangles) && triangles.length === 0) {\n\t\tconsole.warn(`triangles appears to be an array with 0 elements.`);\n\t}\n\tif(isFaceArray(triangles)) {\n\t\ttrianglesArray = buildTriangleArray(triangles);\n\t} else if (triangles instanceof Float32Array) {\n\t\ttrianglesArray = triangles;\n\t} else if (isNumberArray(triangles)) {\n\t\ttrianglesArray = new Float32Array(triangles)\n\t} else {\n\t\tthrow new Error(`triangles must be of type Vector[][] | number[] | Float32Array, got: ${typeof triangles}`);\n\t}\n\tlet bboxArray:Float32Array = calcBoundingBoxes(trianglesArray);\n\t// clone a helper array\n\tlet bboxHelper:Float32Array = new Float32Array(bboxArray.length);\n\tbboxHelper.set(bboxArray);\n\n\t// create the root node, add all the triangles to it\n\tvar triangleCount:number = trianglesArray.length / 9;\n\tvar extents:XYZ[] = calcExtents(bboxArray, 0, triangleCount, EPSILON);\n\tlet rootNode:BVHNode = new BVHNode(extents[0], extents[1], 0, triangleCount, 0);\n\tlet nodesToSplit:BVHNode[] = [rootNode];\n\tlet node:BVHNode | undefined;\n\n\twhile(node = nodesToSplit.pop()) {\n\t\tlet nodes = splitNode(node, maxTrianglesPerNode, bboxArray, bboxHelper);\n\t\tnodesToSplit.push(...nodes);\n\t}\n\t\n\treturn new BVH(rootNode, bboxArray, trianglesArray);\n}\n\nexport async function BVHBuilderAsync(triangles:unknown | Vector[][] | number[] | Float32Array, maxTrianglesPerNode:number = 10, asyncParams:AsyncifyParams = {}, progressCallback?:(obj:BVHProgress) => void):Promise<BVH> {\n\tif(typeof maxTrianglesPerNode !== 'number') throw new Error(`maxTrianglesPerNode must be of type number, got: ${typeof maxTrianglesPerNode}`);\n\tif(maxTrianglesPerNode < 1) throw new Error(`maxTrianglesPerNode must be greater than or equal to 1, got: ${maxTrianglesPerNode}`);\n\tif(Number.isNaN(maxTrianglesPerNode)) throw new Error(`maxTrianglesPerNode is NaN`);\n\tif(!Number.isInteger(maxTrianglesPerNode)) console.warn(`maxTrianglesPerNode is expected to be an integer, got: ${maxTrianglesPerNode}`);\n\tlet trianglesArray:Float32Array;\n\t//Vector[][] | number[] | Float32Array\n\tif(Array.isArray(triangles) && triangles.length === 0) {\n\t\tconsole.warn(`triangles appears to be an array with 0 elements.`);\n\t}\n\tif(isFaceArray(triangles)) {\n\t\ttrianglesArray = buildTriangleArray(triangles);\n\t} else if (triangles instanceof Float32Array) {\n\t\ttrianglesArray = triangles;\n\t} else if (isNumberArray(triangles)) {\n\t\ttrianglesArray = new Float32Array(triangles)\n\t} else {\n\t\tthrow new Error(`triangles must be of type Vector[][] | number[] | Float32Array, got: ${typeof triangles}`);\n\t}\n\tlet bboxArray:Float32Array = calcBoundingBoxes(trianglesArray);\n\t// clone a helper array\n\tlet bboxHelper:Float32Array = new Float32Array(bboxArray.length);\n\tbboxHelper.set(bboxArray);\n\n\t// create the root node, add all the triangles to it\n\tvar triangleCount:number = trianglesArray.length / 9;\n\tvar extents:XYZ[] = calcExtents(bboxArray, 0, triangleCount, EPSILON);\n\tlet rootNode:BVHNode = new BVHNode(extents[0], extents[1], 0, triangleCount, 0);\n\tlet nodesToSplit:BVHNode[] = [rootNode];\n\tlet node:BVHNode | undefined;\n\n\tlet tally = 0;\n\tawait asyncWork(() => {\n\t\tnode = nodesToSplit.pop();\n\t\treturn tally * 9 / trianglesArray.length;\n\t}, () => {\n\t\tif(!node) return;\n\t\tlet nodes = splitNode(node, maxTrianglesPerNode, bboxArray, bboxHelper);\n\t\tif(!nodes.length) tally += node.elementCount();\n\t\tnodesToSplit.push(...nodes);\n\t}, asyncParams, progressCallback ?\n\t\t(nodesSplit:WorkProgress) => progressCallback(Object.assign({trianglesLeafed: tally}, nodesSplit))\n\t\t: undefined\n\t);\n\treturn new BVH(rootNode, bboxArray, trianglesArray);\n}\n\nfunction splitNode(node: BVHNode, maxTriangles:number, bboxArray:Float32Array, bboxHelper:Float32Array):BVHNode[] {\n\tconst nodeCount:number = node.elementCount()\n\tif (nodeCount <= maxTriangles || nodeCount === 0) return [];\n\n\tlet startIndex:number = node.startIndex;\n\tlet endIndex:number = node.endIndex;\n\n\tlet leftNode:number[][] = [ [],[],[] ];\n\tlet rightNode:number[][] = [ [],[],[] ];\n\tlet extentCenters:number[] = [node.centerX(), node.centerY(), node.centerZ()];\n\n\tlet objectCenter:number[] = [];\n\tobjectCenter.length = 3;\n\n\tfor (let i = startIndex; i < endIndex; i++) {\n\t\tlet idx = i * 7 + 1;\n\t\tobjectCenter[0] = (bboxArray[idx] + bboxArray[idx++ + 3]) * 0.5; // center = (min + max) / 2\n\t\tobjectCenter[1] = (bboxArray[idx] + bboxArray[idx++ + 3]) * 0.5; // center = (min + max) / 2\n\t\tobjectCenter[2] = (bboxArray[idx] + bboxArray[idx + 3]) * 0.5; // center = (min + max) / 2\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tif (objectCenter[j] < extentCenters[j]) {\n\t\t\t\tleftNode[j].push(i);\n\t\t\t} else {\n\t\t\t\trightNode[j].push(i);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check if we couldn't split the node by any of the axes (x, y or z). halt here, dont try to split any more (cause it will always fail, and we'll enter an infinite loop\n\tvar splitFailed:boolean[] = [];\n\tsplitFailed.length = 3;\n\n\tsplitFailed[0] = (leftNode[0].length === 0) || (rightNode[0].length === 0);\n\tsplitFailed[1] = (leftNode[1].length === 0) || (rightNode[1].length === 0);\n\tsplitFailed[2] = (leftNode[2].length === 0) || (rightNode[2].length === 0);\n\n\tif (splitFailed[0] && splitFailed[1] && splitFailed[2]) return [];\n\n\t// choose the longest split axis. if we can't split by it, choose next best one.\n\tvar splitOrder = [0, 1, 2];\n\n\tvar extentsLength = [\n\t\tnode.extentsMax[0] - node.extentsMin[0],\n\t\tnode.extentsMax[1] - node.extentsMin[1],\n\t\tnode.extentsMax[2] - node.extentsMin[2]\n\t];\n\n\tsplitOrder.sort((axis0, axis1) => extentsLength[axis1] - extentsLength[axis0]);\n\n\tlet leftElements:number[] | undefined = [];\n\tlet rightElements:number[] | undefined = [];\n\n\tfor (let j = 0; j < 3; j++) {\n\t\tvar candidateIndex = splitOrder[j];\n\t\tif (!splitFailed[candidateIndex]) {\n\t\t\tleftElements = leftNode[candidateIndex];\n\t\t\trightElements = rightNode[candidateIndex];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t// sort the elements in range (startIndex, endIndex) according to which node they should be at\n\tvar node0Start = startIndex;\n\tvar node0End = node0Start + leftElements.length;\n\tvar node1Start = node0End;\n\tvar node1End = endIndex;\n\t\n\tcopyBoxes(leftElements, rightElements, node.startIndex, bboxArray, bboxHelper);\n\n\t// copy results back to main array\n\tvar subArr = bboxHelper.subarray(node.startIndex * 7, node.endIndex * 7);\n\tbboxArray.set(subArr, node.startIndex * 7);\n\n\t// create 2 new nodes for the node we just split, and add links to them from the parent node\n\tvar node0Extents = calcExtents(bboxArray, node0Start, node0End, EPSILON);\n\tvar node1Extents = calcExtents(bboxArray, node1Start, node1End, EPSILON);\n\n\tvar node0 = new BVHNode(node0Extents[0], node0Extents[1], node0Start, node0End, node.level + 1);\n\tvar node1 = new BVHNode(node1Extents[0], node1Extents[1], node1Start, node1End, node.level + 1);\n\n\tnode.node0 = node0;\n\tnode.node1 = node1;\n\tnode.clearShapes();\n\n\t// add new nodes to the split queue\n\treturn [node0, node1];\n}\n\nfunction copyBoxes(leftElements:number[], rightElements:number[], startIndex:number, bboxArray:Float32Array, bboxHelper:Float32Array) {\n\tvar concatenatedElements = leftElements.concat(rightElements);\n\tvar helperPos = startIndex;\n\tfor (let i = 0; i < concatenatedElements.length; i++) {\n\t\tlet currElement = concatenatedElements[i];\n\t\tcopyBox(bboxArray, currElement, bboxHelper, helperPos);\n\t\thelperPos++;\n\t}\n}\n\nfunction calcExtents(bboxArray:Float32Array, startIndex:number, endIndex:number, expandBy: number = 0.0):XYZ[] {\n\tif (startIndex >= endIndex) return [[0, 0, 0], [0, 0, 0]];\n\tlet minX = Infinity;\n\tlet minY = Infinity;\n\tlet minZ = Infinity;\n\tlet maxX = -Infinity;\n\tlet maxY = -Infinity;\n\tlet maxZ = -Infinity;\n\tfor (let i = startIndex; i < endIndex; i++) {\n\t\tlet idx = i * 7 + 1;\n\t\tminX = Math.min(bboxArray[idx++], minX);\n\t\tminY = Math.min(bboxArray[idx++], minY);\n\t\tminZ = Math.min(bboxArray[idx++], minZ);\n\t\tmaxX = Math.max(bboxArray[idx++], maxX);\n\t\tmaxY = Math.max(bboxArray[idx++], maxY);\n\t\tmaxZ = Math.max(bboxArray[idx], maxZ);\n\t}\n\treturn [\n\t\t[minX - expandBy, minY - expandBy, minZ - expandBy],\n\t\t[maxX + expandBy, maxY + expandBy, maxZ + expandBy]\n\t];\n}\n\nfunction calcBoundingBoxes(trianglesArray: Float32Array):Float32Array {\n\tconst triangleCount:number = trianglesArray.length / 9;\n\tconst bboxArray:Float32Array = new Float32Array(triangleCount * 7);\n\n\tfor (let i = 0; i < triangleCount; i++) {\n\t\tlet idx = i * 9;\n\t\tconst p0x = trianglesArray[idx++];\n\t\tconst p0y = trianglesArray[idx++];\n\t\tconst p0z = trianglesArray[idx++];\n\t\tconst p1x = trianglesArray[idx++];\n\t\tconst p1y = trianglesArray[idx++];\n\t\tconst p1z = trianglesArray[idx++];\n\t\tconst p2x = trianglesArray[idx++];\n\t\tconst p2y = trianglesArray[idx++];\n\t\tconst p2z = trianglesArray[idx];\n\n\t\tconst minX = Math.min(p0x, p1x, p2x);\n\t\tconst minY = Math.min(p0y, p1y, p2y);\n\t\tconst minZ = Math.min(p0z, p1z, p2z);\n\t\tconst maxX = Math.max(p0x, p1x, p2x);\n\t\tconst maxY = Math.max(p0y, p1y, p2y);\n\t\tconst maxZ = Math.max(p0z, p1z, p2z);\n\t\tsetBox(bboxArray, i, i, minX, minY, minZ, maxX, maxY, maxZ);\n\t}\n\n\treturn bboxArray;\n}\n\nfunction buildTriangleArray(triangles:Vector[][]):Float32Array {\n\tconst trianglesArray = new Float32Array(triangles.length * 9);\n\n\tfor (let i = 0; i < triangles.length; i++) {\n\t\tconst p0 = triangles[i][0];\n\t\tconst p1 = triangles[i][1];\n\t\tconst p2 = triangles[i][2];\n\t\tlet idx = i * 9;\n\t\ttrianglesArray[idx++] = p0.x;\n\t\ttrianglesArray[idx++] = p0.y;\n\t\ttrianglesArray[idx++] = p0.z;\n\n\t\ttrianglesArray[idx++] = p1.x;\n\t\ttrianglesArray[idx++] = p1.y;\n\t\ttrianglesArray[idx++] = p1.z;\n\n\t\ttrianglesArray[idx++] = p2.x;\n\t\ttrianglesArray[idx++] = p2.y;\n\t\ttrianglesArray[idx] = p2.z;\n\t}\n\n\treturn trianglesArray;\n}\n\nfunction setBox(bboxArray:Float32Array, pos:number, triangleId:number, minX:number, minY:number, minZ:number, maxX:number, maxY:number, maxZ:number):void {\n\tlet idx = pos * 7;\n\tbboxArray[idx++] = triangleId;\n\tbboxArray[idx++] = minX;\n\tbboxArray[idx++] = minY;\n\tbboxArray[idx++] = minZ;\n\tbboxArray[idx++] = maxX;\n\tbboxArray[idx++] = maxY;\n\tbboxArray[idx] = maxZ;\n}\n\nfunction copyBox(sourceArray:Float32Array, sourcePos:number, destArray:Float32Array, destPos:number):void {\n\tlet idx = destPos * 7;\n\tlet jdx = sourcePos * 7;\n\tdestArray[idx++] = sourceArray[jdx++];\n\tdestArray[idx++] = sourceArray[jdx++];\n\tdestArray[idx++] = sourceArray[jdx++];\n\tdestArray[idx++] = sourceArray[jdx++];\n\tdestArray[idx++] = sourceArray[jdx++];\n\tdestArray[idx++] = sourceArray[jdx++];\n\tdestArray[idx] = sourceArray[jdx];\n}\n\nfunction isFaceArray(testArray: unknown): testArray is Vector[][] {\n\tif(!Array.isArray(testArray)) return false;\n\tfor(let i = 0; i < testArray.length; i++) {\n\t\tconst face = testArray[i];\n\t\tif(!Array.isArray(face)) return false;\n\t\tif(face.length !== 3) return false;\n\t\tfor(let j = 0; j < 3; j++) {\n\t\t\tconst vertex:Vector = face[j] as Vector;\n\t\t\tif(typeof vertex.x !== \"number\" || typeof vertex.y !== \"number\" || typeof vertex.z !== \"number\") return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction isNumberArray(testArray: unknown): testArray is number[] {\n\tif(!Array.isArray(testArray)) return false;\n\tfor(let i = 0; i < testArray.length; i++) {\n\t\tif(typeof testArray[i] !== \"number\") return false;\n\t}\n\treturn true;\n}\n","import { Vector3, Triangle } from 'three';\nimport { TessellateModifier } from './TessellateModifier';\nimport Room from '../../objects/room';\nimport Surface from '../../objects/surface';\nimport { BVH } from '../raytracer/bvh/BVH';\nimport { BVHBuilder } from '../raytracer/bvh/BVHBuilder';\n\nexport interface Patch {\n  index: number;\n  centroid: Vector3;\n  normal: Vector3;\n  area: number;\n  vertices: [Vector3, Vector3, Vector3];\n  surfaceIndex: number;\n  absorption: (freq: number) => number;\n  scattering: (freq: number) => number;\n}\n\nexport interface PatchSet {\n  patches: Patch[];\n  bvh: BVH;\n  /** Maps BVH triangle index to patch index */\n  triangleToPatch: number[];\n}\n\n/**\n * Tessellates all room surfaces into patches and builds a BVH for ray intersection.\n */\nexport function buildPatchesFromRoom(room: Room, maxEdgeLength: number): PatchSet {\n  const surfaces = room.allSurfaces as Surface[];\n  const patches: Patch[] = [];\n  const allTriangleVertices: number[][] = [];\n  const triangleToPatch: number[] = [];\n\n  const tessellator = new TessellateModifier(maxEdgeLength, 6);\n\n  for (let si = 0; si < surfaces.length; si++) {\n    const surface = surfaces[si];\n    const geom = surface.geometry.clone();\n\n    // Tessellate the surface geometry\n    const tessellated = tessellator.modify(geom);\n    const posAttr = tessellated.getAttribute('position');\n    const posArray = posAttr.array as Float32Array;\n    const triCount = posArray.length / 9;\n\n    for (let t = 0; t < triCount; t++) {\n      const offset = t * 9;\n      // Vertices in local space\n      const vA = new Vector3(posArray[offset], posArray[offset + 1], posArray[offset + 2]);\n      const vB = new Vector3(posArray[offset + 3], posArray[offset + 4], posArray[offset + 5]);\n      const vC = new Vector3(posArray[offset + 6], posArray[offset + 7], posArray[offset + 8]);\n\n      // Transform to world space\n      const wA = surface.localToWorld(vA.clone());\n      const wB = surface.localToWorld(vB.clone());\n      const wC = surface.localToWorld(vC.clone());\n\n      const tri = new Triangle(wA, wB, wC);\n      const area = tri.getArea();\n      if (area < 1e-10) continue; // Skip degenerate triangles\n\n      const centroid = new Vector3();\n      tri.getMidpoint(centroid);\n\n      const normal = new Vector3();\n      tri.getNormal(normal);\n\n      const patchIndex = patches.length;\n\n      patches.push({\n        index: patchIndex,\n        centroid,\n        normal,\n        area,\n        vertices: [wA, wB, wC],\n        surfaceIndex: si,\n        absorption: surface.absorptionFunction,\n        scattering: surface.scatteringFunction || (() => surface.scatteringCoefficient),\n      });\n\n      // Store flat vertex array for BVH builder\n      allTriangleVertices.push([\n        wA.x, wA.y, wA.z,\n        wB.x, wB.y, wB.z,\n        wC.x, wC.y, wC.z,\n      ]);\n      triangleToPatch.push(patchIndex);\n    }\n  }\n\n  // Build BVH from all patch triangles\n  const flatArray = new Float32Array(allTriangleVertices.length * 9);\n  for (let i = 0; i < allTriangleVertices.length; i++) {\n    for (let j = 0; j < 9; j++) {\n      flatArray[i * 9 + j] = allTriangleVertices[i][j];\n    }\n  }\n  const bvh = BVHBuilder(flatArray);\n\n  return { patches, bvh, triangleToPatch };\n}\n\n/**\n * Sample a random point on a triangle using barycentric coordinates.\n */\nexport function samplePointOnPatch(patch: Patch): Vector3 {\n  let u = Math.random();\n  let v = Math.random();\n  if (u + v > 1) {\n    u = 1 - u;\n    v = 1 - v;\n  }\n  const w = 1 - u - v;\n  return new Vector3(\n    patch.vertices[0].x * u + patch.vertices[1].x * v + patch.vertices[2].x * w,\n    patch.vertices[0].y * u + patch.vertices[1].y * v + patch.vertices[2].y * w,\n    patch.vertices[0].z * u + patch.vertices[1].z * v + patch.vertices[2].z * w,\n  );\n}\n","import { Vector3 } from 'three';\nimport { BRDF } from './brdf';\nimport { DirectionalResponse } from './directional-response';\nimport { Response } from './response';\nimport { PatchSet, samplePointOnPatch } from './patch';\n\nexport interface ShootingContext {\n  patchSet: PatchSet;\n  unshotEnergy: DirectionalResponse[];\n  totalEnergy: DirectionalResponse[];\n  brdf: BRDF;\n  /** Per-patch absorption at the current frequency */\n  absorptions: number[];\n  /** Per-patch scattering at the current frequency */\n  scatterings: number[];\n  /** Air absorption coefficient in Nepers/m at the current frequency */\n  airAbsNepers: number;\n  /** Speed of sound in m/s */\n  speedOfSound: number;\n  /** Internal sample rate for time discretization */\n  sampleRate: number;\n  /** Number of rays per shooting iteration */\n  raysPerShoot: number;\n}\n\n/**\n * Select the patch with the most unshot energy.\n */\nexport function selectShootingPatch(unshotEnergy: DirectionalResponse[]): number {\n  let maxEnergy = -1;\n  let maxIdx = 0;\n  for (let i = 0; i < unshotEnergy.length; i++) {\n    const e = unshotEnergy[i].sum();\n    if (e > maxEnergy) {\n      maxEnergy = e;\n      maxIdx = i;\n    }\n  }\n  return maxIdx;\n}\n\n/**\n * Compute total unshot energy across all patches.\n */\nexport function totalUnshotEnergy(unshotEnergy: DirectionalResponse[]): number {\n  let total = 0;\n  for (let i = 0; i < unshotEnergy.length; i++) {\n    total += unshotEnergy[i].sum();\n  }\n  return total;\n}\n\n/**\n * Shoot energy from a single patch to all visible patches via ray tracing.\n */\nexport function shootFromPatch(ctx: ShootingContext, patchIdx: number): void {\n  const { patchSet, unshotEnergy, totalEnergy, brdf, airAbsNepers, speedOfSound, sampleRate, raysPerShoot } = ctx;\n  const { patches, bvh, triangleToPatch } = patchSet;\n  const srcPatch = patches[patchIdx];\n  const srcEnergy = unshotEnergy[patchIdx];\n\n  // Distribute rays across BRDF slots proportional to energy\n  const slotEnergies: number[] = [];\n  let totalSlotEnergy = 0;\n  for (let k = 0; k < brdf.nSlots; k++) {\n    const e = srcEnergy.responses[k].sum();\n    slotEnergies.push(e);\n    totalSlotEnergy += e;\n  }\n\n  if (totalSlotEnergy < 1e-20) return;\n\n  for (let k = 0; k < brdf.nSlots; k++) {\n    if (slotEnergies[k] < 1e-20) continue;\n\n    const fraction = slotEnergies[k] / totalSlotEnergy;\n    const nRays = Math.max(1, Math.round(fraction * raysPerShoot));\n    const gain = 1.0 / nRays;\n\n    for (let r = 0; r < nRays; r++) {\n      // Generate ray origin: random point on source patch\n      const origin = samplePointOnPatch(srcPatch);\n\n      // Generate ray direction within BRDF slot k\n      const localDir = sampleDirectionInSlot(brdf, k);\n      const worldDir = localToWorld(localDir, srcPatch.normal);\n\n      // Trace ray through BVH\n      const hits = bvh.intersectRay(origin, worldDir, false);\n      if (!hits || hits.length === 0) continue;\n\n      // Find the closest hit that isn't the source patch itself\n      let closestHit: any = null;\n      let closestDist = Infinity;\n      for (const hit of hits) {\n        const hitPatchIdx = triangleToPatch[hit.triangleIndex];\n        if (hitPatchIdx === patchIdx) continue;\n        const hitPoint = hit.intersectionPoint;\n        const dx = hitPoint.x - origin.x;\n        const dy = hitPoint.y - origin.y;\n        const dz = hitPoint.z - origin.z;\n        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (dist < closestDist) {\n          closestDist = dist;\n          closestHit = hit;\n        }\n      }\n\n      if (!closestHit || closestDist < 1e-6) continue;\n\n      const rcvPatchIdx = triangleToPatch[closestHit.triangleIndex];\n      const rcvPatch = patches[rcvPatchIdx];\n\n      // Propagation delay in samples\n      const delaySamples = (closestDist / speedOfSound) * sampleRate;\n\n      // Air absorption attenuation\n      const airAtten = Math.exp(-airAbsNepers * closestDist);\n\n      // Compute incoming direction at receiver using ray direction (not centroid)\n      const incomingSlot = brdf.getDirectionIndex(worldDir.clone().negate(), rcvPatch.normal);\n\n      // Get outgoing weights from receiver's BRDF\n      // Recompute BRDF coefficients for receiver patch material\n      const rcvAbsorption = ctx.absorptions[rcvPatchIdx];\n      const rcvScattering = ctx.scatterings[rcvPatchIdx];\n      brdf.computeCoefficients(rcvAbsorption, rcvScattering);\n      const outgoingWeights = brdf.getOutgoingWeights(incomingSlot);\n\n      // Deposit energy at receiver patch\n      const sourceResponse = srcEnergy.responses[k];\n      const scaledGain = gain * airAtten;\n\n      for (let outSlot = 0; outSlot < brdf.nSlots; outSlot++) {\n        const weight = outgoingWeights[outSlot] * scaledGain;\n        if (weight < 1e-20) continue;\n        unshotEnergy[rcvPatchIdx].responses[outSlot].delayMultiplyAdd(\n          sourceResponse, delaySamples, weight\n        );\n        totalEnergy[rcvPatchIdx].responses[outSlot].delayMultiplyAdd(\n          sourceResponse, delaySamples, weight\n        );\n      }\n    }\n  }\n\n  // Clear unshot energy of the shooting patch\n  srcEnergy.clear();\n}\n\n/**\n * Inject source emission into visible patches.\n */\nexport function injectSourceEnergy(\n  sourcePosition: Vector3,\n  initialEnergy: number,\n  ctx: ShootingContext,\n  nRays: number = 500\n): void {\n  const { patchSet, unshotEnergy, totalEnergy, brdf, airAbsNepers, speedOfSound, sampleRate } = ctx;\n  const { patches, bvh, triangleToPatch } = patchSet;\n\n  const gain = initialEnergy / nRays;\n\n  for (let r = 0; r < nRays; r++) {\n    // Random direction on full sphere from source\n    const dir = randomSphereDirection();\n\n    const hits = bvh.intersectRay(sourcePosition, dir, false);\n    if (!hits || hits.length === 0) continue;\n\n    // Find closest hit\n    let closestHit: any = null;\n    let closestDist = Infinity;\n    for (const hit of hits) {\n      const hitPoint = hit.intersectionPoint;\n      const dx = hitPoint.x - sourcePosition.x;\n      const dy = hitPoint.y - sourcePosition.y;\n      const dz = hitPoint.z - sourcePosition.z;\n      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n      if (dist < closestDist) {\n        closestDist = dist;\n        closestHit = hit;\n      }\n    }\n\n    if (!closestHit || closestDist < 1e-6) continue;\n\n    const patchIdx = triangleToPatch[closestHit.triangleIndex];\n    const patch = patches[patchIdx];\n\n    const delaySamples = (closestDist / speedOfSound) * sampleRate;\n    const airAtten = Math.exp(-airAbsNepers * closestDist);\n\n    // Direction arriving at the patch\n    const fromSource = dir.clone().negate();\n    const incomingSlot = brdf.getDirectionIndex(fromSource, patch.normal);\n\n    // Apply BRDF at receiving patch\n    const patchAbsorption = ctx.absorptions[patchIdx];\n    const patchScattering = ctx.scatterings[patchIdx];\n    brdf.computeCoefficients(patchAbsorption, patchScattering);\n    const outWeights = brdf.getOutgoingWeights(incomingSlot);\n\n    // Create a unit impulse as the source emission\n    const impulse = new Response(1);\n    impulse.buffer[0] = gain * airAtten;\n\n    for (let outSlot = 0; outSlot < brdf.nSlots; outSlot++) {\n      const w = outWeights[outSlot];\n      if (w < 1e-20) continue;\n      unshotEnergy[patchIdx].responses[outSlot].delayMultiplyAdd(impulse, delaySamples, w);\n      totalEnergy[patchIdx].responses[outSlot].delayMultiplyAdd(impulse, delaySamples, w);\n    }\n  }\n}\n\n/**\n * Gather energy at a receiver position from all visible patches.\n * Returns a single time-domain response buffer (the impulse response).\n */\nexport function gatherAtReceiver(\n  receiverPosition: Vector3,\n  ctx: ShootingContext\n): Response {\n  const { patchSet, totalEnergy, brdf, airAbsNepers, speedOfSound, sampleRate } = ctx;\n  const { patches, bvh, triangleToPatch } = patchSet;\n\n  // Start with a generous response length\n  const result = new Response(1);\n\n  for (let i = 0; i < patches.length; i++) {\n    const patch = patches[i];\n\n    // Direction from patch to receiver\n    const toReceiver = new Vector3().subVectors(receiverPosition, patch.centroid);\n    const dist = toReceiver.length();\n    if (dist < 1e-6) continue;\n    toReceiver.normalize();\n\n    // Check if the patch normal faces toward the receiver\n    const cosTheta = patch.normal.dot(toReceiver);\n    if (cosTheta <= 0) continue;\n\n    // Visibility check: trace ray from patch centroid to receiver\n    const hits = bvh.intersectRay(patch.centroid, toReceiver, false);\n    let occluded = false;\n    if (hits) {\n      for (const hit of hits) {\n        const hitPatchIdx = triangleToPatch[hit.triangleIndex];\n        if (hitPatchIdx === i) continue;\n        const hitPoint = hit.intersectionPoint;\n        const hitDist = new Vector3(\n          hitPoint.x - patch.centroid.x,\n          hitPoint.y - patch.centroid.y,\n          hitPoint.z - patch.centroid.z\n        ).length();\n        if (hitDist < dist - 0.01) {\n          occluded = true;\n          break;\n        }\n      }\n    }\n    if (occluded) continue;\n\n    // Propagation delay and attenuation\n    const delaySamples = (dist / speedOfSound) * sampleRate;\n    const airAtten = Math.exp(-airAbsNepers * dist);\n\n    // Solid angle subtended by patch as seen from receiver\n    const solidAngle = (patch.area * cosTheta) / (dist * dist);\n\n    // Get the direction slot toward the receiver\n    const dirSlot = brdf.getDirectionIndex(toReceiver, patch.normal);\n\n    // Gather from the energy in this direction\n    const patchResponse = totalEnergy[i].responses[dirSlot];\n    const weight = solidAngle * airAtten;\n    result.delayMultiplyAdd(patchResponse, delaySamples, weight);\n  }\n\n  return result;\n}\n\n/**\n * Generate a random direction on the unit sphere.\n */\nfunction randomSphereDirection(): Vector3 {\n  const theta = Math.acos(2 * Math.random() - 1);\n  const phi = 2 * Math.PI * Math.random();\n  return new Vector3(\n    Math.sin(theta) * Math.cos(phi),\n    Math.sin(theta) * Math.sin(phi),\n    Math.cos(theta)\n  );\n}\n\n/**\n * Sample a direction within a BRDF hemisphere slot.\n * Generates a random direction biased toward the slot's center direction.\n */\nfunction sampleDirectionInSlot(brdf: BRDF, slotIdx: number): Vector3 {\n  const center = brdf.directions[slotIdx];\n  // Perturb around center direction with cosine-weighted distribution\n  const theta = Math.acos(Math.sqrt(Math.random())) * 0.5; // Half-angle spread\n  const phi = 2 * Math.PI * Math.random();\n\n  // Create a local frame around center\n  let tangent = new Vector3(1, 0, 0);\n  if (Math.abs(center.dot(tangent)) > 0.9) {\n    tangent = new Vector3(0, 1, 0);\n  }\n  const u = new Vector3().crossVectors(center, tangent).normalize();\n  const v = new Vector3().crossVectors(center, u).normalize();\n\n  const sinT = Math.sin(theta);\n  const cosT = Math.cos(theta);\n  const dir = new Vector3()\n    .addScaledVector(center, cosT)\n    .addScaledVector(u, sinT * Math.cos(phi))\n    .addScaledVector(v, sinT * Math.sin(phi));\n  dir.normalize();\n\n  // Clamp to hemisphere (z >= 0 in local frame)\n  if (dir.z < 0) dir.z = -dir.z;\n  dir.normalize();\n  return dir;\n}\n\n/**\n * Transform a local-frame direction (z-up = normal) to world space.\n */\nfunction localToWorld(localDir: Vector3, normal: Vector3): Vector3 {\n  const z = normal.clone().normalize();\n  let tangent = new Vector3(1, 0, 0);\n  if (Math.abs(z.dot(tangent)) > 0.9) {\n    tangent = new Vector3(0, 1, 0);\n  }\n  const x = new Vector3().crossVectors(z, tangent).normalize();\n  const y = new Vector3().crossVectors(z, x).normalize();\n\n  return new Vector3(\n    localDir.x * x.x + localDir.y * y.x + localDir.z * z.x,\n    localDir.x * x.y + localDir.y * y.y + localDir.z * z.y,\n    localDir.x * x.z + localDir.y * y.z + localDir.z * z.z,\n  ).normalize();\n}\n","import Solver, { SolverParams } from \"../solver\";\nimport { emit, on } from \"../../messenger\";\nimport { Vector3 } from \"three\";\nimport {\n  addSolver,\n  removeSolver,\n  setSolverProperty,\n  useContainer,\n  useResult\n} from \"../../store\";\nimport { v4 as uuid } from 'uuid';\nimport { ResultKind, Result } from \"../../store/result-store\";\nimport { whole_octave } from \"../acoustics\";\nimport { soundSpeed } from \"../acoustics/sound-speed\";\nimport { airAttenuation } from \"../acoustics/air-attenuation\";\nimport Room from \"../../objects/room\";\nimport Source from \"../../objects/source\";\nimport Receiver from \"../../objects/receiver\";\nimport { BRDF } from \"./brdf\";\nimport { DirectionalResponse } from \"./directional-response\";\nimport { Response } from \"./response\";\nimport { buildPatchesFromRoom } from \"./patch\";\nimport {\n  ShootingContext,\n  selectShootingPatch,\n  totalUnshotEnergy,\n  shootFromPatch,\n  injectSourceEnergy,\n  gatherAtReceiver,\n} from \"./form-factor\";\n\nexport interface ARTProps extends SolverParams {\n  roomID?: string;\n  sourceIDs?: string[];\n  receiverIDs?: string[];\n  maxEdgeLength?: number;\n  brdfDetail?: number;\n  raysPerShoot?: number;\n  maxIterations?: number;\n  convergenceThreshold?: number;\n  temperature?: number;\n  sampleRate?: number;\n}\n\nexport type ARTSaveObject = {\n  uuid: string;\n  name: string;\n  kind: string;\n  autoCalculate: boolean;\n  roomID?: string;\n  sourceIDs?: string[];\n  receiverIDs?: string[];\n  maxEdgeLength?: number;\n  brdfDetail?: number;\n  raysPerShoot?: number;\n  maxIterations?: number;\n  convergenceThreshold?: number;\n  temperature?: number;\n  sampleRate?: number;\n};\n\nconst defaults = {\n  name: \"Acoustic Radiance Transfer\"\n};\n\nexport class ART extends Solver {\n  public uuid: string;\n  public roomID: string;\n  public sourceIDs: string[];\n  public receiverIDs: string[];\n\n  /** Tessellation patch size in meters */\n  public maxEdgeLength: number;\n  /** Icosahedron subdivision level (0=6 bins, 1=~18 bins, 2=~66 bins) */\n  public brdfDetail: number;\n  /** Rays per shooting iteration */\n  public raysPerShoot: number;\n  /** Maximum shooting iterations */\n  public maxIterations: number;\n  /** Stop when unshot/initial < threshold */\n  public convergenceThreshold: number;\n  /** Temperature in Celsius for speed of sound and air absorption */\n  public temperature: number;\n  /** Internal temporal sample rate in Hz */\n  public sampleRate: number;\n  /** Octave band center frequencies to compute */\n  public frequencies: number[];\n  /** Initial source energy */\n  public initialEnergy: number;\n  /** Number of rays for source injection */\n  public sourceRays: number;\n\n  /** Iteration count from last calculation */\n  public lastIterationCount: number;\n  /** Patch count from last calculation */\n  public lastPatchCount: number;\n  /** Whether any results have been emitted */\n  public hasEmittedResults: boolean;\n\n  constructor(props: ARTProps = defaults) {\n    super(props);\n    this.kind = \"art\";\n    this.name = props.name || defaults.name;\n    this.uuid = uuid();\n\n    const rooms = useContainer.getState().getRooms();\n    this.roomID = props.roomID || (rooms.length > 0 ? rooms[0].uuid : '');\n\n    this.sourceIDs = props.sourceIDs || [];\n    this.receiverIDs = props.receiverIDs || [];\n\n    this.maxEdgeLength = props.maxEdgeLength ?? 0.5;\n    this.brdfDetail = props.brdfDetail ?? 1;\n    this.raysPerShoot = props.raysPerShoot ?? 200;\n    this.maxIterations = props.maxIterations ?? 100;\n    this.convergenceThreshold = props.convergenceThreshold ?? 0.01;\n    this.temperature = props.temperature ?? 20;\n    this.sampleRate = props.sampleRate ?? 1000;\n\n    this.frequencies = whole_octave.slice(4, 11); // 125 Hz to 8000 Hz\n    this.initialEnergy = 500;\n    this.sourceRays = 500;\n\n    this.lastIterationCount = 0;\n    this.lastPatchCount = 0;\n    this.hasEmittedResults = false;\n  }\n\n  calculate(): void {\n    const containers = useContainer.getState().containers;\n    const room = containers[this.roomID] as Room;\n    if (!room) {\n      console.error(\"ART: No room found\");\n      return;\n    }\n\n    // Find sources and receivers\n    const sources: Source[] = [];\n    const receivers: Receiver[] = [];\n    for (const id of this.sourceIDs) {\n      const s = containers[id];\n      if (s && s.kind === \"source\") sources.push(s as Source);\n    }\n    for (const id of this.receiverIDs) {\n      const r = containers[id];\n      if (r && r.kind === \"receiver\") receivers.push(r as Receiver);\n    }\n\n    if (sources.length === 0 || receivers.length === 0) {\n      console.warn(\"ART: Need at least one source and one receiver\");\n      return;\n    }\n\n    // Step 1: Tessellate and build patches\n    const c = soundSpeed(this.temperature);\n    const patchSet = buildPatchesFromRoom(room, this.maxEdgeLength);\n    const nPatches = patchSet.patches.length;\n    this.lastPatchCount = nPatches;\n\n    if (nPatches === 0) {\n      console.error(\"ART: Tessellation produced no patches\");\n      return;\n    }\n\n    // Step 2: Create BRDF\n    const brdf = new BRDF(this.brdfDetail);\n    const responseLength = Math.ceil(this.sampleRate * 5); // 5 second initial response\n\n    // Step 3: Run per frequency band\n    for (const source of sources) {\n      const sourcePos = new Vector3();\n      source.getWorldPosition(sourcePos);\n\n      for (const receiver of receivers) {\n        const receiverPos = new Vector3();\n        receiver.getWorldPosition(receiverPos);\n\n        // Accumulate broadband response from all frequency bands\n        const bandResponses: Response[] = [];\n\n        for (const freq of this.frequencies) {\n          // Per-band material properties\n          const absorptions: number[] = [];\n          const scatterings: number[] = [];\n          for (const patch of patchSet.patches) {\n            absorptions.push(patch.absorption(freq));\n            scatterings.push(patch.scattering(freq));\n          }\n\n          // Air absorption: convert from dB/m to Nepers/m\n          const airAbsDb = airAttenuation([freq], this.temperature)[0];\n          const airAbsNepers = airAbsDb / (20 / Math.LN10);\n\n          // Initialize energy buffers\n          const unshotEnergy: DirectionalResponse[] = [];\n          const totalEnergy: DirectionalResponse[] = [];\n          for (let i = 0; i < nPatches; i++) {\n            unshotEnergy[i] = new DirectionalResponse(brdf.nSlots, responseLength);\n            totalEnergy[i] = new DirectionalResponse(brdf.nSlots, responseLength);\n          }\n\n          // Build shooting context\n          const ctx: ShootingContext = {\n            patchSet,\n            unshotEnergy,\n            totalEnergy,\n            brdf,\n            absorptions,\n            scatterings,\n            airAbsNepers,\n            speedOfSound: c,\n            sampleRate: this.sampleRate,\n            raysPerShoot: this.raysPerShoot,\n          };\n\n          // Step 4: Inject source emission\n          injectSourceEnergy(sourcePos, this.initialEnergy, ctx, this.sourceRays);\n\n          // Step 5: Progressive shooting loop\n          const initialTotal = totalUnshotEnergy(unshotEnergy);\n          let iteration = 0;\n\n          while (iteration < this.maxIterations) {\n            const currentUnshot = totalUnshotEnergy(unshotEnergy);\n            if (initialTotal > 0 && currentUnshot / initialTotal < this.convergenceThreshold) {\n              break;\n            }\n\n            const shootIdx = selectShootingPatch(unshotEnergy);\n            if (unshotEnergy[shootIdx].sum() < 1e-20) break;\n\n            shootFromPatch(ctx, shootIdx);\n            iteration++;\n          }\n\n          this.lastIterationCount = iteration;\n\n          // Step 6: Gather at receiver\n          const bandResponse = gatherAtReceiver(receiverPos, ctx);\n          bandResponses.push(bandResponse);\n        }\n\n        // Step 7: Add direct path contribution (source  receiver)\n        const directDist = sourcePos.distanceTo(receiverPos);\n        if (directDist > 1e-6) {\n          const directDelaySamples = (directDist / c) * this.sampleRate;\n          const directIdx = Math.round(directDelaySamples);\n          // Sum air attenuation across all frequency bands for broadband direct path\n          for (let b = 0; b < bandResponses.length; b++) {\n            const airAbsDb = airAttenuation([this.frequencies[b]], this.temperature)[0];\n            const airAbsNepers = airAbsDb / (20 / Math.LN10);\n            const directAtten = Math.exp(-airAbsNepers * directDist) / (directDist * directDist);\n            if (directIdx < bandResponses[b].buffer.length) {\n              bandResponses[b].buffer[directIdx] += this.initialEnergy * directAtten;\n            }\n          }\n        }\n\n        // Step 8: Combine frequency bands by summing\n        let maxLen = 0;\n        for (const br of bandResponses) {\n          if (br.buffer.length > maxLen) maxLen = br.buffer.length;\n        }\n\n        const combined = new Float32Array(maxLen);\n        for (const br of bandResponses) {\n          for (let i = 0; i < br.buffer.length; i++) {\n            combined[i] += br.buffer[i];\n          }\n        }\n\n        // Normalize to max amplitude\n        let maxVal = 0;\n        for (let i = 0; i < combined.length; i++) {\n          if (Math.abs(combined[i]) > maxVal) maxVal = Math.abs(combined[i]);\n        }\n        if (maxVal > 0) {\n          for (let i = 0; i < combined.length; i++) {\n            combined[i] /= maxVal;\n          }\n        }\n\n        // Step 9: Emit result\n        const displayData: { time: number; amplitude: number }[] = [];\n        const step = Math.max(1, Math.floor(combined.length / 2000));\n        for (let i = 0; i < combined.length; i += step) {\n          displayData.push({\n            time: i / this.sampleRate,\n            amplitude: combined[i],\n          });\n        }\n\n        // Trim trailing silence\n        let lastNonZero = displayData.length - 1;\n        while (lastNonZero > 0 && Math.abs(displayData[lastNonZero].amplitude) < 1e-10) {\n          lastNonZero--;\n        }\n        const trimmedData = displayData.slice(0, lastNonZero + 1);\n\n        const sourceName = source.name || 'source';\n        const receiverName = receiver.name || 'receiver';\n        const resultUuid = `${this.uuid}-art-ir-${source.uuid}-${receiver.uuid}`;\n\n        const result: Result<ResultKind.ImpulseResponse> = {\n          kind: ResultKind.ImpulseResponse,\n          name: `ART IR: ${sourceName}  ${receiverName}`,\n          uuid: resultUuid,\n          from: this.uuid,\n          info: {\n            sampleRate: this.sampleRate,\n            sourceName,\n            receiverName,\n            sourceId: source.uuid,\n            receiverId: receiver.uuid,\n          },\n          data: trimmedData.length > 0 ? trimmedData : [{ time: 0, amplitude: 0 }],\n        };\n\n        const existingResult = useResult.getState().results[resultUuid];\n        if (existingResult) {\n          emit(\"UPDATE_RESULT\", { uuid: resultUuid, result });\n        } else {\n          emit(\"ADD_RESULT\", result);\n        }\n        this.hasEmittedResults = true;\n      }\n    }\n  }\n\n  save() {\n    const { name, kind, uuid, autoCalculate, roomID, sourceIDs, receiverIDs,\n            maxEdgeLength, brdfDetail, raysPerShoot, maxIterations,\n            convergenceThreshold, temperature, sampleRate } = this;\n    return {\n      name, kind, uuid, autoCalculate, roomID, sourceIDs, receiverIDs,\n      maxEdgeLength, brdfDetail, raysPerShoot, maxIterations,\n      convergenceThreshold, temperature, sampleRate,\n    } as ARTSaveObject;\n  }\n\n  restore(state: ARTSaveObject) {\n    super.restore(state);\n    this.kind = state.kind;\n    if (state.roomID !== undefined) this.roomID = state.roomID;\n    if (state.sourceIDs !== undefined) this.sourceIDs = state.sourceIDs;\n    if (state.receiverIDs !== undefined) this.receiverIDs = state.receiverIDs;\n    if (state.maxEdgeLength !== undefined) this.maxEdgeLength = state.maxEdgeLength;\n    if (state.brdfDetail !== undefined) this.brdfDetail = state.brdfDetail;\n    if (state.raysPerShoot !== undefined) this.raysPerShoot = state.raysPerShoot;\n    if (state.maxIterations !== undefined) this.maxIterations = state.maxIterations;\n    if (state.convergenceThreshold !== undefined) this.convergenceThreshold = state.convergenceThreshold;\n    if (state.temperature !== undefined) this.temperature = state.temperature;\n    if (state.sampleRate !== undefined) this.sampleRate = state.sampleRate;\n    return this;\n  }\n\n  get rooms() {\n    return useContainer.getState().getRooms();\n  }\n\n  get room(): Room {\n    return useContainer.getState().containers[this.roomID] as Room;\n  }\n\n  get noResults(): boolean {\n    return !this.hasEmittedResults;\n  }\n}\n\nexport default ART;\n\n// this allows for nice type checking with 'on' and 'emit' from messenger\ndeclare global {\n  interface EventTypes {\n    ADD_ART: ART | undefined;\n    REMOVE_ART: string;\n    ART_SET_PROPERTY: {\n      uuid: string;\n      property: keyof ART;\n      value: ART[EventTypes[\"ART_SET_PROPERTY\"][\"property\"]];\n    };\n    CALCULATE_ART: string;\n  }\n}\n\n// add event listener\non(\"ADD_ART\", addSolver(ART));\non(\"REMOVE_ART\", removeSolver);\non(\"ART_SET_PROPERTY\", setSolverProperty);\non(\"CALCULATE_ART\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as ART;\n  if (solver) solver.calculate();\n});\n\n// need this import at the end to avoid circular dependency issues\nimport { useSolver } from \"../../store\";\n"],"names":["DEFAULT_BRDF_DETAIL","BRDF","detail","positions","IcosahedronGeometry","seen","hemiPoints","i","x","y","z","v","Vector3","key","absorption","scattering","a","s","reflectance","diffuseWeight","specularWeight","incoming","d","mirror","mirrorSlot","outgoing","localDir","bestIdx","bestDot","dot","worldDir","patchNormal","worldToLocal","incomingSlot","dir","normal","tangent","Response","length","start","stop","value","n","newBuffer","index","sum","source","delay","multiplier","newLen","DirectionalResponse","response","b","multPerDirection","constScaler","BVHNode","extentsMin","extentsMax","startIndex","endIndex","level","node0","node1","tempNode","BVHVector3","array","firstElementPos","c","scalar","ax","ay","az","bx","by","bz","potentialVector","BVH","rootNode","boundingBoxArray","triangleArray","rayOrigin","rayDirection","backfaceCulling","nodesToIntersect","trianglesInIntersectingNodes","intersectingTriangles","invRayDirection","node","triIndex","intersectionPoint","minVal","maxVal","rayOriginCoord","invdir","tmin","tmax","tymin","tymax","tzmin","tzmax","diff","edge1","edge2","DdN","sign","DdQxE2","DdE1xQ","QdN","EPSILON","BVHBuilder","triangles","maxTrianglesPerNode","trianglesArray","isFaceArray","buildTriangleArray","isNumberArray","bboxArray","calcBoundingBoxes","bboxHelper","triangleCount","extents","calcExtents","nodesToSplit","nodes","splitNode","maxTriangles","nodeCount","leftNode","rightNode","extentCenters","objectCenter","idx","j","splitFailed","splitOrder","extentsLength","axis0","axis1","leftElements","rightElements","candidateIndex","node0Start","node0End","node1Start","node1End","copyBoxes","subArr","node0Extents","node1Extents","concatenatedElements","helperPos","currElement","copyBox","expandBy","minX","minY","minZ","maxX","maxY","maxZ","p0x","p0y","p0z","p1x","p1y","p1z","p2x","p2y","p2z","setBox","p0","p1","p2","pos","triangleId","sourceArray","sourcePos","destArray","destPos","jdx","testArray","face","vertex","buildPatchesFromRoom","room","maxEdgeLength","surfaces","patches","allTriangleVertices","triangleToPatch","tessellator","TessellateModifier","si","surface","geom","posArray","triCount","t","offset","vA","vB","vC","wA","wB","wC","tri","Triangle","area","centroid","patchIndex","flatArray","bvh","samplePointOnPatch","patch","u","w","selectShootingPatch","unshotEnergy","maxEnergy","maxIdx","e","totalUnshotEnergy","total","shootFromPatch","ctx","patchIdx","patchSet","totalEnergy","brdf","airAbsNepers","speedOfSound","sampleRate","raysPerShoot","srcPatch","srcEnergy","slotEnergies","totalSlotEnergy","k","fraction","nRays","gain","r","origin","sampleDirectionInSlot","localToWorld","hits","closestHit","closestDist","hit","hitPoint","dx","dy","dz","dist","rcvPatchIdx","rcvPatch","delaySamples","airAtten","rcvAbsorption","rcvScattering","outgoingWeights","sourceResponse","scaledGain","outSlot","weight","injectSourceEnergy","sourcePosition","initialEnergy","randomSphereDirection","fromSource","patchAbsorption","patchScattering","outWeights","impulse","gatherAtReceiver","receiverPosition","result","toReceiver","cosTheta","occluded","solidAngle","dirSlot","patchResponse","theta","phi","slotIdx","center","sinT","cosT","defaults","ART","Solver","props","uuid","rooms","useContainer","whole_octave","containers","sources","receivers","id","soundSpeed","nPatches","responseLength","receiver","receiverPos","bandResponses","freq","absorptions","scatterings","airAttenuation","initialTotal","iteration","currentUnshot","shootIdx","bandResponse","directDist","directDelaySamples","directIdx","directAtten","maxLen","br","combined","displayData","step","lastNonZero","trimmedData","sourceName","receiverName","resultUuid","ResultKind","useResult","emit","name","kind","autoCalculate","roomID","sourceIDs","receiverIDs","brdfDetail","maxIterations","convergenceThreshold","temperature","state","on","addSolver","removeSolver","setSolverProperty","solver","useSolver"],"mappings":"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"}