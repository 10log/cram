{"version":3,"file":"index-WhIGaloW.mjs","sources":["../node_modules/three/examples/jsm/misc/GPUComputationRenderer.js","../src/compute/2d-fdtd/shaders/height-map.frag?raw","../src/compute/2d-fdtd/shaders/read-level.frag?raw","../src/compute/2d-fdtd/shaders/clear.frag?raw","../src/compute/2d-fdtd/shaders/water.vert?raw","../src/compute/2d-fdtd/shaders/water.frag?raw","../src/compute/2d-fdtd/shaders/index.ts","../src/compute/2d-fdtd/rasterize-line.ts","../src/compute/2d-fdtd/fdtd-wall.ts","../src/common/clamp.ts","../src/compute/2d-fdtd/index.ts"],"sourcesContent":["import {\n\tClampToEdgeWrapping,\n\tDataTexture,\n\tFloatType,\n\tNearestFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tWebGLRenderTarget\n} from 'three';\n\nimport { FullScreenQuad } from '../postprocessing/Pass.js';\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by @zz85.\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel).\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * ```\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n * ```\n * Basic use:\n * ```js\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, vel0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, pos0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n * ```\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * ```js\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n * ```\n *\n * @three_import import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n */\nclass GPUComputationRenderer {\n\n\t/**\n\t * Constructs a new GPU computation renderer.\n\t *\n\t * @param {number} sizeX - Computation problem size is always 2d: sizeX * sizeY elements.\n \t * @param {number} sizeY - Computation problem size is always 2d: sizeX * sizeY elements.\n \t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\tconstructor( sizeX, sizeY, renderer ) {\n\n\t\tthis.variables = [];\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\tlet dataType = FloatType;\n\n\t\tconst passThruUniforms = {\n\t\t\tpassThruTexture: { value: null }\n\t\t};\n\n\t\tconst passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\t\tconst quad = new FullScreenQuad( passThruShader );\n\n\t\t/**\n\t\t * Sets the data type of the internal textures.\n\t\t *\n\t\t * @param {(FloatType|HalfFloatType)} type - The type to set.\n\t\t * @return {GPUComputationRenderer} A reference to this renderer.\n\t\t */\n\t\tthis.setDataType = function ( type ) {\n\n\t\t\tdataType = type;\n\t\t\treturn this;\n\n\t\t};\n\n\t\t/**\n\t\t * Adds a compute variable to the renderer.\n\t\t *\n\t\t * @param {string} variableName - The variable name.\n\t\t * @param {string} computeFragmentShader - The compute (fragment) shader source.\n\t\t * @param {Texture} initialValueTexture - The initial value texture.\n\t\t * @return {Object} The compute variable.\n\t\t */\n\t\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\t\tconst material = this.createShaderMaterial( computeFragmentShader );\n\n\t\t\tconst variable = {\n\t\t\t\tname: variableName,\n\t\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\t\tmaterial: material,\n\t\t\t\tdependencies: null,\n\t\t\t\trenderTargets: [],\n\t\t\t\twrapS: null,\n\t\t\t\twrapT: null,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t\tmagFilter: NearestFilter\n\t\t\t};\n\n\t\t\tthis.variables.push( variable );\n\n\t\t\treturn variable;\n\n\t\t};\n\n\t\t/**\n\t\t * Sets variable dependencies.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @param {Array<Object>} dependencies - Other compute variables that represents the dependencies.\n\t\t */\n\t\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\t\tvariable.dependencies = dependencies;\n\n\t\t};\n\n\t\t/**\n\t\t * Initializes the renderer.\n\t\t *\n\t\t * @return {?string} Returns `null` if no errors are detected. Otherwise returns the error message.\n\t\t */\n\t\tthis.init = function () {\n\n\t\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\t\treturn 'No support for vertex shader textures.';\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\t\tconst material = variable.material;\n\t\t\t\tconst uniforms = material.uniforms;\n\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tfor ( let d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\t\tlet found = false;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\t\treturn 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\t\tmaterial.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = 0;\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\t/**\n\t\t * Executes the compute. This method is usually called in the animation loop.\n\t\t */\n\t\tthis.compute = function () {\n\n\t\t\tconst currentTextureIndex = this.currentTextureIndex;\n\t\t\tconst nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\t\tfor ( let i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Sets texture dependencies uniforms\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tconst uniforms = variable.material.uniforms;\n\n\t\t\t\t\tfor ( let d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Performs the computation for this variable\n\t\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the current render target for the given compute variable.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @return {WebGLRenderTarget} The current render target.\n\t\t */\n\t\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the alternate render target for the given compute variable.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @return {WebGLRenderTarget} The alternate render target.\n\t\t */\n\t\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t\t};\n\n\t\t/**\n\t\t * Frees all internal resources. Call this method if you don't need the\n\t\t * renderer anymore.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\tquad.dispose();\n\n\t\t\tconst variables = this.variables;\n\n\t\t\tfor ( let i = 0; i < variables.length; i ++ ) {\n\n\t\t\t\tconst variable = variables[ i ];\n\n\t\t\t\tif ( variable.initialValueTexture ) variable.initialValueTexture.dispose();\n\n\t\t\t\tconst renderTargets = variable.renderTargets;\n\n\t\t\t\tfor ( let j = 0; j < renderTargets.length; j ++ ) {\n\n\t\t\t\t\tconst renderTarget = renderTargets[ j ];\n\t\t\t\t\trenderTarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction addResolutionDefine( materialShader ) {\n\n\t\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + ' )';\n\n\t\t}\n\n\t\t/**\n\t\t * Adds a resolution defined for the given material shader.\n\t\t *\n\t\t * @param {Object} materialShader - The material shader.\n\t\t */\n\t\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t\t// The following functions can be used to compute things manually\n\n\t\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\t\tuniforms = uniforms || {};\n\n\t\t\tconst material = new ShaderMaterial( {\n\t\t\t\tname: 'GPUComputationShader',\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\t\tfragmentShader: computeFragmentShader\n\t\t\t} );\n\n\t\t\taddResolutionDefine( material );\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tthis.createShaderMaterial = createShaderMaterial;\n\n\t\t/**\n\t\t * Creates a new render target from the given parameters.\n\t\t *\n\t\t * @param {number} sizeXTexture - The width of the render target.\n\t\t * @param {number} sizeYTexture - The height of the render target.\n\t\t * @param {number} wrapS - The wrapS value.\n\t\t * @param {number} wrapT - The wrapS value.\n\t\t * @param {number} minFilter - The minFilter value.\n\t\t * @param {number} magFilter - The magFilter value.\n\t\t * @return {WebGLRenderTarget} The new render target.\n\t\t */\n\t\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\t\twrapS = wrapS || ClampToEdgeWrapping;\n\t\t\twrapT = wrapT || ClampToEdgeWrapping;\n\n\t\t\tminFilter = minFilter || NearestFilter;\n\t\t\tmagFilter = magFilter || NearestFilter;\n\n\t\t\tconst renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\t\twrapS: wrapS,\n\t\t\t\twrapT: wrapT,\n\t\t\t\tminFilter: minFilter,\n\t\t\t\tmagFilter: magFilter,\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: dataType,\n\t\t\t\tdepthBuffer: false\n\t\t\t} );\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Creates a new data texture.\n\t\t *\n\t\t * @return {DataTexture} The new data texture.\n\t\t */\n\t\tthis.createTexture = function () {\n\n\t\t\tconst data = new Float32Array( sizeX * sizeY * 4 );\n\t\t\tconst texture = new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\n\t\t\ttexture.needsUpdate = true;\n\t\t\treturn texture;\n\n\t\t};\n\n\t\t/**\n\t\t * Renders the given texture into the given render target.\n\t\t *\n\t\t * @param {Texture} input - The input.\n\t\t * @param {WebGLRenderTarget} output - The output.\n\t\t */\n\t\tthis.renderTexture = function ( input, output ) {\n\n\t\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t\t};\n\n\n\t\t/**\n\t\t * Renders the given material into the given render target\n\t\t * with a full-screen pass.\n\t\t *\n\t\t * @param {Material} material - The material.\n\t\t * @param {WebGLRenderTarget} output - The output.\n\t\t */\n\t\tthis.doRenderTarget = function ( material, output ) {\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\tquad.material = material;\n\t\t\trenderer.setRenderTarget( output );\n\t\t\tquad.render( renderer );\n\t\t\tquad.material = passThruShader;\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t};\n\n\t\t// Shaders\n\n\t\tfunction getPassThroughVertexShader() {\n\n\t\t\treturn\t'void main()\t{\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_Position = vec4( position, 1.0 );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t\tfunction getPassThroughFragmentShader() {\n\n\t\t\treturn\t'uniform sampler2D passThruTexture;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'void main() {\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t}\n\n}\n\nexport { GPUComputationRenderer };\n","export default \"#include <common>\\r\\n\\r\\nuniform vec2 mousePos;\\r\\nuniform float mouseSize;\\r\\nuniform float damping;\\r\\nuniform float heightCompensation;\\r\\nuniform sampler2D sourcemap;\\r\\n\\r\\nvoid main()\\t{\\r\\n\\r\\n  vec2 cellSize = 1.0 / resolution.xy;\\r\\n\\r\\n  vec2 uv = gl_FragCoord.xy * cellSize;\\r\\n    \\r\\n  float newvel = 0.;\\r\\n  float newpos = 0.;\\r\\n\\r\\n\\r\\n  vec4 heightmapValue = texture2D( heightmap, uv );\\r\\n  vec4 sourcemapValue = texture2D( sourcemap, uv);\\r\\n  \\r\\n\\r\\n\\r\\n  if(sourcemapValue.b > 0.0){\\r\\n    float pos = heightmapValue.r;\\r\\n    float vel = heightmapValue.g;\\r\\n    \\r\\n    \\r\\n    \\r\\n    vec2 ud_offset = vec2( 0.0, cellSize.y );\\r\\n    vec2 rl_offset = vec2( cellSize.x, 0.0 );\\r\\n    \\r\\n    vec4 u = texture2D( heightmap, uv + ud_offset );    \\r\\n    vec4 d = texture2D( heightmap, uv - ud_offset );\\r\\n    vec4 r = texture2D( heightmap, uv + rl_offset );\\r\\n    vec4 l = texture2D( heightmap, uv - rl_offset );\\r\\n    \\r\\n    float u_wall = texture2D( sourcemap, uv + ud_offset ).b;\\r\\n    float d_wall = texture2D( sourcemap, uv - ud_offset ).b;\\r\\n    float r_wall = texture2D( sourcemap, uv + rl_offset ).b;\\r\\n    float l_wall = texture2D( sourcemap, uv - rl_offset ).b;\\r\\n    \\r\\n    \\r\\n    // float u_pos = u_wall == 0 ? d.r : u.r;\\r\\n    // float d_pos = d_wall == 0 ? u.r : d.r;\\r\\n    // float r_pos = r_wall == 0 ? l.r : r.r;\\r\\n    // float l_pos = l_wall == 0 ? r.r : l.r;\\r\\n\\r\\n    float u_pos =  u.r;\\r\\n    float d_pos =  d.r;\\r\\n    float r_pos =  r.r;\\r\\n    float l_pos =  l.r;\\r\\n    \\r\\n    if(u_wall == 0.0){\\r\\n      u_pos = texture2D( heightmap, uv - ud_offset ).r;\\r\\n    }\\r\\n    if(d_wall == 0.0){\\r\\n      d_pos = texture2D( heightmap, uv + ud_offset ).r;\\r\\n    }\\r\\n    if(r_wall == 0.0){\\r\\n      r_pos = texture2D( heightmap, uv - rl_offset ).r;\\r\\n    }\\r\\n    if(l_wall == 0.0){\\r\\n      l_pos = texture2D( heightmap, uv + rl_offset ).r;\\r\\n    }\\r\\n\\r\\n    float mid = 0.25*(u_pos+d_pos+r_pos+l_pos);\\r\\n  \\r\\n    float med = heightmapValue.b * 1.5;\\r\\n    newvel = med*(mid-pos)+vel*damping;\\r\\n    newpos = pos+newvel;\\r\\n    \\r\\n    if(sourcemapValue.a == 0.0){  \\r\\n      newvel = sourcemapValue.g;\\r\\n      newpos = sourcemapValue.r;\\r\\n    }    \\r\\n  }\\r\\n  else {\\r\\n    newvel = 0.0;\\r\\n    newpos = 127.5;\\r\\n  }\\r\\n  \\r\\n  \\r\\n  gl_FragColor = vec4(newpos, newvel, heightmapValue.b, sourcemapValue.b);\\r\\n\\r\\n\\r\\n}\\r\\n\"","export default \"uniform vec2 point1;\\r\\nuniform float cell_size;\\r\\nuniform float inv_cell_size;\\r\\n\\r\\nuniform sampler2D levelTexture;\\r\\n\\r\\n// Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target\\r\\n\\r\\nfloat shift_right( float v, float amt ) {\\r\\n\\r\\n\\tv = floor( v ) + 0.5;\\r\\n\\treturn floor( v / exp2( amt ) );\\r\\n\\r\\n}\\r\\n\\r\\nfloat shift_left( float v, float amt ) {\\r\\n\\r\\n\\treturn floor( v * exp2( amt ) + 0.5 );\\r\\n\\r\\n}\\r\\n\\r\\nfloat mask_last( float v, float bits ) {\\r\\n\\r\\n\\treturn mod( v, shift_left( 1.0, bits ) );\\r\\n\\r\\n}\\r\\n\\r\\nfloat extract_bits( float num, float from, float to ) {\\r\\n\\r\\n\\tfrom = floor( from + 0.5 ); to = floor( to + 0.5 );\\r\\n\\treturn mask_last( shift_right( num, from ), to - from );\\r\\n\\r\\n}\\r\\n\\r\\nvec4 encode_float( float val ) {\\r\\n\\tif ( val == 0.0 ) return vec4( 0, 0, 0, 0 );\\r\\n\\tfloat sign = val > 0.0 ? 0.0 : 1.0;\\r\\n\\tval = abs( val );\\r\\n\\tfloat exponent = floor( log2( val ) );\\r\\n\\tfloat biased_exponent = exponent + 127.0;\\r\\n\\tfloat fraction = ( ( val / exp2( exponent ) ) - 1.0 ) * 8388608.0;\\r\\n\\tfloat t = biased_exponent / 2.0;\\r\\n\\tfloat last_bit_of_biased_exponent = fract( t ) * 2.0;\\r\\n\\tfloat remaining_bits_of_biased_exponent = floor( t );\\r\\n\\tfloat byte4 = extract_bits( fraction, 0.0, 8.0 ) / 255.0;\\r\\n\\tfloat byte3 = extract_bits( fraction, 8.0, 16.0 ) / 255.0;\\r\\n\\tfloat byte2 = ( last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;\\r\\n\\tfloat byte1 = ( sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;\\r\\n\\treturn vec4( byte4, byte3, byte2, byte1 );\\r\\n}\\r\\n\\r\\nvoid main()\\t{\\r\\n\\r\\n\\tvec2 cellSize = vec2(cell_size);\\r\\n\\r\\n\\tfloat waterLevel = texture2D( levelTexture, point1 ).x;\\r\\n\\r\\n\\tvec2 normal = vec2(\\r\\n\\t\\t( texture2D( levelTexture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( levelTexture, point1 + vec2( cellSize.x, 0 ) ).x ) * inv_cell_size,\\r\\n\\t\\t( texture2D( levelTexture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( levelTexture, point1 + vec2( 0, cellSize.y ) ).x ) * inv_cell_size );\\r\\n\\r\\n\\tif ( gl_FragCoord.x < 1.5 ) {\\r\\n\\r\\n\\t\\tgl_FragColor = encode_float( waterLevel );\\r\\n\\r\\n\\t} else if ( gl_FragCoord.x < 2.5 ) {\\r\\n\\r\\n\\t\\tgl_FragColor = encode_float( normal.x );\\r\\n\\r\\n\\t} else if ( gl_FragCoord.x < 3.5 ) {\\r\\n\\r\\n\\t\\tgl_FragColor = encode_float( normal.y );\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tgl_FragColor = encode_float( 0.0 );\\r\\n\\r\\n\\t}\\r\\n\\r\\n}\"","export default \"uniform sampler2D clearTexture;\\r\\n\\r\\nvoid main()\\t{\\r\\n\\r\\n\\tvec2 cellSize = 1.0 / resolution.xy;\\r\\n\\r\\n\\tvec2 uv = gl_FragCoord.xy * cellSize;\\r\\n\\r\\n\\r\\n\\tvec4 textureValue = texture2D( clearTexture, uv );\\r\\n\\r\\n\\ttextureValue.r = 127.5;\\r\\n\\ttextureValue.g = 0.0;\\r\\n\\r\\n\\tgl_FragColor = textureValue;\\r\\n\\r\\n}\\r\\n\"","export default \"uniform sampler2D heightmap;\\r\\nuniform float inv_cell_size;\\r\\nuniform float cell_size;\\r\\nvarying float vHeight;\\r\\nvarying float vWall;\\r\\n#define PHONG\\r\\n\\r\\nvarying vec3 vViewPosition;\\r\\n\\r\\n#ifndef FLAT_SHADED\\r\\n\\r\\n\\tvarying vec3 vNormal;\\r\\n\\r\\n#endif\\r\\n\\r\\n#include <common>\\r\\n#include <uv_pars_vertex>\\r\\n#include <uv2_pars_vertex>\\r\\n#include <displacementmap_pars_vertex>\\r\\n#include <envmap_pars_vertex>\\r\\n#include <color_pars_vertex>\\r\\n#include <morphtarget_pars_vertex>\\r\\n#include <skinning_pars_vertex>\\r\\n#include <shadowmap_pars_vertex>\\r\\n#include <logdepthbuf_pars_vertex>\\r\\n#include <clipping_planes_pars_vertex>\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\\tvec2 cellSize = vec2( cell_size );\\r\\n\\r\\n\\t#include <uv_vertex>\\r\\n\\t#include <uv2_vertex>\\r\\n\\t#include <color_vertex>\\r\\n\\r\\n\\t// # include <beginnormal_vertex>\\r\\n\\t// Compute normal from heightmap\\r\\n\\tvec3 objectNormal = vec3(\\r\\n\\t\\t( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * inv_cell_size,\\r\\n\\t\\t( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * inv_cell_size,\\r\\n\\t\\t1.0 );\\r\\n\\t//<beginnormal_vertex>\\r\\n\\r\\n\\t#include <morphnormal_vertex>\\r\\n\\t#include <skinbase_vertex>\\r\\n\\t#include <skinnormal_vertex>\\r\\n\\t#include <defaultnormal_vertex>\\r\\n\\r\\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\r\\n\\r\\n\\tvNormal = normalize( transformedNormal );\\r\\n\\r\\n#endif\\r\\n\\r\\n\\t//# include <begin_vertex>\\r\\n\\tvec4 heightmapValue = texture2D( heightmap, uv );\\r\\n\\tfloat heightValue = heightmapValue.x - 127.5;\\r\\n\\tvHeight = heightValue;\\r\\n\\tvWall = heightmapValue.a;\\r\\n\\t\\r\\n\\tvec3 transformed = vec3( position.x, position.y, heightValue );\\r\\n\\t//<begin_vertex>\\r\\n\\r\\n\\t#include <morphtarget_vertex>\\r\\n\\t#include <skinning_vertex>\\r\\n\\t#include <displacementmap_vertex>\\r\\n\\t#include <project_vertex>\\r\\n\\t#include <logdepthbuf_vertex>\\r\\n\\t#include <clipping_planes_vertex>\\r\\n\\r\\n\\tvViewPosition = - mvPosition.xyz;\\r\\n\\r\\n\\t#include <worldpos_vertex>\\r\\n\\t#include <envmap_vertex>\\r\\n\\t#include <shadowmap_vertex>\\r\\n\\r\\n}\\r\\n\"","export default \"#define PHONG\\r\\n\\r\\nvarying float vHeight;\\r\\nvarying float vWall;\\r\\n\\r\\nuniform vec3 diffuse;\\r\\nuniform vec3 emissive;\\r\\nuniform vec3 specular;\\r\\nuniform float shininess;\\r\\nuniform float opacity;\\r\\nuniform float colorBrightness;\\r\\n\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <dithering_pars_fragment>\\r\\n#include <color_pars_fragment>\\r\\n#include <uv_pars_fragment>\\r\\n#include <uv2_pars_fragment>\\r\\n#include <map_pars_fragment>\\r\\n#include <alphamap_pars_fragment>\\r\\n#include <aomap_pars_fragment>\\r\\n#include <lightmap_pars_fragment>\\r\\n#include <emissivemap_pars_fragment>\\r\\n#include <envmap_common_pars_fragment>\\r\\n#include <envmap_pars_fragment>\\r\\n#include <gradientmap_pars_fragment>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <lights_phong_pars_fragment>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <bumpmap_pars_fragment>\\r\\n#include <normalmap_pars_fragment>\\r\\n#include <specularmap_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\n#include <clipping_planes_pars_fragment>\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\\t#include <clipping_planes_fragment>\\r\\n\\r\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\r\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\r\\n\\tvec3 totalEmissiveRadiance = emissive;\\r\\n\\r\\n\\t#include <logdepthbuf_fragment>\\r\\n\\t#include <map_fragment>\\r\\n\\t#include <color_fragment>\\r\\n\\t#include <alphamap_fragment>\\r\\n\\t#include <alphatest_fragment>\\r\\n\\t#include <specularmap_fragment>\\r\\n\\t#include <normal_fragment_begin>\\r\\n\\t#include <normal_fragment_maps>\\r\\n\\t#include <emissivemap_fragment>\\r\\n\\r\\n\\t// accumulation\\r\\n\\t#include <lights_phong_fragment>\\r\\n\\t#include <lights_fragment_begin>\\r\\n\\t#include <lights_fragment_maps>\\r\\n\\t#include <lights_fragment_end>\\r\\n\\r\\n\\t// modulation\\r\\n\\t#include <aomap_fragment>\\r\\n\\r\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\r\\n\\r\\n\\t#include <envmap_fragment>\\r\\n\\r\\n\\tvec3 col = vec3(0.0,0.0,0.0);\\r\\n\\tif(vHeight > 0.0){\\r\\n\\t\\tcol.r = vHeight/127.5*colorBrightness;\\r\\n\\t}\\r\\n\\telse if(vHeight <= 0.0){\\r\\n\\t\\tcol.g = -vHeight/127.5*colorBrightness;\\r\\n\\t}\\r\\n\\r\\n\\tgl_FragColor = vec4( col, 1.0 );\\r\\n\\r\\n\\t#include <tonemapping_fragment>\\r\\n\\t#include <encodings_fragment>\\r\\n\\t#include <fog_fragment>\\r\\n\\t#include <premultiplied_alpha_fragment>\\r\\n\\t#include <dithering_fragment>\\r\\n\\r\\n}\"","import heightMapFrag from \"./height-map.frag?raw\";\r\nimport readLevelFrag from \"./read-level.frag?raw\";\r\nimport clearFrag from \"./clear.frag?raw\";\r\nimport waterVert from \"./water.vert?raw\";\r\nimport waterFrag from \"./water.frag?raw\";\r\n\r\nexport default {\r\n  heightMapFrag,\r\n  readLevelFrag,\r\n  clearFrag,\r\n  waterVert,\r\n  waterFrag\r\n};\r\n","export function rasterizeLine(x1: number, y1: number, x2: number, y2: number) {\r\n  \r\n  const pixels = [] as number[][];\r\n  \r\n  // Iterators, counters required by algorithm\r\n  let x, y, dx, dy, dx1, dy1, px, py, xe, ye, i;\r\n\r\n  // Calculate line deltas\r\n  dx = x2 - x1;\r\n  dy = y2 - y1;\r\n\r\n  // Create a positive copy of deltas (makes iterating easier)\r\n  dx1 = Math.abs(dx);\r\n  dy1 = Math.abs(dy);\r\n\r\n  // Calculate error intervals for both axis\r\n  px = 2 * dy1 - dx1;\r\n  py = 2 * dx1 - dy1;\r\n\r\n  // The line is X-axis dominant\r\n  if (dy1 <= dx1) {\r\n    // Line is drawn left to right\r\n    if (dx >= 0) {\r\n      x = x1;\r\n      y = y1;\r\n      xe = x2;\r\n    } else {\r\n      // Line is drawn right to left (swap ends)\r\n      x = x2;\r\n      y = y2;\r\n      xe = x1;\r\n    }\r\n\r\n    pixels.push([x, y]); // Draw first pixel\r\n\r\n    // Rasterize the line\r\n    for (i = 0; x < xe; i++) {\r\n      x = x + 1;\r\n\r\n      // Deal with octants...\r\n      if (px < 0) {\r\n        px = px + 2 * dy1;\r\n      } else {\r\n        if ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) {\r\n          y = y + 1;\r\n        } else {\r\n          y = y - 1;\r\n        }\r\n        px = px + 2 * (dy1 - dx1);\r\n      }\r\n\r\n      // Draw pixel from line span at\r\n      // currently rasterized position\r\n      pixels.push([x, y]); \r\n    }\r\n  } else {\r\n    // The line is Y-axis dominant\r\n\r\n    // Line is drawn bottom to top\r\n    if (dy >= 0) {\r\n      x = x1;\r\n      y = y1;\r\n      ye = y2;\r\n    } else {\r\n      // Line is drawn top to bottom\r\n      x = x2;\r\n      y = y2;\r\n      ye = y1;\r\n    }\r\n\r\n   pixels.push([x, y]); \r\n\r\n    // Rasterize the line\r\n    for (i = 0; y < ye; i++) {\r\n      y = y + 1;\r\n\r\n      // Deal with octants...\r\n      if (py <= 0) {\r\n        py = py + 2 * dx1;\r\n      } else {\r\n        if ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) {\r\n          x = x + 1;\r\n        } else {\r\n          x = x - 1;\r\n        }\r\n        py = py + 2 * (dx1 - dy1);\r\n      }\r\n\r\n      // Draw pixel from line span at\r\n      // currently rasterized position\r\n     pixels.push([x, y]); \r\n    }\r\n  }\r\n  return pixels;\r\n};\r\n\r\nexport default rasterizeLine;","import rasterizeLine from './rasterize-line';\r\n\r\nexport interface FDTDWallProps {\r\n  x1: number;\r\n  y1: number;\r\n  x2: number;\r\n  y2: number;\r\n}\r\n\r\nclass FDTDWall {\r\n  enabled: boolean;\r\n  x1: number;\r\n  y1: number;\r\n  x2: number;\r\n  y2: number;\r\n  cells: number[][];\r\n  previousCells: number[][];\r\n  shouldClearPreviousCells: boolean;\r\n  constructor(props: FDTDWallProps) {\r\n    this.x1 = props.x1;\r\n    this.y1 = props.y1;\r\n    this.x2 = props.x2;\r\n    this.y2 = props.y2;\r\n    this.cells = rasterizeLine(this.x1, this.y1, this.x2, this.y2);\r\n    this.previousCells = this.cells;\r\n    this.shouldClearPreviousCells = false;\r\n    this.enabled = true;\r\n  }\r\n  \r\n  move(props: FDTDWallProps) {\r\n    this.previousCells = this.cells;\r\n    this.x1 = props.x1;\r\n    this.y1 = props.y1;\r\n    this.x2 = props.x2;\r\n    this.y2 = props.y2;\r\n    this.cells = rasterizeLine(this.x1, this.y1, this.x2, this.y2);\r\n    this.shouldClearPreviousCells = true;\r\n  }\r\n}\r\n\r\nexport { FDTDWall };\r\n\r\nexport default FDTDWall;\r\n","export function clamp(v: number, a: number, b: number): number {\r\n  return v < a ? a : v > b ? b : v;\r\n}\r\n","import { on, postMessage, removeMessageHandler } from \"../../messenger\";\r\nimport {\r\n  PlaneGeometry,\r\n  ShaderMaterial,\r\n  UniformsLib,\r\n  Mesh,\r\n  WebGLRenderer,\r\n  DataTexture,\r\n  UniformsUtils,\r\n  Color,\r\n  DoubleSide,\r\n  Vector2,\r\n  IUniform,\r\n  WebGLRenderTarget,\r\n  ClampToEdgeWrapping,\r\n  NearestFilter,\r\n  RGBAFormat,\r\n  UnsignedByteType,\r\n  BufferGeometry,\r\n  MeshBasicMaterial,\r\n  MeshLambertMaterial\r\n} from \"three\";\r\nimport {\r\n  GPUComputationRenderer,\r\n  Variable\r\n} from \"three/examples/jsm/misc/GPUComputationRenderer.js\";\r\nimport shaders from \"./shaders\";\r\nimport Solver from \"../solver\";\r\n\r\nimport Source from \"../../objects/source\";\r\nimport Receiver from \"../../objects/receiver\";\r\nimport map from \"../../common/map\";\r\nimport FDTDWall, { FDTDWallProps } from \"./fdtd-wall\";\r\nimport Surface from \"../../objects/surface\";\r\nimport { KeyValuePair } from \"../../common/key-value-pair\";\r\nimport { clamp } from \"../../common/clamp\";\r\nimport { EditorModes } from \"../../constants\";\r\nimport { useContainer } from \"../../store\";\r\nimport { renderer } from \"../../render/renderer\";\r\n\r\nconst CELL_RESOLUTION = 256;\r\n\r\nexport const FDTD_2D_Defaults = {\r\n  width: 10,\r\n  height: 10,\r\n  cellSize: 10 / CELL_RESOLUTION,\r\n  offsetX: 0,\r\n  offsetY: 0\r\n};\r\n\r\nexport interface FDTD_2D_Props {\r\n  width?: number;\r\n  height?: number;\r\n  cellSize?: number;\r\n  offsetX?: number;\r\n  offsetY?: number;\r\n}\r\n\r\nexport interface Uniforms {\r\n  [uniform: string]: IUniform;\r\n}\r\n\r\nclass FDTD_2D extends Solver {\r\n  gpuCompute!: GPUComputationRenderer;\r\n\r\n  /**\r\n   * number of x cells\r\n   */\r\n  nx: number;\r\n\r\n  /**\r\n   * number of y cells\r\n   */\r\n  ny: number;\r\n  \r\n  offsetX: number;\r\n  offsetY: number;\r\n\r\n  uniforms!: Uniforms;\r\n  mesh!: Mesh;\r\n  editMesh!: Mesh;\r\n  heightmapVariable!: Variable;\r\n  sourcemapVariable!: Variable;\r\n  sourcemap!: DataTexture;\r\n  readLevelShader!: ShaderMaterial;\r\n  readLevelImage!: Uint8Array;\r\n  readLevelRenderTarget!: WebGLRenderTarget;\r\n  sources!: KeyValuePair<Source>;\r\n  sourceKeys!: string[];\r\n  receivers!: KeyValuePair<Receiver>;\r\n  receiverKeys!: string[];\r\n  walls!: FDTDWall[];\r\n  /**\r\n   * simulation in seconds\r\n   */\r\n  time: number;\r\n\r\n  /**\r\n   * simulation time step in seconds\r\n   */\r\n  dt: number;\r\n  width: number;\r\n  height: number;\r\n  cellSize: number;\r\n  numPasses: number;\r\n  waveSpeed: number;\r\n  recording: boolean;\r\n  clearShader!: ShaderMaterial;\r\n  frame: number;\r\n  messageHandlers: string[][];\r\n  eventListeners: (()=>void)[];\r\n  constructor(props?: FDTD_2D_Props) {\r\n    super(props);\r\n    this.kind = \"fdtd-2d\";\r\n    this.running = false;\r\n    this.time = 0;\r\n    this.frame = 0;\r\n    this.numPasses = 1;\r\n    this.waveSpeed = 340.29;\r\n    this.recording = false;\r\n\r\n    const surfaces = [...useContainer.getState().selectedObjects.values()].filter(x=>x.kind===\"surface\") as Surface[];\r\n    let surface: Surface|null = null;\r\n    props = props || {};\r\n    if (surfaces.length > 0) {\r\n      surface = surfaces.length > 1 ? surfaces[0].mergeSurfaces(surfaces) : surfaces[0];\r\n      surface.mesh.geometry.computeBoundingBox();\r\n      const boundingBox = surface.mesh.geometry.boundingBox;\r\n      if (boundingBox) {\r\n        props.width = boundingBox.max.x - boundingBox.min.x;\r\n        props.height = boundingBox.max.y - boundingBox.min.y;\r\n        props.offsetX = boundingBox.min.x;\r\n        props.offsetY = boundingBox.min.y;\r\n      }\r\n    }\r\n    const _width = (props && props.width) || FDTD_2D_Defaults.width;\r\n    const _height = (props && props.height) || FDTD_2D_Defaults.height;\r\n\r\n    this.offsetX = (props && props.offsetX) || FDTD_2D_Defaults.offsetX;\r\n    this.offsetY = (props && props.offsetY) || FDTD_2D_Defaults.offsetY;\r\n\r\n    this.cellSize = (props && props.cellSize) || Math.max(_width, _height) / CELL_RESOLUTION;\r\n\r\n    this.nx = Math.ceil(_width / this.cellSize);\r\n    this.ny = Math.ceil(_height / this.cellSize);\r\n\r\n    this.width = this.nx * this.cellSize;\r\n    this.height = this.ny * this.cellSize;\r\n\r\n    this.dt = this.cellSize / this.waveSpeed;\r\n\r\n    this.sources = {} as KeyValuePair<Source>;\r\n    this.sourceKeys = [] as string[];\r\n    this.receivers = {} as KeyValuePair<Receiver>;\r\n    this.receiverKeys = [] as string[];\r\n    this.walls = [] as FDTDWall[];\r\n    this.messageHandlers = [] as string[][];\r\n    this.eventListeners = [] as (()=>void)[];\r\n\r\n    const editGeometry = new PlaneGeometry(this.width, this.height, 1, 1);\r\n    editGeometry.translate(this.width/2, this.height/2, 0);\r\n    editGeometry.translate(this.offsetX, this.offsetY, 0);\r\n    const editMaterials = [\r\n      new MeshBasicMaterial({ wireframe: true, side: DoubleSide, color: 0x707070 }),\r\n      new MeshLambertMaterial({ transparent: true, opacity: 0.35, side: DoubleSide, color: 0x707070 })\r\n    ];\r\n    \r\n    this.editMesh = new Mesh(editGeometry, editMaterials[0]);\r\n    this.editMesh.name = \"fdtd-2d-edit-mesh\";\r\n    this.editMesh.visible = false;\r\n    \r\n    renderer.fdtdItems.add(this.editMesh);\r\n    \r\n\r\n    this.fillTexture = this.fillTexture.bind(this);\r\n    this.init = this.init.bind(this);\r\n    this.render = this.render.bind(this);\r\n    this.updateWalls = this.updateWalls.bind(this);\r\n    this.updateSourceTexture = this.updateSourceTexture.bind(this);\r\n    this.addWallsFromSurfaceEdges = this.addWallsFromSurfaceEdges.bind(this);\r\n    this.setWireframeVisible = this.setWireframeVisible.bind(this);\r\n    this.getWireframeVisible = this.getWireframeVisible.bind(this);\r\n    this.toggleWall = this.toggleWall.bind(this);\r\n    this.clear = this.clear.bind(this);\r\n    \r\n    \r\n    this.init();\r\n    \r\n    this.onModeChange(postMessage(\"GET_EDITOR_MODE\")[0]);\r\n\r\n    if(surface){\r\n      this.addWallsFromSurfaceEdges(surface);\r\n    }\r\n    \r\n\r\n  }\r\n  onModeChange(mode: EditorModes) {\r\n    switch (mode) {\r\n      case EditorModes.OBJECT: { \r\n        this.editMesh.visible = false;\r\n        this.mesh.visible = true;\r\n      } break;\r\n      case EditorModes.SKETCH: { \r\n        this.editMesh.visible = false;\r\n        this.mesh.visible = false;\r\n      } break;\r\n      case EditorModes.EDIT: { \r\n        this.editMesh.visible = true;\r\n        this.mesh.visible = false;\r\n      } break;\r\n      default: break;\r\n    }\r\n  }\r\n  setWidth(width: number) {\r\n    this.nx = Math.ceil(width / this.cellSize);\r\n    this.width = this.nx * this.cellSize;\r\n  }\r\n  setHeight(height: number) {\r\n    this.ny = Math.ceil(height / this.cellSize);\r\n    this.height = this.ny * this.cellSize;\r\n  }\r\n  \r\n  setDimmensions(width: number, height: number) {\r\n    this.setWidth(width);\r\n    this.setHeight(height);\r\n  }\r\n  \r\n  init() {\r\n    this.dispose();\r\n    const geometry = new PlaneGeometry(this.width, this.height, this.nx - 1, this.ny - 1);\r\n    geometry.name = \"fdtd-2d-plane-geometry\";\r\n    geometry.translate(this.width / 2, this.height / 2, 0);\r\n    geometry.translate(this.offsetX, this.offsetY, 0);\r\n    const heightmap = { value: null };\r\n    const uniforms = UniformsUtils.merge([\r\n      UniformsLib.common,\r\n      UniformsLib.specularmap,\r\n      UniformsLib.envmap,\r\n      UniformsLib.aomap,\r\n      UniformsLib.lightmap,\r\n      UniformsLib.emissivemap,\r\n      UniformsLib.bumpmap,\r\n      UniformsLib.normalmap,\r\n      UniformsLib.displacementmap,\r\n      UniformsLib.gradientmap,\r\n      UniformsLib.fog,\r\n      UniformsLib.lights,\r\n      {\r\n        emissive: { value: new Color(0x000000) },\r\n        specular: { value: new Color(0x111111) },\r\n        shininess: { value: 30 },\r\n        colorBrightness: { value: 10 },\r\n        cell_size: { value: this.cellSize },\r\n        inv_cell_size: { value: 1 / this.cellSize },\r\n        heightmap\r\n      }\r\n    ]);\r\n    const vertexShader = shaders.waterVert;\r\n    const fragmentShader = shaders.waterFrag;\r\n    const side = DoubleSide;\r\n    const material = new ShaderMaterial({\r\n      uniforms,\r\n      vertexShader,\r\n      fragmentShader,\r\n      side,\r\n      name: \"fdtd-2d-material\"\r\n    });\r\n    material.lights = true;\r\n\r\n    this.uniforms = material.uniforms;\r\n    this.mesh = new Mesh(geometry, material);\r\n\r\n    this.mesh.matrixAutoUpdate = false;\r\n    this.mesh.updateMatrix();\r\n    // this.mesh.scale.setScalar(this.width / this.nx);\r\n    (this.mesh.material as ShaderMaterial).wireframe = false;\r\n    this.mesh.matrixAutoUpdate = true;\r\n    this.mesh.scale.setZ(0.01);\r\n    renderer.fdtdItems.add(this.mesh);\r\n\r\n    this.gpuCompute = new GPUComputationRenderer(this.nx, this.ny, renderer.renderer as WebGLRenderer);\r\n\r\n    let heightmapInit = this.gpuCompute.createTexture();\r\n    this.sourcemap = this.gpuCompute.createTexture();\r\n    this.fillSourceTexture();\r\n    this.updateSourceTexture();\r\n    this.fillTexture(heightmapInit);\r\n    this.heightmapVariable = this.gpuCompute.addVariable(\"heightmap\", shaders.heightMapFrag, heightmapInit);\r\n    this.gpuCompute.setVariableDependencies(this.heightmapVariable, [this.heightmapVariable]);\r\n\r\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"sourcemap\"] = { value: this.sourcemap };\r\n\r\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"mousePos\"] = { value: new Vector2(5, 5) };\r\n\r\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"mouseSize\"] = { value: 0.0 };\r\n\r\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"damping\"] = { value: 0.9999 };\r\n\r\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"heightCompensation\"] = { value: 0 };\r\n\r\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"cell_size\"] = { value: this.cellSize };\r\n\r\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"inv_cell_size\"] = { value: 1 / this.cellSize };\r\n\r\n    const error = this.gpuCompute.init();\r\n    if (error !== null) {\r\n      console.error(error);\r\n    }\r\n\r\n    this.clearShader = this.gpuCompute[\"createShaderMaterial\"](shaders.clearFrag, { clearTexture: { value: null } });\r\n\r\n    this.readLevelShader = this.gpuCompute[\"createShaderMaterial\"](shaders.readLevelFrag, {\r\n      point1: { value: new Vector2() },\r\n      levelTexture: { value: null },\r\n      cell_size: { value: this.cellSize },\r\n      inv_cell_size: { value: 1 / this.cellSize }\r\n    });\r\n\r\n    // Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation\r\n    this.readLevelImage = new Uint8Array(4 * 1 * 4);\r\n\r\n    this.readLevelRenderTarget = new WebGLRenderTarget(4, 1, {\r\n      wrapS: ClampToEdgeWrapping,\r\n      wrapT: ClampToEdgeWrapping,\r\n      minFilter: NearestFilter,\r\n      magFilter: NearestFilter,\r\n      format: RGBAFormat,\r\n      type: UnsignedByteType,\r\n      stencilBuffer: false,\r\n      depthBuffer: false\r\n    });\r\n    \r\n\r\n    this.eventListeners.push(on(\"RENDERER_UPDATED\", ()=>{\r\n      if (this.running) this.render();\r\n    }));\r\n    this.render();\r\n    this.clear();\r\n  }\r\n  editSize() {\r\n    // this.mesh.visible = false;\r\n  }\r\n  dispose() {\r\n    this.eventListeners.forEach(dispose => dispose());\r\n\r\n    for (let i = 0; i < this.messageHandlers.length; i++) {\r\n      removeMessageHandler(this.messageHandlers[i][0], this.messageHandlers[i][1]); \r\n    }\r\n    this.mesh && renderer.fdtdItems.remove(this.mesh);\r\n    this.messageHandlers = [] as string[][];\r\n  }\r\n  run() {\r\n    this.running = true;\r\n    renderer.fdtd2drunning = true;\r\n  }\r\n  stop() {\r\n    this.running = false;\r\n    renderer.fdtd2drunning = false;\r\n  }\r\n  // save() {\r\n  //   return pickProps([\"name\", \"uuid\", \"width\", \"height\", \"offsetX\", \"offsetY\", \"cellSize\"], this);\r\n  // }\r\n  setWireframeVisible(show: boolean) {\r\n    (this.mesh.material as ShaderMaterial).wireframe = show;\r\n  }\r\n  getWireframeVisible() {\r\n    return (this.mesh.material as ShaderMaterial).wireframe;\r\n  }\r\n  addSource(source: Source) {\r\n    this.sourceKeys = [...new Set(this.sourceKeys.concat(source.uuid))];\r\n    this.sources[source.uuid] = source;\r\n  }\r\n  removeSource(id: string) {\r\n    if (this.sources[id]) {\r\n      delete this.sources[id];\r\n      this.sourceKeys = this.sourceKeys.filter((x) => x !== id);\r\n    }\r\n  }\r\n  addReceiver(receiver: Receiver) {\r\n    this.receiverKeys = [...new Set(this.receiverKeys.concat(receiver.uuid))];\r\n    this.receivers[receiver.uuid] = receiver;\r\n  }\r\n  removeReceiver(id: string) {\r\n    if (this.receivers[id]) {\r\n      delete this.receivers[id];\r\n      this.receiverKeys = this.receiverKeys.filter((x) => x !== id);\r\n    }\r\n  }\r\n  addWall(props: FDTDWallProps) {\r\n    const x1 = clamp(Math.floor((props.x1 - this.offsetX) / this.cellSize), 0, this.nx - 1);\r\n    const y1 = clamp(Math.floor((props.y1 - this.offsetY) / this.cellSize), 0, this.nx - 1);\r\n    const x2 = clamp(Math.floor((props.x2 - this.offsetX) / this.cellSize), 0, this.nx - 1);\r\n    const y2 = clamp(Math.floor((props.y2 - this.offsetY) / this.cellSize), 0, this.nx - 1);\r\n    this.walls.push(new FDTDWall({ x1, y1, x2, y2 }));\r\n    this.updateWalls();\r\n  }\r\n  addWallsFromSurfaceEdges(surface: Surface) {\r\n    const positionAttr = (surface.edges.geometry as BufferGeometry).getAttribute('position');\r\n    for (let i = 0; i < positionAttr.count; i += 2) {\r\n      let x1 = clamp(Math.floor((positionAttr.getX(i) - this.offsetX) / this.cellSize), 0, this.nx - 1);\r\n      let y1 = clamp(Math.floor((positionAttr.getY(i) - this.offsetY) / this.cellSize), 0, this.ny - 1);\r\n      let x2 = clamp(Math.floor((positionAttr.getX(i + 1) - this.offsetX) / this.cellSize), 0, this.nx - 1);\r\n      let y2 = clamp(Math.floor((positionAttr.getY(i + 1) - this.offsetY) / this.cellSize), 0, this.ny - 1);\r\n      this.walls.push(new FDTDWall({ x1, y1, x2, y2 }));\r\n    }\r\n    this.updateWalls();\r\n  }\r\n\r\n  fillSourceTexture() {\r\n    const pixels = this.sourcemap.image.data;\r\n    if (!pixels) return;\r\n    let p = 0;\r\n    for (let j = 0; j < this.ny; j++) {\r\n      for (let i = 0; i < this.nx; i++) {\r\n        pixels[p + 0] = 0;\r\n        pixels[p + 1] = 0;\r\n        pixels[p + 2] = 1;\r\n        pixels[p + 3] = 1;\r\n        p += 4;\r\n      }\r\n    }\r\n  }\r\n\r\n  toggleWall(index: number) {\r\n    if (this.walls[index]) {\r\n      this.walls[index].enabled = !this.walls[index].enabled;\r\n      this.updateWalls();\r\n    }\r\n  }\r\n\r\n  updateWalls() {\r\n    const data = this.sourcemap.image.data;\r\n    if (!data) return;\r\n    for (let i = 0; i < this.walls.length; i++) {\r\n      if (this.walls[i].shouldClearPreviousCells) {\r\n        for (let j = 0; j < this.walls[i].previousCells.length; j++) {\r\n          const index = 4 * (this.walls[i].previousCells[j][1] * this.nx + this.walls[i].previousCells[j][0]);\r\n          data[index + 2] = 1;\r\n        }\r\n        this.walls[i].shouldClearPreviousCells = false;\r\n      }\r\n      if (this.walls[i].enabled) {\r\n        for (let j = 0; j < this.walls[i].cells.length; j++) {\r\n          const index = 4 * (this.walls[i].cells[j][1] * this.nx + this.walls[i].cells[j][0]);\r\n          data[index + 2] = 0;\r\n        }\r\n      } else {\r\n        for (let j = 0; j < this.walls[i].cells.length; j++) {\r\n          const index = 4 * (this.walls[i].cells[j][1] * this.nx + this.walls[i].cells[j][0]);\r\n          data[index + 2] = 1;\r\n        }\r\n      }\r\n    }\r\n    this.sourcemap.needsUpdate = true;\r\n  }\r\n\r\n  updateSourceTexture() {\r\n    const pixels = this.sourcemap.image.data;\r\n    if (!pixels) return;\r\n    for (let i = 0; i < this.sourceKeys.length; i++) {\r\n      const x = Math.round((this.sources[this.sourceKeys[i]].x - this.offsetX) / this.cellSize);\r\n      const y = Math.round((this.sources[this.sourceKeys[i]].y - this.offsetY) / this.cellSize);\r\n      const index = 4 * (y * this.nx + x);\r\n      this.sources[this.sourceKeys[i]].updateWave(this.time, this.frame, this.dt);\r\n      const value = this.sources[this.sourceKeys[i]].value;\r\n      const vel = this.sources[this.sourceKeys[i]].velocity;\r\n      pixels[index + 0] = map(value, -2, 2, 0, 255);\r\n      pixels[index + 1] = map(vel, -2, 2, 0, 255);\r\n      pixels[index + 3] = 0;\r\n\r\n      if (this.sources[this.sourceKeys[i]].shouldClearPreviousPosition) {\r\n        const px = Math.round((this.sources[this.sourceKeys[i]].previousX - this.offsetX) / this.cellSize);\r\n        const py = Math.round((this.sources[this.sourceKeys[i]].previousY - this.offsetY) / this.cellSize);\r\n        const previndex = 4 * (py * this.nx + px);\r\n        pixels[previndex + 0] = 0;\r\n        pixels[previndex + 1] = 0;\r\n        pixels[previndex + 3] = 1;\r\n        this.sources[this.sourceKeys[i]].shouldClearPreviousPosition = false;\r\n        this.sources[this.sourceKeys[i]].updatePreviousPosition();\r\n      }\r\n    }\r\n    this.sourcemap.needsUpdate = true;\r\n  }\r\n  fillTexture(texture: DataTexture) {\r\n    const pixels = texture.image.data;\r\n    if (!pixels) return;\r\n    let p = 0;\r\n    for (let j = 0; j < this.ny; j++) {\r\n      for (let i = 0; i < this.nx; i++) {\r\n        // const value = Math.sin(n * Math.PI * x) * Math.cos(n * Math.PI * y);\r\n        const value = 0;\r\n\r\n        pixels[p + 0] = map(value, -2, 2, 0, 255);\r\n        pixels[p + 1] = 0;\r\n        pixels[p + 2] = 1;\r\n        pixels[p + 3] = 1;\r\n        p += 4;\r\n      }\r\n    }\r\n  }\r\n  readReceiverLevels() {\r\n    const currentRenderTarget = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable);\r\n    this.readLevelShader.uniforms[\"levelTexture\"].value = currentRenderTarget[\"texture\"];\r\n    for (let i = 0; i < this.receiverKeys.length; i++) {\r\n      const key = this.receiverKeys[i];\r\n      if (this.receivers[key]) {\r\n        const u = (this.receivers[key].position.x - this.offsetX) / this.width;\r\n        const v = (this.receivers[key].position.y - this.offsetY) / this.height;\r\n        this.readLevelShader.uniforms[\"point1\"].value.set(u, v);\r\n        this.gpuCompute.doRenderTarget(this.readLevelShader, this.readLevelRenderTarget);\r\n        (renderer.renderer as WebGLRenderer).readRenderTargetPixels(\r\n          this.readLevelRenderTarget,\r\n          0,\r\n          0,\r\n          4,\r\n          1,\r\n          this.readLevelImage\r\n        );\r\n        const pixels = new Float32Array(this.readLevelImage.buffer);\r\n        const level = pixels[0];\r\n        this.receivers[key].fdtdSamples.push((level-127.5)/127.5);\r\n      }\r\n    }\r\n  }\r\n  clear() {\r\n    const currentRenderTarget = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable);\r\n    const alternateRenderTarget = this.gpuCompute.getAlternateRenderTarget(this.heightmapVariable);\r\n    this.clearShader.uniforms[\"clearTexture\"].value = currentRenderTarget[\"texture\"];\r\n    this.gpuCompute.doRenderTarget(this.clearShader, alternateRenderTarget);\r\n    this.clearShader.uniforms[\"clearTexture\"].value = alternateRenderTarget[\"texture\"];\r\n    this.gpuCompute.doRenderTarget(this.clearShader, currentRenderTarget);\r\n    this.time = 0;\r\n    this.frame = 0;\r\n  }\r\n  render() {\r\n    for (let i = 0; i < this.numPasses; i++) {\r\n      this.updateSourceTexture();\r\n\r\n      this.heightmapVariable.material[\"uniforms\"][\"sourcemap\"].value = this.sourcemap;\r\n\r\n      // Do the gpu computation\r\n      this.gpuCompute.compute();\r\n\r\n      if (this.recording) {\r\n        for (let j = 0; j < this.sourceKeys.length; j++){\r\n          this.sources[this.sourceKeys[j]].recordSample();\r\n        }\r\n        this.readReceiverLevels();\r\n      }\r\n\r\n      this.time += this.dt;\r\n      this.frame += 1;\r\n    }\r\n\r\n    // Get compute output in custom uniform\r\n    this.uniforms[\"heightmap\"].value = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable)[\"texture\"];\r\n  }\r\n  onParameterConfigFocus() {}\r\n  onParameterConfigBlur() {}\r\n}\r\n\r\nexport { FDTD_2D };\r\n\r\nexport default FDTD_2D;\r\n\r\n"],"names":["GPUComputationRenderer","sizeX","sizeY","renderer","dataType","FloatType","passThruUniforms","passThruShader","createShaderMaterial","getPassThroughFragmentShader","quad","FullScreenQuad","type","variableName","computeFragmentShader","initialValueTexture","material","variable","NearestFilter","dependencies","i","uniforms","d","depVar","found","j","currentTextureIndex","nextTextureIndex","il","dl","variables","renderTargets","addResolutionDefine","materialShader","ShaderMaterial","getPassThroughVertexShader","sizeXTexture","sizeYTexture","wrapS","wrapT","minFilter","magFilter","ClampToEdgeWrapping","WebGLRenderTarget","RGBAFormat","data","texture","DataTexture","input","output","currentRenderTarget","currentXrEnabled","currentShadowAutoUpdate","heightMapFrag","readLevelFrag","clearFrag","waterVert","waterFrag","shaders","rasterizeLine","x1","y1","x2","y2","pixels","x","y","dx","dy","dx1","dy1","px","py","xe","ye","FDTDWall","props","clamp","a","b","CELL_RESOLUTION","FDTD_2D_Defaults","FDTD_2D","Solver","surfaces","useContainer","surface","boundingBox","_width","_height","editGeometry","PlaneGeometry","editMaterials","MeshBasicMaterial","DoubleSide","MeshLambertMaterial","Mesh","postMessage","mode","EditorModes","width","height","geometry","heightmap","UniformsUtils","UniformsLib","Color","vertexShader","fragmentShader","side","heightmapInit","Vector2","error","UnsignedByteType","on","dispose","removeMessageHandler","show","source","id","receiver","positionAttr","p","index","value","vel","map","previndex","key","u","v","level","alternateRenderTarget"],"mappings":"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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAfC,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICMfC,IAAe;AAAA,EACb,eAAAL;AAAA,EACA,eAAAC;AAAA,EA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","x_google_ignoreList":[0]}