{"version":3,"file":"index-H8RHiQrY.mjs","sources":["../node_modules/three/examples/jsm/misc/GPUComputationRenderer.js","../src/compute/2d-fdtd/shaders/height-map.frag?raw","../src/compute/2d-fdtd/shaders/read-level.frag?raw","../src/compute/2d-fdtd/shaders/clear.frag?raw","../src/compute/2d-fdtd/shaders/water.vert?raw","../src/compute/2d-fdtd/shaders/water.frag?raw","../src/compute/2d-fdtd/shaders/index.ts","../src/compute/2d-fdtd/timestep.ts","../src/compute/2d-fdtd/rasterize-line.ts","../src/compute/2d-fdtd/fdtd-wall.ts","../src/common/clamp.ts","../src/compute/2d-fdtd/index.ts"],"sourcesContent":["import {\n\tClampToEdgeWrapping,\n\tDataTexture,\n\tFloatType,\n\tNearestFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tWebGLRenderTarget\n} from 'three';\n\nimport { FullScreenQuad } from '../postprocessing/Pass.js';\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by @zz85.\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel).\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * ```\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n * ```\n * Basic use:\n * ```js\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, vel0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, pos0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n * ```\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * ```js\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n * ```\n *\n * @three_import import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n */\nclass GPUComputationRenderer {\n\n\t/**\n\t * Constructs a new GPU computation renderer.\n\t *\n\t * @param {number} sizeX - Computation problem size is always 2d: sizeX * sizeY elements.\n \t * @param {number} sizeY - Computation problem size is always 2d: sizeX * sizeY elements.\n \t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\tconstructor( sizeX, sizeY, renderer ) {\n\n\t\tthis.variables = [];\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\tlet dataType = FloatType;\n\n\t\tconst passThruUniforms = {\n\t\t\tpassThruTexture: { value: null }\n\t\t};\n\n\t\tconst passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\t\tconst quad = new FullScreenQuad( passThruShader );\n\n\t\t/**\n\t\t * Sets the data type of the internal textures.\n\t\t *\n\t\t * @param {(FloatType|HalfFloatType)} type - The type to set.\n\t\t * @return {GPUComputationRenderer} A reference to this renderer.\n\t\t */\n\t\tthis.setDataType = function ( type ) {\n\n\t\t\tdataType = type;\n\t\t\treturn this;\n\n\t\t};\n\n\t\t/**\n\t\t * Adds a compute variable to the renderer.\n\t\t *\n\t\t * @param {string} variableName - The variable name.\n\t\t * @param {string} computeFragmentShader - The compute (fragment) shader source.\n\t\t * @param {Texture} initialValueTexture - The initial value texture.\n\t\t * @return {Object} The compute variable.\n\t\t */\n\t\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\t\tconst material = this.createShaderMaterial( computeFragmentShader );\n\n\t\t\tconst variable = {\n\t\t\t\tname: variableName,\n\t\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\t\tmaterial: material,\n\t\t\t\tdependencies: null,\n\t\t\t\trenderTargets: [],\n\t\t\t\twrapS: null,\n\t\t\t\twrapT: null,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t\tmagFilter: NearestFilter\n\t\t\t};\n\n\t\t\tthis.variables.push( variable );\n\n\t\t\treturn variable;\n\n\t\t};\n\n\t\t/**\n\t\t * Sets variable dependencies.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @param {Array<Object>} dependencies - Other compute variables that represents the dependencies.\n\t\t */\n\t\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\t\tvariable.dependencies = dependencies;\n\n\t\t};\n\n\t\t/**\n\t\t * Initializes the renderer.\n\t\t *\n\t\t * @return {?string} Returns `null` if no errors are detected. Otherwise returns the error message.\n\t\t */\n\t\tthis.init = function () {\n\n\t\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\t\treturn 'No support for vertex shader textures.';\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\t\tconst material = variable.material;\n\t\t\t\tconst uniforms = material.uniforms;\n\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tfor ( let d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\t\tlet found = false;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\t\treturn 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\t\tmaterial.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = 0;\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\t/**\n\t\t * Executes the compute. This method is usually called in the animation loop.\n\t\t */\n\t\tthis.compute = function () {\n\n\t\t\tconst currentTextureIndex = this.currentTextureIndex;\n\t\t\tconst nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\t\tfor ( let i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Sets texture dependencies uniforms\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tconst uniforms = variable.material.uniforms;\n\n\t\t\t\t\tfor ( let d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Performs the computation for this variable\n\t\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the current render target for the given compute variable.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @return {WebGLRenderTarget} The current render target.\n\t\t */\n\t\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the alternate render target for the given compute variable.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @return {WebGLRenderTarget} The alternate render target.\n\t\t */\n\t\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t\t};\n\n\t\t/**\n\t\t * Frees all internal resources. Call this method if you don't need the\n\t\t * renderer anymore.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\tquad.dispose();\n\n\t\t\tconst variables = this.variables;\n\n\t\t\tfor ( let i = 0; i < variables.length; i ++ ) {\n\n\t\t\t\tconst variable = variables[ i ];\n\n\t\t\t\tif ( variable.initialValueTexture ) variable.initialValueTexture.dispose();\n\n\t\t\t\tconst renderTargets = variable.renderTargets;\n\n\t\t\t\tfor ( let j = 0; j < renderTargets.length; j ++ ) {\n\n\t\t\t\t\tconst renderTarget = renderTargets[ j ];\n\t\t\t\t\trenderTarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction addResolutionDefine( materialShader ) {\n\n\t\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + ' )';\n\n\t\t}\n\n\t\t/**\n\t\t * Adds a resolution defined for the given material shader.\n\t\t *\n\t\t * @param {Object} materialShader - The material shader.\n\t\t */\n\t\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t\t// The following functions can be used to compute things manually\n\n\t\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\t\tuniforms = uniforms || {};\n\n\t\t\tconst material = new ShaderMaterial( {\n\t\t\t\tname: 'GPUComputationShader',\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\t\tfragmentShader: computeFragmentShader\n\t\t\t} );\n\n\t\t\taddResolutionDefine( material );\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tthis.createShaderMaterial = createShaderMaterial;\n\n\t\t/**\n\t\t * Creates a new render target from the given parameters.\n\t\t *\n\t\t * @param {number} sizeXTexture - The width of the render target.\n\t\t * @param {number} sizeYTexture - The height of the render target.\n\t\t * @param {number} wrapS - The wrapS value.\n\t\t * @param {number} wrapT - The wrapS value.\n\t\t * @param {number} minFilter - The minFilter value.\n\t\t * @param {number} magFilter - The magFilter value.\n\t\t * @return {WebGLRenderTarget} The new render target.\n\t\t */\n\t\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\t\twrapS = wrapS || ClampToEdgeWrapping;\n\t\t\twrapT = wrapT || ClampToEdgeWrapping;\n\n\t\t\tminFilter = minFilter || NearestFilter;\n\t\t\tmagFilter = magFilter || NearestFilter;\n\n\t\t\tconst renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\t\twrapS: wrapS,\n\t\t\t\twrapT: wrapT,\n\t\t\t\tminFilter: minFilter,\n\t\t\t\tmagFilter: magFilter,\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: dataType,\n\t\t\t\tdepthBuffer: false\n\t\t\t} );\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Creates a new data texture.\n\t\t *\n\t\t * @return {DataTexture} The new data texture.\n\t\t */\n\t\tthis.createTexture = function () {\n\n\t\t\tconst data = new Float32Array( sizeX * sizeY * 4 );\n\t\t\tconst texture = new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\n\t\t\ttexture.needsUpdate = true;\n\t\t\treturn texture;\n\n\t\t};\n\n\t\t/**\n\t\t * Renders the given texture into the given render target.\n\t\t *\n\t\t * @param {Texture} input - The input.\n\t\t * @param {WebGLRenderTarget} output - The output.\n\t\t */\n\t\tthis.renderTexture = function ( input, output ) {\n\n\t\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t\t};\n\n\n\t\t/**\n\t\t * Renders the given material into the given render target\n\t\t * with a full-screen pass.\n\t\t *\n\t\t * @param {Material} material - The material.\n\t\t * @param {WebGLRenderTarget} output - The output.\n\t\t */\n\t\tthis.doRenderTarget = function ( material, output ) {\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\tquad.material = material;\n\t\t\trenderer.setRenderTarget( output );\n\t\t\tquad.render( renderer );\n\t\t\tquad.material = passThruShader;\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t};\n\n\t\t// Shaders\n\n\t\tfunction getPassThroughVertexShader() {\n\n\t\t\treturn\t'void main()\t{\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_Position = vec4( position, 1.0 );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t\tfunction getPassThroughFragmentShader() {\n\n\t\t\treturn\t'uniform sampler2D passThruTexture;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'void main() {\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t}\n\n}\n\nexport { GPUComputationRenderer };\n","export default \"#include <common>\\n\\nuniform vec2 mousePos;\\nuniform float mouseSize;\\nuniform float damping;\\nuniform float heightCompensation;\\nuniform float courantSq;\\nuniform sampler2D sourcemap;\\n\\nvoid main()\\t{\\n\\n  vec2 cellSize = 1.0 / resolution.xy;\\n\\n  vec2 uv = gl_FragCoord.xy * cellSize;\\n    \\n  float newvel = 0.;\\n  float newpos = 0.;\\n\\n\\n  vec4 heightmapValue = texture2D( heightmap, uv );\\n  vec4 sourcemapValue = texture2D( sourcemap, uv);\\n  \\n\\n\\n  if(sourcemapValue.b > 0.0){\\n    float pos = heightmapValue.r;\\n    float vel = heightmapValue.g;\\n    \\n    \\n    \\n    vec2 ud_offset = vec2( 0.0, cellSize.y );\\n    vec2 rl_offset = vec2( cellSize.x, 0.0 );\\n    \\n    vec4 u = texture2D( heightmap, uv + ud_offset );    \\n    vec4 d = texture2D( heightmap, uv - ud_offset );\\n    vec4 r = texture2D( heightmap, uv + rl_offset );\\n    vec4 l = texture2D( heightmap, uv - rl_offset );\\n    \\n    float u_wall = texture2D( sourcemap, uv + ud_offset ).b;\\n    float d_wall = texture2D( sourcemap, uv - ud_offset ).b;\\n    float r_wall = texture2D( sourcemap, uv + rl_offset ).b;\\n    float l_wall = texture2D( sourcemap, uv - rl_offset ).b;\\n    \\n    \\n    // float u_pos = u_wall == 0 ? d.r : u.r;\\n    // float d_pos = d_wall == 0 ? u.r : d.r;\\n    // float r_pos = r_wall == 0 ? l.r : r.r;\\n    // float l_pos = l_wall == 0 ? r.r : l.r;\\n\\n    float u_pos =  u.r;\\n    float d_pos =  d.r;\\n    float r_pos =  r.r;\\n    float l_pos =  l.r;\\n    \\n    if(u_wall == 0.0){\\n      u_pos = texture2D( heightmap, uv - ud_offset ).r;\\n    }\\n    if(d_wall == 0.0){\\n      d_pos = texture2D( heightmap, uv + ud_offset ).r;\\n    }\\n    if(r_wall == 0.0){\\n      r_pos = texture2D( heightmap, uv - rl_offset ).r;\\n    }\\n    if(l_wall == 0.0){\\n      l_pos = texture2D( heightmap, uv + rl_offset ).r;\\n    }\\n\\n    float mid = 0.25*(u_pos+d_pos+r_pos+l_pos);\\n  \\n    float med = 4.0 * courantSq;\\n    newvel = med*(mid-pos)+vel*damping;\\n    newpos = pos+newvel;\\n    \\n    if(sourcemapValue.a == 0.0){  \\n      newvel = sourcemapValue.g;\\n      newpos = sourcemapValue.r;\\n    }    \\n  }\\n  else {\\n    newvel = 0.0;\\n    newpos = 127.5;\\n  }\\n  \\n  \\n  gl_FragColor = vec4(newpos, newvel, heightmapValue.b, sourcemapValue.b);\\n\\n\\n}\\n\"","export default \"uniform vec2 point1;\\nuniform float cell_size;\\nuniform float inv_cell_size;\\n\\nuniform sampler2D levelTexture;\\n\\n// Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target\\n\\nfloat shift_right( float v, float amt ) {\\n\\n\\tv = floor( v ) + 0.5;\\n\\treturn floor( v / exp2( amt ) );\\n\\n}\\n\\nfloat shift_left( float v, float amt ) {\\n\\n\\treturn floor( v * exp2( amt ) + 0.5 );\\n\\n}\\n\\nfloat mask_last( float v, float bits ) {\\n\\n\\treturn mod( v, shift_left( 1.0, bits ) );\\n\\n}\\n\\nfloat extract_bits( float num, float from, float to ) {\\n\\n\\tfrom = floor( from + 0.5 ); to = floor( to + 0.5 );\\n\\treturn mask_last( shift_right( num, from ), to - from );\\n\\n}\\n\\nvec4 encode_float( float val ) {\\n\\tif ( val == 0.0 ) return vec4( 0, 0, 0, 0 );\\n\\tfloat sign = val > 0.0 ? 0.0 : 1.0;\\n\\tval = abs( val );\\n\\tfloat exponent = floor( log2( val ) );\\n\\tfloat biased_exponent = exponent + 127.0;\\n\\tfloat fraction = ( ( val / exp2( exponent ) ) - 1.0 ) * 8388608.0;\\n\\tfloat t = biased_exponent / 2.0;\\n\\tfloat last_bit_of_biased_exponent = fract( t ) * 2.0;\\n\\tfloat remaining_bits_of_biased_exponent = floor( t );\\n\\tfloat byte4 = extract_bits( fraction, 0.0, 8.0 ) / 255.0;\\n\\tfloat byte3 = extract_bits( fraction, 8.0, 16.0 ) / 255.0;\\n\\tfloat byte2 = ( last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;\\n\\tfloat byte1 = ( sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;\\n\\treturn vec4( byte4, byte3, byte2, byte1 );\\n}\\n\\nvoid main()\\t{\\n\\n\\tvec2 cellSize = vec2(cell_size);\\n\\n\\tfloat waterLevel = texture2D( levelTexture, point1 ).x;\\n\\n\\tvec2 normal = vec2(\\n\\t\\t( texture2D( levelTexture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( levelTexture, point1 + vec2( cellSize.x, 0 ) ).x ) * inv_cell_size,\\n\\t\\t( texture2D( levelTexture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( levelTexture, point1 + vec2( 0, cellSize.y ) ).x ) * inv_cell_size );\\n\\n\\tif ( gl_FragCoord.x < 1.5 ) {\\n\\n\\t\\tgl_FragColor = encode_float( waterLevel );\\n\\n\\t} else if ( gl_FragCoord.x < 2.5 ) {\\n\\n\\t\\tgl_FragColor = encode_float( normal.x );\\n\\n\\t} else if ( gl_FragCoord.x < 3.5 ) {\\n\\n\\t\\tgl_FragColor = encode_float( normal.y );\\n\\n\\t} else {\\n\\n\\t\\tgl_FragColor = encode_float( 0.0 );\\n\\n\\t}\\n\\n}\"","export default \"uniform sampler2D clearTexture;\\n\\nvoid main()\\t{\\n\\n\\tvec2 cellSize = 1.0 / resolution.xy;\\n\\n\\tvec2 uv = gl_FragCoord.xy * cellSize;\\n\\n\\n\\tvec4 textureValue = texture2D( clearTexture, uv );\\n\\n\\ttextureValue.r = 127.5;\\n\\ttextureValue.g = 0.0;\\n\\n\\tgl_FragColor = textureValue;\\n\\n}\\n\"","export default \"uniform sampler2D heightmap;\\nuniform float inv_cell_size;\\nuniform float cell_size;\\nvarying float vHeight;\\nvarying float vWall;\\n#define PHONG\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\\tvarying vec3 vNormal;\\n\\n#endif\\n\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\nvoid main() {\\n\\n\\tvec2 cellSize = vec2( cell_size );\\n\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\n\\t// # include <beginnormal_vertex>\\n\\t// Compute normal from heightmap\\n\\tvec3 objectNormal = vec3(\\n\\t\\t( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * inv_cell_size,\\n\\t\\t( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * inv_cell_size,\\n\\t\\t1.0 );\\n\\t//<beginnormal_vertex>\\n\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\n\\n\\tvNormal = normalize( transformedNormal );\\n\\n#endif\\n\\n\\t//# include <begin_vertex>\\n\\tvec4 heightmapValue = texture2D( heightmap, uv );\\n\\tfloat heightValue = heightmapValue.x - 127.5;\\n\\tvHeight = heightValue;\\n\\tvWall = heightmapValue.a;\\n\\t\\n\\tvec3 transformed = vec3( position.x, position.y, heightValue );\\n\\t//<begin_vertex>\\n\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\n\\tvViewPosition = - mvPosition.xyz;\\n\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\n}\\n\"","export default \"#define PHONG\\n\\nvarying float vHeight;\\nvarying float vWall;\\n\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\nuniform float colorBrightness;\\n\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\nvoid main() {\\n\\n\\t#include <clipping_planes_fragment>\\n\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\n\\t// accumulation\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\n\\t// modulation\\n\\t#include <aomap_fragment>\\n\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\n\\t#include <envmap_fragment>\\n\\n\\tvec3 col = vec3(0.0,0.0,0.0);\\n\\tif(vHeight > 0.0){\\n\\t\\tcol.r = vHeight/127.5*colorBrightness;\\n\\t}\\n\\telse if(vHeight <= 0.0){\\n\\t\\tcol.g = -vHeight/127.5*colorBrightness;\\n\\t}\\n\\n\\tgl_FragColor = vec4( col, 1.0 );\\n\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n\\n}\"","import heightMapFrag from \"./height-map.frag?raw\";\nimport readLevelFrag from \"./read-level.frag?raw\";\nimport clearFrag from \"./clear.frag?raw\";\nimport waterVert from \"./water.vert?raw\";\nimport waterFrag from \"./water.frag?raw\";\n\nexport default {\n  heightMapFrag,\n  readLevelFrag,\n  clearFrag,\n  waterVert,\n  waterFrag\n};\n","/**\n * Compute the stable time step for the 2D FDTD wave equation.\n *\n * The 2D CFL condition requires C = c·dt/dx ≤ 1/√2.\n * Setting dt = dx / (c·√2) gives C = 1/√2 exactly (maximally stable).\n */\nexport function computeTimestep(cellSize: number, waveSpeed: number): number {\n  return cellSize / (waveSpeed * Math.SQRT2);\n}\n","export function rasterizeLine(x1: number, y1: number, x2: number, y2: number) {\n  \n  const pixels = [] as number[][];\n  \n  // Iterators, counters required by algorithm\n  let x, y, dx, dy, dx1, dy1, px, py, xe, ye, i;\n\n  // Calculate line deltas\n  dx = x2 - x1;\n  dy = y2 - y1;\n\n  // Create a positive copy of deltas (makes iterating easier)\n  dx1 = Math.abs(dx);\n  dy1 = Math.abs(dy);\n\n  // Calculate error intervals for both axis\n  px = 2 * dy1 - dx1;\n  py = 2 * dx1 - dy1;\n\n  // The line is X-axis dominant\n  if (dy1 <= dx1) {\n    // Line is drawn left to right\n    if (dx >= 0) {\n      x = x1;\n      y = y1;\n      xe = x2;\n    } else {\n      // Line is drawn right to left (swap ends)\n      x = x2;\n      y = y2;\n      xe = x1;\n    }\n\n    pixels.push([x, y]); // Draw first pixel\n\n    // Rasterize the line\n    for (i = 0; x < xe; i++) {\n      x = x + 1;\n\n      // Deal with octants...\n      if (px < 0) {\n        px = px + 2 * dy1;\n      } else {\n        if ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) {\n          y = y + 1;\n        } else {\n          y = y - 1;\n        }\n        px = px + 2 * (dy1 - dx1);\n      }\n\n      // Draw pixel from line span at\n      // currently rasterized position\n      pixels.push([x, y]); \n    }\n  } else {\n    // The line is Y-axis dominant\n\n    // Line is drawn bottom to top\n    if (dy >= 0) {\n      x = x1;\n      y = y1;\n      ye = y2;\n    } else {\n      // Line is drawn top to bottom\n      x = x2;\n      y = y2;\n      ye = y1;\n    }\n\n   pixels.push([x, y]); \n\n    // Rasterize the line\n    for (i = 0; y < ye; i++) {\n      y = y + 1;\n\n      // Deal with octants...\n      if (py <= 0) {\n        py = py + 2 * dx1;\n      } else {\n        if ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) {\n          x = x + 1;\n        } else {\n          x = x - 1;\n        }\n        py = py + 2 * (dx1 - dy1);\n      }\n\n      // Draw pixel from line span at\n      // currently rasterized position\n     pixels.push([x, y]); \n    }\n  }\n  return pixels;\n};\n\nexport default rasterizeLine;","import rasterizeLine from './rasterize-line';\n\nexport interface FDTDWallProps {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n}\n\nclass FDTDWall {\n  enabled: boolean;\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  cells: number[][];\n  previousCells: number[][];\n  shouldClearPreviousCells: boolean;\n  constructor(props: FDTDWallProps) {\n    this.x1 = props.x1;\n    this.y1 = props.y1;\n    this.x2 = props.x2;\n    this.y2 = props.y2;\n    this.cells = rasterizeLine(this.x1, this.y1, this.x2, this.y2);\n    this.previousCells = this.cells;\n    this.shouldClearPreviousCells = false;\n    this.enabled = true;\n  }\n  \n  move(props: FDTDWallProps) {\n    this.previousCells = this.cells;\n    this.x1 = props.x1;\n    this.y1 = props.y1;\n    this.x2 = props.x2;\n    this.y2 = props.y2;\n    this.cells = rasterizeLine(this.x1, this.y1, this.x2, this.y2);\n    this.shouldClearPreviousCells = true;\n  }\n}\n\nexport { FDTDWall };\n\nexport default FDTDWall;\n","export function clamp(v: number, a: number, b: number): number {\n  return v < a ? a : v > b ? b : v;\n}\n","import { on, postMessage, removeMessageHandler } from \"../../messenger\";\nimport {\n  PlaneGeometry,\n  ShaderMaterial,\n  UniformsLib,\n  Mesh,\n  WebGLRenderer,\n  DataTexture,\n  UniformsUtils,\n  Color,\n  DoubleSide,\n  Vector2,\n  IUniform,\n  WebGLRenderTarget,\n  ClampToEdgeWrapping,\n  NearestFilter,\n  RGBAFormat,\n  UnsignedByteType,\n  BufferGeometry,\n  MeshBasicMaterial,\n  MeshLambertMaterial\n} from \"three\";\nimport {\n  GPUComputationRenderer,\n  Variable\n} from \"three/examples/jsm/misc/GPUComputationRenderer.js\";\nimport shaders from \"./shaders\";\nimport Solver from \"../solver\";\nimport { computeTimestep } from \"./timestep\";\n\nimport Source from \"../../objects/source\";\nimport Receiver from \"../../objects/receiver\";\nimport map from \"../../common/map\";\nimport FDTDWall, { FDTDWallProps } from \"./fdtd-wall\";\nimport Surface from \"../../objects/surface\";\nimport { KeyValuePair } from \"../../common/key-value-pair\";\nimport { clamp } from \"../../common/clamp\";\nimport { EditorModes } from \"../../constants\";\nimport { useContainer } from \"../../store\";\nimport { renderer } from \"../../render/renderer\";\n\nconst CELL_RESOLUTION = 256;\n\nexport const FDTD_2D_Defaults = {\n  width: 10,\n  height: 10,\n  cellSize: 10 / CELL_RESOLUTION,\n  offsetX: 0,\n  offsetY: 0\n};\n\nexport interface FDTD_2D_Props {\n  width?: number;\n  height?: number;\n  cellSize?: number;\n  offsetX?: number;\n  offsetY?: number;\n}\n\nexport interface Uniforms {\n  [uniform: string]: IUniform;\n}\n\nclass FDTD_2D extends Solver {\n  gpuCompute!: GPUComputationRenderer;\n\n  /**\n   * number of x cells\n   */\n  nx: number;\n\n  /**\n   * number of y cells\n   */\n  ny: number;\n  \n  offsetX: number;\n  offsetY: number;\n\n  uniforms!: Uniforms;\n  mesh!: Mesh;\n  editMesh!: Mesh;\n  heightmapVariable!: Variable;\n  sourcemapVariable!: Variable;\n  sourcemap!: DataTexture;\n  readLevelShader!: ShaderMaterial;\n  readLevelImage!: Uint8Array;\n  readLevelRenderTarget!: WebGLRenderTarget;\n  sources!: KeyValuePair<Source>;\n  sourceKeys!: string[];\n  receivers!: KeyValuePair<Receiver>;\n  receiverKeys!: string[];\n  walls!: FDTDWall[];\n  /**\n   * simulation in seconds\n   */\n  time: number;\n\n  /**\n   * simulation time step in seconds\n   */\n  dt: number;\n  width: number;\n  height: number;\n  cellSize: number;\n  numPasses: number;\n  waveSpeed: number;\n  recording: boolean;\n  clearShader!: ShaderMaterial;\n  frame: number;\n  messageHandlers: string[][];\n  eventListeners: (()=>void)[];\n  constructor(props?: FDTD_2D_Props) {\n    super(props);\n    this.kind = \"fdtd-2d\";\n    this.running = false;\n    this.time = 0;\n    this.frame = 0;\n    this.numPasses = 1;\n    this.waveSpeed = 340.29;\n    this.recording = false;\n\n    const surfaces = [...useContainer.getState().selectedObjects.values()].filter(x=>x.kind===\"surface\") as Surface[];\n    let surface: Surface|null = null;\n    props = props || {};\n    if (surfaces.length > 0) {\n      surface = surfaces.length > 1 ? surfaces[0].mergeSurfaces(surfaces) : surfaces[0];\n      surface.mesh.geometry.computeBoundingBox();\n      const boundingBox = surface.mesh.geometry.boundingBox;\n      if (boundingBox) {\n        props.width = boundingBox.max.x - boundingBox.min.x;\n        props.height = boundingBox.max.y - boundingBox.min.y;\n        props.offsetX = boundingBox.min.x;\n        props.offsetY = boundingBox.min.y;\n      }\n    }\n    const _width = (props && props.width) || FDTD_2D_Defaults.width;\n    const _height = (props && props.height) || FDTD_2D_Defaults.height;\n\n    this.offsetX = (props && props.offsetX) || FDTD_2D_Defaults.offsetX;\n    this.offsetY = (props && props.offsetY) || FDTD_2D_Defaults.offsetY;\n\n    this.cellSize = (props && props.cellSize) || Math.max(_width, _height) / CELL_RESOLUTION;\n\n    this.nx = Math.ceil(_width / this.cellSize);\n    this.ny = Math.ceil(_height / this.cellSize);\n\n    this.width = this.nx * this.cellSize;\n    this.height = this.ny * this.cellSize;\n\n    this.dt = computeTimestep(this.cellSize, this.waveSpeed);\n\n    this.sources = {} as KeyValuePair<Source>;\n    this.sourceKeys = [] as string[];\n    this.receivers = {} as KeyValuePair<Receiver>;\n    this.receiverKeys = [] as string[];\n    this.walls = [] as FDTDWall[];\n    this.messageHandlers = [] as string[][];\n    this.eventListeners = [] as (()=>void)[];\n\n    const editGeometry = new PlaneGeometry(this.width, this.height, 1, 1);\n    editGeometry.translate(this.width/2, this.height/2, 0);\n    editGeometry.translate(this.offsetX, this.offsetY, 0);\n    const editMaterials = [\n      new MeshBasicMaterial({ wireframe: true, side: DoubleSide, color: 0x707070 }),\n      new MeshLambertMaterial({ transparent: true, opacity: 0.35, side: DoubleSide, color: 0x707070 })\n    ];\n    \n    this.editMesh = new Mesh(editGeometry, editMaterials[0]);\n    this.editMesh.name = \"fdtd-2d-edit-mesh\";\n    this.editMesh.visible = false;\n    \n    renderer.fdtdItems.add(this.editMesh);\n    \n\n    this.fillTexture = this.fillTexture.bind(this);\n    this.init = this.init.bind(this);\n    this.render = this.render.bind(this);\n    this.updateWalls = this.updateWalls.bind(this);\n    this.updateSourceTexture = this.updateSourceTexture.bind(this);\n    this.addWallsFromSurfaceEdges = this.addWallsFromSurfaceEdges.bind(this);\n    this.setWireframeVisible = this.setWireframeVisible.bind(this);\n    this.getWireframeVisible = this.getWireframeVisible.bind(this);\n    this.toggleWall = this.toggleWall.bind(this);\n    this.clear = this.clear.bind(this);\n    \n    \n    this.init();\n    \n    this.onModeChange(postMessage(\"GET_EDITOR_MODE\")[0]);\n\n    if(surface){\n      this.addWallsFromSurfaceEdges(surface);\n    }\n    \n\n  }\n  onModeChange(mode: EditorModes) {\n    switch (mode) {\n      case EditorModes.OBJECT: { \n        this.editMesh.visible = false;\n        this.mesh.visible = true;\n      } break;\n      case EditorModes.SKETCH: { \n        this.editMesh.visible = false;\n        this.mesh.visible = false;\n      } break;\n      case EditorModes.EDIT: { \n        this.editMesh.visible = true;\n        this.mesh.visible = false;\n      } break;\n      default: break;\n    }\n  }\n  setWidth(width: number) {\n    this.nx = Math.ceil(width / this.cellSize);\n    this.width = this.nx * this.cellSize;\n  }\n  setHeight(height: number) {\n    this.ny = Math.ceil(height / this.cellSize);\n    this.height = this.ny * this.cellSize;\n  }\n  \n  setDimmensions(width: number, height: number) {\n    this.setWidth(width);\n    this.setHeight(height);\n  }\n  \n  init() {\n    this.dispose();\n    const geometry = new PlaneGeometry(this.width, this.height, this.nx - 1, this.ny - 1);\n    geometry.name = \"fdtd-2d-plane-geometry\";\n    geometry.translate(this.width / 2, this.height / 2, 0);\n    geometry.translate(this.offsetX, this.offsetY, 0);\n    const heightmap = { value: null };\n    const uniforms = UniformsUtils.merge([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.gradientmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: new Color(0x000000) },\n        specular: { value: new Color(0x111111) },\n        shininess: { value: 30 },\n        colorBrightness: { value: 10 },\n        cell_size: { value: this.cellSize },\n        inv_cell_size: { value: 1 / this.cellSize },\n        heightmap\n      }\n    ]);\n    const vertexShader = shaders.waterVert;\n    const fragmentShader = shaders.waterFrag;\n    const side = DoubleSide;\n    const material = new ShaderMaterial({\n      uniforms,\n      vertexShader,\n      fragmentShader,\n      side,\n      name: \"fdtd-2d-material\"\n    });\n    material.lights = true;\n\n    this.uniforms = material.uniforms;\n    this.mesh = new Mesh(geometry, material);\n\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    // this.mesh.scale.setScalar(this.width / this.nx);\n    (this.mesh.material as ShaderMaterial).wireframe = false;\n    this.mesh.matrixAutoUpdate = true;\n    this.mesh.scale.setZ(0.01);\n    renderer.fdtdItems.add(this.mesh);\n\n    this.gpuCompute = new GPUComputationRenderer(this.nx, this.ny, renderer.renderer as WebGLRenderer);\n\n    let heightmapInit = this.gpuCompute.createTexture();\n    this.sourcemap = this.gpuCompute.createTexture();\n    this.fillSourceTexture();\n    this.updateSourceTexture();\n    this.fillTexture(heightmapInit);\n    this.heightmapVariable = this.gpuCompute.addVariable(\"heightmap\", shaders.heightMapFrag, heightmapInit);\n    this.gpuCompute.setVariableDependencies(this.heightmapVariable, [this.heightmapVariable]);\n\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"sourcemap\"] = { value: this.sourcemap };\n\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"mousePos\"] = { value: new Vector2(5, 5) };\n\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"mouseSize\"] = { value: 0.0 };\n\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"damping\"] = { value: 0.9999 };\n\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"courantSq\"] = { value: (this.waveSpeed * this.dt / this.cellSize) ** 2 };\n\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"heightCompensation\"] = { value: 0 };\n\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"cell_size\"] = { value: this.cellSize };\n\n    (this.heightmapVariable.material as ShaderMaterial).uniforms[\"inv_cell_size\"] = { value: 1 / this.cellSize };\n\n    const error = this.gpuCompute.init();\n    if (error !== null) {\n      console.error(error);\n    }\n\n    this.clearShader = this.gpuCompute[\"createShaderMaterial\"](shaders.clearFrag, { clearTexture: { value: null } });\n\n    this.readLevelShader = this.gpuCompute[\"createShaderMaterial\"](shaders.readLevelFrag, {\n      point1: { value: new Vector2() },\n      levelTexture: { value: null },\n      cell_size: { value: this.cellSize },\n      inv_cell_size: { value: 1 / this.cellSize }\n    });\n\n    // Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation\n    this.readLevelImage = new Uint8Array(4 * 1 * 4);\n\n    this.readLevelRenderTarget = new WebGLRenderTarget(4, 1, {\n      wrapS: ClampToEdgeWrapping,\n      wrapT: ClampToEdgeWrapping,\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n      format: RGBAFormat,\n      type: UnsignedByteType,\n      stencilBuffer: false,\n      depthBuffer: false\n    });\n    \n\n    this.eventListeners.push(on(\"RENDERER_UPDATED\", ()=>{\n      if (this.running) this.render();\n    }));\n    this.render();\n    this.clear();\n  }\n  editSize() {\n    // this.mesh.visible = false;\n  }\n  dispose() {\n    this.eventListeners.forEach(dispose => dispose());\n\n    for (let i = 0; i < this.messageHandlers.length; i++) {\n      removeMessageHandler(this.messageHandlers[i][0], this.messageHandlers[i][1]); \n    }\n    this.mesh && renderer.fdtdItems.remove(this.mesh);\n    this.messageHandlers = [] as string[][];\n  }\n  run() {\n    this.running = true;\n    renderer.fdtd2drunning = true;\n  }\n  stop() {\n    this.running = false;\n    renderer.fdtd2drunning = false;\n  }\n  // save() {\n  //   return pickProps([\"name\", \"uuid\", \"width\", \"height\", \"offsetX\", \"offsetY\", \"cellSize\"], this);\n  // }\n  setWireframeVisible(show: boolean) {\n    (this.mesh.material as ShaderMaterial).wireframe = show;\n  }\n  getWireframeVisible() {\n    return (this.mesh.material as ShaderMaterial).wireframe;\n  }\n  addSource(source: Source) {\n    this.sourceKeys = [...new Set(this.sourceKeys.concat(source.uuid))];\n    this.sources[source.uuid] = source;\n  }\n  removeSource(id: string) {\n    if (this.sources[id]) {\n      delete this.sources[id];\n      this.sourceKeys = this.sourceKeys.filter((x) => x !== id);\n    }\n  }\n  addReceiver(receiver: Receiver) {\n    this.receiverKeys = [...new Set(this.receiverKeys.concat(receiver.uuid))];\n    this.receivers[receiver.uuid] = receiver;\n  }\n  removeReceiver(id: string) {\n    if (this.receivers[id]) {\n      delete this.receivers[id];\n      this.receiverKeys = this.receiverKeys.filter((x) => x !== id);\n    }\n  }\n  addWall(props: FDTDWallProps) {\n    const x1 = clamp(Math.floor((props.x1 - this.offsetX) / this.cellSize), 0, this.nx - 1);\n    const y1 = clamp(Math.floor((props.y1 - this.offsetY) / this.cellSize), 0, this.ny - 1);\n    const x2 = clamp(Math.floor((props.x2 - this.offsetX) / this.cellSize), 0, this.nx - 1);\n    const y2 = clamp(Math.floor((props.y2 - this.offsetY) / this.cellSize), 0, this.ny - 1);\n    this.walls.push(new FDTDWall({ x1, y1, x2, y2 }));\n    this.updateWalls();\n  }\n  addWallsFromSurfaceEdges(surface: Surface) {\n    const positionAttr = (surface.edges.geometry as BufferGeometry).getAttribute('position');\n    for (let i = 0; i < positionAttr.count; i += 2) {\n      let x1 = clamp(Math.floor((positionAttr.getX(i) - this.offsetX) / this.cellSize), 0, this.nx - 1);\n      let y1 = clamp(Math.floor((positionAttr.getY(i) - this.offsetY) / this.cellSize), 0, this.ny - 1);\n      let x2 = clamp(Math.floor((positionAttr.getX(i + 1) - this.offsetX) / this.cellSize), 0, this.nx - 1);\n      let y2 = clamp(Math.floor((positionAttr.getY(i + 1) - this.offsetY) / this.cellSize), 0, this.ny - 1);\n      this.walls.push(new FDTDWall({ x1, y1, x2, y2 }));\n    }\n    this.updateWalls();\n  }\n\n  fillSourceTexture() {\n    const pixels = this.sourcemap.image.data;\n    if (!pixels) return;\n    let p = 0;\n    for (let j = 0; j < this.ny; j++) {\n      for (let i = 0; i < this.nx; i++) {\n        pixels[p + 0] = 0;\n        pixels[p + 1] = 0;\n        pixels[p + 2] = 1;\n        pixels[p + 3] = 1;\n        p += 4;\n      }\n    }\n  }\n\n  toggleWall(index: number) {\n    if (this.walls[index]) {\n      this.walls[index].enabled = !this.walls[index].enabled;\n      this.updateWalls();\n    }\n  }\n\n  updateWalls() {\n    const data = this.sourcemap.image.data;\n    if (!data) return;\n    for (let i = 0; i < this.walls.length; i++) {\n      if (this.walls[i].shouldClearPreviousCells) {\n        for (let j = 0; j < this.walls[i].previousCells.length; j++) {\n          const index = 4 * (this.walls[i].previousCells[j][1] * this.nx + this.walls[i].previousCells[j][0]);\n          data[index + 2] = 1;\n        }\n        this.walls[i].shouldClearPreviousCells = false;\n      }\n      if (this.walls[i].enabled) {\n        for (let j = 0; j < this.walls[i].cells.length; j++) {\n          const index = 4 * (this.walls[i].cells[j][1] * this.nx + this.walls[i].cells[j][0]);\n          data[index + 2] = 0;\n        }\n      } else {\n        for (let j = 0; j < this.walls[i].cells.length; j++) {\n          const index = 4 * (this.walls[i].cells[j][1] * this.nx + this.walls[i].cells[j][0]);\n          data[index + 2] = 1;\n        }\n      }\n    }\n    this.sourcemap.needsUpdate = true;\n  }\n\n  updateSourceTexture() {\n    const pixels = this.sourcemap.image.data;\n    if (!pixels) return;\n    for (let i = 0; i < this.sourceKeys.length; i++) {\n      const x = Math.round((this.sources[this.sourceKeys[i]].x - this.offsetX) / this.cellSize);\n      const y = Math.round((this.sources[this.sourceKeys[i]].y - this.offsetY) / this.cellSize);\n      const index = 4 * (y * this.nx + x);\n      this.sources[this.sourceKeys[i]].updateWave(this.time, this.frame, this.dt);\n      const value = this.sources[this.sourceKeys[i]].value;\n      const vel = this.sources[this.sourceKeys[i]].velocity;\n      pixels[index + 0] = map(value, -2, 2, 0, 255);\n      pixels[index + 1] = map(vel, -2, 2, 0, 255);\n      pixels[index + 3] = 0;\n\n      if (this.sources[this.sourceKeys[i]].shouldClearPreviousPosition) {\n        const px = Math.round((this.sources[this.sourceKeys[i]].previousX - this.offsetX) / this.cellSize);\n        const py = Math.round((this.sources[this.sourceKeys[i]].previousY - this.offsetY) / this.cellSize);\n        const previndex = 4 * (py * this.nx + px);\n        pixels[previndex + 0] = 0;\n        pixels[previndex + 1] = 0;\n        pixels[previndex + 3] = 1;\n        this.sources[this.sourceKeys[i]].shouldClearPreviousPosition = false;\n        this.sources[this.sourceKeys[i]].updatePreviousPosition();\n      }\n    }\n    this.sourcemap.needsUpdate = true;\n  }\n  fillTexture(texture: DataTexture) {\n    const pixels = texture.image.data;\n    if (!pixels) return;\n    let p = 0;\n    for (let j = 0; j < this.ny; j++) {\n      for (let i = 0; i < this.nx; i++) {\n        // const value = Math.sin(n * Math.PI * x) * Math.cos(n * Math.PI * y);\n        const value = 0;\n\n        pixels[p + 0] = map(value, -2, 2, 0, 255);\n        pixels[p + 1] = 0;\n        pixels[p + 2] = 1;\n        pixels[p + 3] = 1;\n        p += 4;\n      }\n    }\n  }\n  readReceiverLevels() {\n    const currentRenderTarget = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable);\n    this.readLevelShader.uniforms[\"levelTexture\"].value = currentRenderTarget[\"texture\"];\n    for (let i = 0; i < this.receiverKeys.length; i++) {\n      const key = this.receiverKeys[i];\n      if (this.receivers[key]) {\n        const u = (this.receivers[key].position.x - this.offsetX) / this.width;\n        const v = (this.receivers[key].position.y - this.offsetY) / this.height;\n        this.readLevelShader.uniforms[\"point1\"].value.set(u, v);\n        this.gpuCompute.doRenderTarget(this.readLevelShader, this.readLevelRenderTarget);\n        (renderer.renderer as WebGLRenderer).readRenderTargetPixels(\n          this.readLevelRenderTarget,\n          0,\n          0,\n          4,\n          1,\n          this.readLevelImage\n        );\n        const pixels = new Float32Array(this.readLevelImage.buffer);\n        const level = pixels[0];\n        this.receivers[key].fdtdSamples.push((level-127.5)/127.5);\n      }\n    }\n  }\n  clear() {\n    const currentRenderTarget = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable);\n    const alternateRenderTarget = this.gpuCompute.getAlternateRenderTarget(this.heightmapVariable);\n    this.clearShader.uniforms[\"clearTexture\"].value = currentRenderTarget[\"texture\"];\n    this.gpuCompute.doRenderTarget(this.clearShader, alternateRenderTarget);\n    this.clearShader.uniforms[\"clearTexture\"].value = alternateRenderTarget[\"texture\"];\n    this.gpuCompute.doRenderTarget(this.clearShader, currentRenderTarget);\n    this.time = 0;\n    this.frame = 0;\n  }\n  render() {\n    for (let i = 0; i < this.numPasses; i++) {\n      this.updateSourceTexture();\n\n      this.heightmapVariable.material[\"uniforms\"][\"sourcemap\"].value = this.sourcemap;\n\n      // Do the gpu computation\n      this.gpuCompute.compute();\n\n      if (this.recording) {\n        for (let j = 0; j < this.sourceKeys.length; j++){\n          this.sources[this.sourceKeys[j]].recordSample();\n        }\n        this.readReceiverLevels();\n      }\n\n      this.time += this.dt;\n      this.frame += 1;\n    }\n\n    // Get compute output in custom uniform\n    this.uniforms[\"heightmap\"].value = this.gpuCompute.getCurrentRenderTarget(this.heightmapVariable)[\"texture\"];\n  }\n  onParameterConfigFocus() {}\n  onParameterConfigBlur() {}\n}\n\nexport { FDTD_2D };\n\nexport default FDTD_2D;\n\n"],"names":["GPUComputationRenderer","sizeX","sizeY","renderer","dataType","FloatType","passThruUniforms","passThruShader","createShaderMaterial","getPassThroughFragmentShader","quad","FullScreenQuad","type","variableName","computeFragmentShader","initialValueTexture","material","variable","NearestFilter","dependencies","i","uniforms","d","depVar","found","j","currentTextureIndex","nextTextureIndex","il","dl","variables","renderTargets","addResolutionDefine","materialShader","ShaderMaterial","getPassThroughVertexShader","sizeXTexture","sizeYTexture","wrapS","wrapT","minFilter","magFilter","ClampToEdgeWrapping","WebGLRenderTarget","RGBAFormat","data","texture","DataTexture","input","output","currentRenderTarget","currentXrEnabled","currentShadowAutoUpdate","heightMapFrag","readLevelFrag","clearFrag","waterVert","waterFrag","shaders","computeTimestep","cellSize","waveSpeed","rasterizeLine","x1","y1","x2","y2","pixels","x","y","dx","dy","dx1","dy1","px","py","xe","ye","FDTDWall","props","clamp","v","a","b","CELL_RESOLUTION","FDTD_2D_Defaults","FDTD_2D","Solver","surfaces","useContainer","surface","boundingBox","_width","_height","editGeometry","PlaneGeometry","editMaterials","MeshBasicMaterial","DoubleSide","MeshLambertMaterial","Mesh","postMessage","mode","EditorModes","width","height","geometry","heightmap","UniformsUtils","UniformsLib","Color","vertexShader","fragmentShader","side","heightmapInit","Vector2","error","UnsignedByteType","on","dispose","removeMessageHandler","show","source","id","receiver","positionAttr","p","index","value","vel","map","previndex","key","u","level","alternateRenderTarget"],"mappings":"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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAfC,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICMfC,IAAe;AAAA,EACb,eAAAL;AAAA,EACA,eAAAC;AAAA,EACA,WAAAC;AAAA,EACA,WAAAC;AAAA,EACA,WAAAC;AACF;ACNO,SAASE,GAAgBC,GAAkBC,GAA2B;AAC3E,SAAOD,KAAYC,IAAY,KAAK;AACtC;ACRO,SAASC,EAAcC,GAAYC,GAAYC,GAAYC,GAAY;AAE5E,QAAMC,IAAS,CAAA;AAGf,MAAIC,GAAGC,GAAGC,GAAIC,GAAIC,GAAKC,GAAKC,GAAIC,GAAIC,GAAIC,GAAIzD;AAe5C,MAZAkD,IAAKL,IAAKF,GACVQ,IAAKL,IAAKF,GAGVQ,IAAM,KAAK,IAAIF,CAAE,GACjBG,IAAM,KAAK,IAAIF,CAAE,GAGjBG,IAAK,IAAID,IAAMD,GACfG,IAAK,IAAIH,IAAMC,GAGXA,KAAOD;AAgBT,SAdIF,KAAM,KACRF,IAAIL,GACJM,IAAIL,GACJY,IAAKX,MAGLG,IAAIH,GACJI,IAAIH,GACJU,IAAKb,IAGPI,EAAO,KAAK,CAACC,GAAGC,CAAC,CAAC,GAGbjD,IAAI,GAAGgD,IAAIQ,GAAIxD;AAClB,MAAAgD,IAAIA,IAAI,GAGJM,IAAK,IACPA,IAAKA,IAAK,IAAID,KAETH,IAAK,KAAKC,IAAK,KAAOD,IAAK,KAAKC,IAAK,IACxCF,IAAIA,IAAI,IAERA,IAAIA,IAAI,GAEVK,IAAKA,IAAK,KAAKD,IAAMD,KAKvBL,EAAO,KAAK,CAACC,GAAGC,CAAC,CAAC;AAAA;AAoBpB,SAdIE,KAAM,KACRH,IAAIL,GACJM,IAAIL,GACJa,IAAKX,MAGLE,IAAIH,GACJI,IAAIH,GACJW,IAAKb,IAGRG,EAAO,KAAK,CAACC,GAAGC,CAAC,CAAC,GAGZjD,IAAI,GAAGiD,IAAIQ,GAAIzD;AAClB,MAAAiD,IAAIA,IAAI,GAGJM,KAAM,IACRA,IAAKA,IAAK,IAAIH,KAETF,IAAK,KAAKC,IAAK,KAAOD,IAAK,KAAKC,IAAK,IACxCH,IAAIA,IAAI,IAERA,IAAIA,IAAI,GAEVO,IAAKA,IAAK,KAAKH,IAAMC,KAKxBN,EAAO,KAAK,CAACC,GAAGC,CAAC,CAAC;AAGrB,SAAOF;AACT;ACrFA,MAAMW,EAAS;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAYC,GAAsB;AAChC,SAAK,KAAKA,EAAM,IAChB,KAAK,KAAKA,EAAM,IAChB,KAAK,KAAKA,EAAM,IAChB,KAAK,KAAKA,EAAM,IAChB,KAAK,QAAQjB,EAAc,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,EAAE,GAC7D,KAAK,gBAAgB,KAAK,OAC1B,KAAK,2BAA2B,IAChC,KAAK,UAAU;AAAA,EACjB;AAAA,EAEA,KAAKiB,GAAsB;AACzB,SAAK,gBAAgB,KAAK,OAC1B,KAAK,KAAKA,EAAM,IAChB,KAAK,KAAKA,EAAM,IAChB,KAAK,KAAKA,EAAM,IAChB,KAAK,KAAKA,EAAM,IAChB,KAAK,QAAQjB,EAAc,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,EAAE,GAC7D,KAAK,2BAA2B;AAAA,EAClC;AACF;ACtCO,SAASkB,EAAMC,GAAWC,GAAWC,GAAmB;AAC7D,SAAOF,IAAIC,IAAIA,IAAID,IAAIE,IAAIA,IAAIF;AACjC;ACuCA,MAAMG,KAAkB,KAEXC,IAAmB;AAAA,EAC9B,OAAO;AAAA,EACP,QAAQ;AAAA,EAER,SAAS;AAAA,EACT,SAAS;AACX;AAcA,MAAMC,WAAgBC,EAAO;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAYR,GAAuB;AACjC,UAAMA,CAAK,GACX,KAAK,OAAO,WACZ,KAAK,UAAU,IACf,KAAK,OAAO,GACZ,KAAK,QAAQ,GACb,KAAK,YAAY,GACjB,KAAK,YAAY,QACjB,KAAK,YAAY;AAEjB,UAAMS,IAAW,CAAC,GAAGC,EAAa,WAAW,gBAAgB,QAAQ,EAAE,OAAO,CAAArB,MAAGA,EAAE,SAAO,SAAS;AACnG,QAAIsB,IAAwB;AAE5B,QADAX,IAAQA,KAAS,CAAA,GACbS,EAAS,SAAS,GAAG;AACvB,MAAAE,IAAUF,EAAS,SAAS,IAAIA,EAAS,CAAC,EAAE,cAAcA,CAAQ,IAAIA,EAAS,CAAC,GAChFE,EAAQ,KAAK,SAAS,mBAAA;AACtB,YAAMC,IAAcD,EAAQ,KAAK,SAAS;AAC1C,MAAIC,MACFZ,EAAM,QAAQY,EAAY,IAAI,IAAIA,EAAY,IAAI,GAClDZ,EAAM,SAASY,EAAY,IAAI,IAAIA,EAAY,IAAI,GACnDZ,EAAM,UAAUY,EAAY,IAAI,GAChCZ,EAAM,UAAUY,EAAY,IAAI;AAAA,IAEpC;AACA,UAAMC,IAAUb,KAASA,EAAM,SAAUM,EAAiB,OACpDQ,IAAWd,KAASA,EAAM,UAAWM,EAAiB;AAE5D,SAAK,UAAWN,KAASA,EAAM,WAAYM,EAAiB,SAC5D,KAAK,UAAWN,KAASA,EAAM,WAAYM,EAAiB,SAE5D,KAAK,WAAYN,KAASA,EAAM,YAAa,KAAK,IAAIa,GAAQC,CAAO,IAAIT,IAEzE,KAAK,KAAK,KAAK,KAAKQ,IAAS,KAAK,QAAQ,GAC1C,KAAK,KAAK,KAAK,KAAKC,IAAU,KAAK,QAAQ,GAE3C,KAAK,QAAQ,KAAK,KAAK,KAAK,UAC5B,KAAK,SAAS,KAAK,KAAK,KAAK,UAE7B,KAAK,KAAKlC,GAAgB,KAAK,UAAU,KAAK,SAAS,GAEvD,KAAK,UAAU,CAAA,GACf,KAAK,aAAa,CAAA,GAClB,KAAK,YAAY,CAAA,GACjB,KAAK,eAAe,CAAA,GACpB,KAAK,QAAQ,CAAA,GACb,KAAK,kBAAkB,CAAA,GACvB,KAAK,iBAAiB,CAAA;AAEtB,UAAMmC,IAAe,IAAIC,EAAc,KAAK,OAAO,KAAK,QAAQ,GAAG,CAAC;AACpE,IAAAD,EAAa,UAAU,KAAK,QAAM,GAAG,KAAK,SAAO,GAAG,CAAC,GACrDA,EAAa,UAAU,KAAK,SAAS,KAAK,SAAS,CAAC;AACpD,UAAME,IAAgB;AAAA,MACpB,IAAIC,EAAkB,EAAE,WAAW,IAAM,MAAMC,GAAY,OAAO,SAAU;AAAA,MAC5E,IAAIC,EAAoB,EAAE,aAAa,IAAM,SAAS,MAAM,MAAMD,GAAY,OAAO,QAAA,CAAU;AAAA,IAAA;AAGjG,SAAK,WAAW,IAAIE,EAAKN,GAAcE,EAAc,CAAC,CAAC,GACvD,KAAK,SAAS,OAAO,qBACrB,KAAK,SAAS,UAAU,IAExB7F,EAAS,UAAU,IAAI,KAAK,QAAQ,GAGpC,KAAK,cAAc,KAAK,YAAY,KAAK,IAAI,GAC7C,KAAK,OAAO,KAAK,KAAK,KAAK,IAAI,GAC/B,KAAK,SAAS,KAAK,OAAO,KAAK,IAAI,GACnC,KAAK,cAAc,KAAK,YAAY,KAAK,IAAI,GAC7C,KAAK,sBAAsB,KAAK,oBAAoB,KAAK,IAAI,GAC7D,KAAK,2BAA2B,KAAK,yBAAyB,KAAK,IAAI,GACvE,KAAK,sBAAsB,KAAK,oBAAoB,KAAK,IAAI,GAC7D,KAAK,sBAAsB,KAAK,oBAAoB,KAAK,IAAI,GAC7D,KAAK,aAAa,KAAK,WAAW,KAAK,IAAI,GAC3C,KAAK,QAAQ,KAAK,MAAM,KAAK,IAAI,GAGjC,KAAK,KAAA,GAEL,KAAK,aAAakG,EAAY,iBAAiB,EAAE,CAAC,CAAC,GAEhDX,KACD,KAAK,yBAAyBA,CAAO;AAAA,EAIzC;AAAA,EACA,aAAaY,GAAmB;AAC9B,YAAQA,GAAA;AAAA,MACN,KAAKC,EAAY;AACf,aAAK,SAAS,UAAU,IACxB,KAAK,KAAK,UAAU;AACpB;AAAA,MACF,KAAKA,EAAY;AACf,aAAK,SAAS,UAAU,IACxB,KAAK,KAAK,UAAU;AACpB;AAAA,MACF,KAAKA,EAAY;AACf,aAAK,SAAS,UAAU,IACxB,KAAK,KAAK,UAAU;AACpB;AAAA,IACO;AAAA,EAEb;AAAA,EACA,SAASC,GAAe;AACtB,SAAK,KAAK,KAAK,KAAKA,IAAQ,KAAK,QAAQ,GACzC,KAAK,QAAQ,KAAK,KAAK,KAAK;AAAA,EAC9B;AAAA,EACA,UAAUC,GAAgB;AACxB,SAAK,KAAK,KAAK,KAAKA,IAAS,KAAK,QAAQ,GAC1C,KAAK,SAAS,KAAK,KAAK,KAAK;AAAA,EAC/B;AAAA,EAEA,eAAeD,GAAeC,GAAgB;AAC5C,SAAK,SAASD,CAAK,GACnB,KAAK,UAAUC,CAAM;AAAA,EACvB;AAAA,EAEA,OAAO;AACL,SAAK,QAAA;AACL,UAAMC,IAAW,IAAIX,EAAc,KAAK,OAAO,KAAK,QAAQ,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC;AACpF,IAAAW,EAAS,OAAO,0BAChBA,EAAS,UAAU,KAAK,QAAQ,GAAG,KAAK,SAAS,GAAG,CAAC,GACrDA,EAAS,UAAU,KAAK,SAAS,KAAK,SAAS,CAAC;AAChD,UAAMC,IAAY,EAAE,OAAO,KAAA,GACrBtF,IAAWuF,EAAc,MAAM;AAAA,MACnCC,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZA,EAAY;AAAA,MACZ;AAAA,QACE,UAAU,EAAE,OAAO,IAAIC,EAAM,CAAQ,EAAA;AAAA,QACrC,UAAU,EAAE,OAAO,IAAIA,EAAM,OAAQ,EAAA;AAAA,QACrC,WAAW,EAAE,OAAO,GAAA;AAAA,QACpB,iBAAiB,EAAE,OAAO,GAAA;AAAA,QAC1B,WAAW,EAAE,OAAO,KAAK,SAAA;AAAA,QACzB,eAAe,EAAE,OAAO,IAAI,KAAK,SAAA;AAAA,QACjC,WAAAH;AAAA,MAAA;AAAA,IACF,CACD,GACKI,IAAerD,EAAQ,WACvBsD,IAAiBtD,EAAQ,WACzBuD,IAAOf,GACPlF,IAAW,IAAIkB,EAAe;AAAA,MAClC,UAAAb;AAAA,MACA,cAAA0F;AAAA,MACA,gBAAAC;AAAA,MACA,MAAAC;AAAA,MACA,MAAM;AAAA,IAAA,CACP;AACD,IAAAjG,EAAS,SAAS,IAElB,KAAK,WAAWA,EAAS,UACzB,KAAK,OAAO,IAAIoF,EAAKM,GAAU1F,CAAQ,GAEvC,KAAK,KAAK,mBAAmB,IAC7B,KAAK,KAAK,aAAA,GAET,KAAK,KAAK,SAA4B,YAAY,IACnD,KAAK,KAAK,mBAAmB,IAC7B,KAAK,KAAK,MAAM,KAAK,IAAI,GACzBb,EAAS,UAAU,IAAI,KAAK,IAAI,GAEhC,KAAK,aAAa,IAAIH,EAAuB,KAAK,IAAI,KAAK,IAAIG,EAAS,QAAyB;AAEjG,QAAI+G,IAAgB,KAAK,WAAW,cAAA;AACpC,SAAK,YAAY,KAAK,WAAW,cAAA,GACjC,KAAK,kBAAA,GACL,KAAK,oBAAA,GACL,KAAK,YAAYA,CAAa,GAC9B,KAAK,oBAAoB,KAAK,WAAW,YAAY,aAAaxD,EAAQ,eAAewD,CAAa,GACtG,KAAK,WAAW,wBAAwB,KAAK,mBAAmB,CAAC,KAAK,iBAAiB,CAAC,GAEvF,KAAK,kBAAkB,SAA4B,SAAS,YAAe,EAAE,OAAO,KAAK,UAAA,GAEzF,KAAK,kBAAkB,SAA4B,SAAS,WAAc,EAAE,OAAO,IAAIC,EAAQ,GAAG,CAAC,EAAA,GAEnG,KAAK,kBAAkB,SAA4B,SAAS,YAAe,EAAE,OAAO,EAAA,GAEpF,KAAK,kBAAkB,SAA4B,SAAS,UAAa,EAAE,OAAO,OAAA,GAElF,KAAK,kBAAkB,SAA4B,SAAS,YAAe,EAAE,QAAQ,KAAK,YAAY,KAAK,KAAK,KAAK,aAAa,EAAA,GAElI,KAAK,kBAAkB,SAA4B,SAAS,qBAAwB,EAAE,OAAO,EAAA,GAE7F,KAAK,kBAAkB,SAA4B,SAAS,YAAe,EAAE,OAAO,KAAK,SAAA,GAEzF,KAAK,kBAAkB,SAA4B,SAAS,gBAAmB,EAAE,OAAO,IAAI,KAAK,SAAA;AAElG,UAAMC,IAAQ,KAAK,WAAW,KAAA;AAC9B,IAAIA,MAAU,QACZ,QAAQ,MAAMA,CAAK,GAGrB,KAAK,cAAc,KAAK,WAAW,qBAAwB1D,EAAQ,WAAW,EAAE,cAAc,EAAE,OAAO,KAAA,GAAQ,GAE/G,KAAK,kBAAkB,KAAK,WAAW,qBAAwBA,EAAQ,eAAe;AAAA,MACpF,QAAQ,EAAE,OAAO,IAAIyD,IAAQ;AAAA,MAC7B,cAAc,EAAE,OAAO,KAAA;AAAA,MACvB,WAAW,EAAE,OAAO,KAAK,SAAA;AAAA,MACzB,eAAe,EAAE,OAAO,IAAI,KAAK,SAAA;AAAA,IAAS,CAC3C,GAGD,KAAK,iBAAiB,IAAI,WAAW,EAAS,GAE9C,KAAK,wBAAwB,IAAIxE,EAAkB,GAAG,GAAG;AAAA,MACvD,OAAOD;AAAA,MACP,OAAOA;AAAA,MACP,WAAWxB;AAAA,MACX,WAAWA;AAAA,MACX,QAAQ0B;AAAA,MACR,MAAMyE;AAAA,MACN,eAAe;AAAA,MACf,aAAa;AAAA,IAAA,CACd,GAGD,KAAK,eAAe,KAAKC,EAAG,oBAAoB,MAAI;AAClD,MAAI,KAAK,WAAS,KAAK,OAAA;AAAA,IACzB,CAAC,CAAC,GACF,KAAK,OAAA,GACL,KAAK,MAAA;AAAA,EACP;AAAA,EACA,WAAW;AAAA,EAEX;AAAA,EACA,UAAU;AACR,SAAK,eAAe,QAAQ,CAAAC,MAAWA,EAAA,CAAS;AAEhD,aAASnG,IAAI,GAAGA,IAAI,KAAK,gBAAgB,QAAQA;AAC/C,MAAAoG,EAAqB,KAAK,gBAAgBpG,CAAC,EAAE,CAAC,GAAG,KAAK,gBAAgBA,CAAC,EAAE,CAAC,CAAC;AAE7E,SAAK,QAAQjB,EAAS,UAAU,OAAO,KAAK,IAAI,GAChD,KAAK,kBAAkB,CAAA;AAAA,EACzB;AAAA,EACA,MAAM;AACJ,SAAK,UAAU,IACfA,EAAS,gBAAgB;AAAA,EAC3B;AAAA,EACA,OAAO;AACL,SAAK,UAAU,IACfA,EAAS,gBAAgB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAIA,oBAAoBsH,GAAe;AAChC,SAAK,KAAK,SAA4B,YAAYA;AAAA,EACrD;AAAA,EACA,sBAAsB;AACpB,WAAQ,KAAK,KAAK,SAA4B;AAAA,EAChD;AAAA,EACA,UAAUC,GAAgB;AACxB,SAAK,aAAa,CAAC,GAAG,IAAI,IAAI,KAAK,WAAW,OAAOA,EAAO,IAAI,CAAC,CAAC,GAClE,KAAK,QAAQA,EAAO,IAAI,IAAIA;AAAA,EAC9B;AAAA,EACA,aAAaC,GAAY;AACvB,IAAI,KAAK,QAAQA,CAAE,MACjB,OAAO,KAAK,QAAQA,CAAE,GACtB,KAAK,aAAa,KAAK,WAAW,OAAO,CAACvD,MAAMA,MAAMuD,CAAE;AAAA,EAE5D;AAAA,EACA,YAAYC,GAAoB;AAC9B,SAAK,eAAe,CAAC,GAAG,IAAI,IAAI,KAAK,aAAa,OAAOA,EAAS,IAAI,CAAC,CAAC,GACxE,KAAK,UAAUA,EAAS,IAAI,IAAIA;AAAA,EAClC;AAAA,EACA,eAAeD,GAAY;AACzB,IAAI,KAAK,UAAUA,CAAE,MACnB,OAAO,KAAK,UAAUA,CAAE,GACxB,KAAK,eAAe,KAAK,aAAa,OAAO,CAACvD,MAAMA,MAAMuD,CAAE;AAAA,EAEhE;AAAA,EACA,QAAQ5C,GAAsB;AAC5B,UAAMhB,IAAKiB,EAAM,KAAK,OAAOD,EAAM,KAAK,KAAK,WAAW,KAAK,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC,GAChFf,IAAKgB,EAAM,KAAK,OAAOD,EAAM,KAAK,KAAK,WAAW,KAAK,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC,GAChFd,IAAKe,EAAM,KAAK,OAAOD,EAAM,KAAK,KAAK,WAAW,KAAK,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC,GAChFb,IAAKc,EAAM,KAAK,OAAOD,EAAM,KAAK,KAAK,WAAW,KAAK,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC;AACtF,SAAK,MAAM,KAAK,IAAID,EAAS,EAAE,IAAAf,GAAI,IAAAC,GAAI,IAAAC,GAAI,IAAAC,EAAA,CAAI,CAAC,GAChD,KAAK,YAAA;AAAA,EACP;AAAA,EACA,yBAAyBwB,GAAkB;AACzC,UAAMmC,IAAgBnC,EAAQ,MAAM,SAA4B,aAAa,UAAU;AACvF,aAAS,IAAI,GAAG,IAAImC,EAAa,OAAO,KAAK,GAAG;AAC9C,UAAI9D,IAAKiB,EAAM,KAAK,OAAO6C,EAAa,KAAK,CAAC,IAAI,KAAK,WAAW,KAAK,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC,GAC5F7D,IAAKgB,EAAM,KAAK,OAAO6C,EAAa,KAAK,CAAC,IAAI,KAAK,WAAW,KAAK,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC,GAC5F5D,IAAKe,EAAM,KAAK,OAAO6C,EAAa,KAAK,IAAI,CAAC,IAAI,KAAK,WAAW,KAAK,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC,GAChG3D,IAAKc,EAAM,KAAK,OAAO6C,EAAa,KAAK,IAAI,CAAC,IAAI,KAAK,WAAW,KAAK,QAAQ,GAAG,GAAG,KAAK,KAAK,CAAC;AACpG,WAAK,MAAM,KAAK,IAAI/C,EAAS,EAAE,IAAAf,GAAI,IAAAC,GAAI,IAAAC,GAAI,IAAAC,EAAA,CAAI,CAAC;AAAA,IAClD;AACA,SAAK,YAAA;AAAA,EACP;AAAA,EAEA,oBAAoB;AAClB,UAAMC,IAAS,KAAK,UAAU,MAAM;AACpC,QAAI,CAACA,EAAQ;AACb,QAAI2D,IAAI;AACR,aAASrG,IAAI,GAAGA,IAAI,KAAK,IAAIA;AAC3B,eAASL,IAAI,GAAGA,IAAI,KAAK,IAAIA;AAC3B,QAAA+C,EAAO2D,IAAI,CAAC,IAAI,GAChB3D,EAAO2D,IAAI,CAAC,IAAI,GAChB3D,EAAO2D,IAAI,CAAC,IAAI,GAChB3D,EAAO2D,IAAI,CAAC,IAAI,GAChBA,KAAK;AAAA,EAGX;AAAA,EAEA,WAAWC,GAAe;AACxB,IAAI,KAAK,MAAMA,CAAK,MAClB,KAAK,MAAMA,CAAK,EAAE,UAAU,CAAC,KAAK,MAAMA,CAAK,EAAE,SAC/C,KAAK,YAAA;AAAA,EAET;AAAA,EAEA,cAAc;AACZ,UAAMlF,IAAO,KAAK,UAAU,MAAM;AAClC,QAAKA,GACL;AAAA,eAASzB,IAAI,GAAGA,IAAI,KAAK,MAAM,QAAQA,KAAK;AAC1C,YAAI,KAAK,MAAMA,CAAC,EAAE,0BAA0B;AAC1C,mBAASK,IAAI,GAAGA,IAAI,KAAK,MAAML,CAAC,EAAE,cAAc,QAAQK,KAAK;AAC3D,kBAAMsG,IAAQ,KAAK,KAAK,MAAM3G,CAAC,EAAE,cAAcK,CAAC,EAAE,CAAC,IAAI,KAAK,KAAK,KAAK,MAAML,CAAC,EAAE,cAAcK,CAAC,EAAE,CAAC;AACjG,YAAAoB,EAAKkF,IAAQ,CAAC,IAAI;AAAA,UACpB;AACA,eAAK,MAAM3G,CAAC,EAAE,2BAA2B;AAAA,QAC3C;AACA,YAAI,KAAK,MAAMA,CAAC,EAAE;AAChB,mBAASK,IAAI,GAAGA,IAAI,KAAK,MAAML,CAAC,EAAE,MAAM,QAAQK,KAAK;AACnD,kBAAMsG,IAAQ,KAAK,KAAK,MAAM3G,CAAC,EAAE,MAAMK,CAAC,EAAE,CAAC,IAAI,KAAK,KAAK,KAAK,MAAML,CAAC,EAAE,MAAMK,CAAC,EAAE,CAAC;AACjF,YAAAoB,EAAKkF,IAAQ,CAAC,IAAI;AAAA,UACpB;AAAA;AAEA,mBAAStG,IAAI,GAAGA,IAAI,KAAK,MAAML,CAAC,EAAE,MAAM,QAAQK,KAAK;AACnD,kBAAMsG,IAAQ,KAAK,KAAK,MAAM3G,CAAC,EAAE,MAAMK,CAAC,EAAE,CAAC,IAAI,KAAK,KAAK,KAAK,MAAML,CAAC,EAAE,MAAMK,CAAC,EAAE,CAAC;AACjF,YAAAoB,EAAKkF,IAAQ,CAAC,IAAI;AAAA,UACpB;AAAA,MAEJ;AACA,WAAK,UAAU,cAAc;AAAA;AAAA,EAC/B;AAAA,EAEA,sBAAsB;AACpB,UAAM5D,IAAS,KAAK,UAAU,MAAM;AACpC,QAAKA,GACL;AAAA,eAAS/C,IAAI,GAAGA,IAAI,KAAK,WAAW,QAAQA,KAAK;AAC/C,cAAMgD,IAAI,KAAK,OAAO,KAAK,QAAQ,KAAK,WAAWhD,CAAC,CAAC,EAAE,IAAI,KAAK,WAAW,KAAK,QAAQ,GAElF2G,IAAQ,KADJ,KAAK,OAAO,KAAK,QAAQ,KAAK,WAAW3G,CAAC,CAAC,EAAE,IAAI,KAAK,WAAW,KAAK,QAAQ,IACjE,KAAK,KAAKgD;AACjC,aAAK,QAAQ,KAAK,WAAWhD,CAAC,CAAC,EAAE,WAAW,KAAK,MAAM,KAAK,OAAO,KAAK,EAAE;AAC1E,cAAM4G,IAAQ,KAAK,QAAQ,KAAK,WAAW5G,CAAC,CAAC,EAAE,OACzC6G,IAAM,KAAK,QAAQ,KAAK,WAAW7G,CAAC,CAAC,EAAE;AAK7C,YAJA+C,EAAO4D,IAAQ,CAAC,IAAIG,EAAIF,GAAO,IAAI,GAAG,GAAG,GAAG,GAC5C7D,EAAO4D,IAAQ,CAAC,IAAIG,EAAID,GAAK,IAAI,GAAG,GAAG,GAAG,GAC1C9D,EAAO4D,IAAQ,CAAC,IAAI,GAEhB,KAAK,QAAQ,KAAK,WAAW3G,CAAC,CAAC,EAAE,6BAA6B;AAChE,gBAAMsD,IAAK,KAAK,OAAO,KAAK,QAAQ,KAAK,WAAWtD,CAAC,CAAC,EAAE,YAAY,KAAK,WAAW,KAAK,QAAQ,GAE3F+G,IAAY,KADP,KAAK,OAAO,KAAK,QAAQ,KAAK,WAAW/G,CAAC,CAAC,EAAE,YAAY,KAAK,WAAW,KAAK,QAAQ,IACrE,KAAK,KAAKsD;AACtC,UAAAP,EAAOgE,IAAY,CAAC,IAAI,GACxBhE,EAAOgE,IAAY,CAAC,IAAI,GACxBhE,EAAOgE,IAAY,CAAC,IAAI,GACxB,KAAK,QAAQ,KAAK,WAAW/G,CAAC,CAAC,EAAE,8BAA8B,IAC/D,KAAK,QAAQ,KAAK,WAAWA,CAAC,CAAC,EAAE,uBAAA;AAAA,QACnC;AAAA,MACF;AACA,WAAK,UAAU,cAAc;AAAA;AAAA,EAC/B;AAAA,EACA,YAAY0B,GAAsB;AAChC,UAAMqB,IAASrB,EAAQ,MAAM;AAC7B,QAAI,CAACqB,EAAQ;AACb,QAAI2D,IAAI;AACR,aAASrG,IAAI,GAAGA,IAAI,KAAK,IAAIA;AAC3B,eAASL,IAAI,GAAGA,IAAI,KAAK,IAAIA;AAI3B,QAAA+C,EAAO2D,IAAI,CAAC,IAAII,EAAI,GAAO,IAAI,GAAG,GAAG,GAAG,GACxC/D,EAAO2D,IAAI,CAAC,IAAI,GAChB3D,EAAO2D,IAAI,CAAC,IAAI,GAChB3D,EAAO2D,IAAI,CAAC,IAAI,GAChBA,KAAK;AAAA,EAGX;AAAA,EACA,qBAAqB;AACnB,UAAM5E,IAAsB,KAAK,WAAW,uBAAuB,KAAK,iBAAiB;AACzF,SAAK,gBAAgB,SAAS,aAAgB,QAAQA,EAAoB;AAC1E,aAAS9B,IAAI,GAAGA,IAAI,KAAK,aAAa,QAAQA,KAAK;AACjD,YAAMgH,IAAM,KAAK,aAAahH,CAAC;AAC/B,UAAI,KAAK,UAAUgH,CAAG,GAAG;AACvB,cAAMC,KAAK,KAAK,UAAUD,CAAG,EAAE,SAAS,IAAI,KAAK,WAAW,KAAK,OAC3DnD,KAAK,KAAK,UAAUmD,CAAG,EAAE,SAAS,IAAI,KAAK,WAAW,KAAK;AACjE,aAAK,gBAAgB,SAAS,OAAU,MAAM,IAAIC,GAAGpD,CAAC,GACtD,KAAK,WAAW,eAAe,KAAK,iBAAiB,KAAK,qBAAqB,GAC9E9E,EAAS,SAA2B;AAAA,UACnC,KAAK;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,KAAK;AAAA,QAAA;AAGP,cAAMmI,IADS,IAAI,aAAa,KAAK,eAAe,MAAM,EACrC,CAAC;AACtB,aAAK,UAAUF,CAAG,EAAE,YAAY,MAAME,IAAM,SAAO,KAAK;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAAA,EACA,QAAQ;AACN,UAAMpF,IAAsB,KAAK,WAAW,uBAAuB,KAAK,iBAAiB,GACnFqF,IAAwB,KAAK,WAAW,yBAAyB,KAAK,iBAAiB;AAC7F,SAAK,YAAY,SAAS,aAAgB,QAAQrF,EAAoB,SACtE,KAAK,WAAW,eAAe,KAAK,aAAaqF,CAAqB,GACtE,KAAK,YAAY,SAAS,aAAgB,QAAQA,EAAsB,SACxE,KAAK,WAAW,eAAe,KAAK,aAAarF,CAAmB,GACpE,KAAK,OAAO,GACZ,KAAK,QAAQ;AAAA,EACf;AAAA,EACA,SAAS;AACP,aAAS9B,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AAQvC,UAPA,KAAK,oBAAA,GAEL,KAAK,kBAAkB,SAAS,SAAY,UAAa,QAAQ,KAAK,WAGtE,KAAK,WAAW,QAAA,GAEZ,KAAK,WAAW;AAClB,iBAASK,IAAI,GAAGA,IAAI,KAAK,WAAW,QAAQA;AAC1C,eAAK,QAAQ,KAAK,WAAWA,CAAC,CAAC,EAAE,aAAA;AAEnC,aAAK,mBAAA;AAAA,MACP;AAEA,WAAK,QAAQ,KAAK,IAClB,KAAK,SAAS;AAAA,IAChB;AAGA,SAAK,SAAS,UAAa,QAAQ,KAAK,WAAW,uBAAuB,KAAK,iBAAiB,EAAE;AAAA,EACpG;AAAA,EACA,yBAAyB;AAAA,EAAC;AAAA,EAC1B,wBAAwB;AAAA,EAAC;AAC3B;","x_google_ignoreList":[0]}