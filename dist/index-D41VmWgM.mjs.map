{"version":3,"file":"index-D41VmWgM.mjs","sources":["../src/compute/raytracer/shaders/points/shader.vert?raw","../src/compute/raytracer/shaders/points/shader.frag?raw","../src/compute/raytracer/shaders/points/index.ts","../src/common/dir-angle-conversions.ts","../src/common/observable.ts","../src/compute/raytracer/types.ts","../src/common/probability.ts","../src/compute/raytracer/ray-core.ts","../src/compute/raytracer/impulse-response.ts","../src/compute/raytracer/response-by-intensity.ts","../src/compute/raytracer/serialization.ts","../src/compute/raytracer/export-playback.ts","../src/compute/raytracer/convergence.ts","../src/compute/raytracer/gpu/gpu-bvh.ts","../src/compute/raytracer/gpu/ray-trace.wgsl?raw","../src/compute/raytracer/gpu/gpu-ray-tracer.ts","../src/compute/raytracer/index.ts"],"sourcesContent":["export default \"attribute vec2 color;\\nvarying vec2 vColor;\\nuniform float pointScale;\\nvoid main() {\\n  vColor = color;\\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n  gl_PointSize = pointScale*(color.x/4.0+0.5);\\n  gl_Position = projectionMatrix * mvPosition;\\n  \\n}\"","export default \"varying vec2 vColor;\\nuniform float drawStyle;\\nuniform int inverted;\\nvec3 hsl2rgb(vec3 c)\\n{\\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\\n}\\n\\nvec3 rgb2hsl( vec3 c ){\\n  float h = 0.0;\\n\\tfloat s = 0.0;\\n\\tfloat l = 0.0;\\n\\tfloat r = c.r;\\n\\tfloat g = c.g;\\n\\tfloat b = c.b;\\n\\tfloat cMin = min( r, min( g, b ) );\\n\\tfloat cMax = max( r, max( g, b ) );\\n\\n\\tl = ( cMax + cMin ) / 2.0;\\n\\tif ( cMax > cMin ) {\\n\\t\\tfloat cDelta = cMax - cMin;\\n        \\n        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original\\n\\t\\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\\n        \\n\\t\\tif ( r == cMax ) {\\n\\t\\t\\th = ( g - b ) / cDelta;\\n\\t\\t} else if ( g == cMax ) {\\n\\t\\t\\th = 2.0 + ( b - r ) / cDelta;\\n\\t\\t} else {\\n\\t\\t\\th = 4.0 + ( r - g ) / cDelta;\\n\\t\\t}\\n\\n\\t\\tif ( h < 0.0) {\\n\\t\\t\\th += 6.0;\\n\\t\\t}\\n\\t\\th = h / 6.0;\\n\\t}\\n\\treturn vec3( h, s, l );\\n}\\n\\nvoid main() {\\n  vec3 color = vec3(0.0);\\n\\tfloat alpha = vColor.x;\\n  if(drawStyle == 0.0){\\n    vec3 col = hsl2rgb(vec3(vColor.x/10.0,0.8, vColor.x));\\n    color = col;\\n\\t\\talpha = vColor.x;\\n  }\\n  else if(drawStyle == 1.0){\\n    vec3 col = hsl2rgb(vec3(vColor.y,vColor.x,vColor.y));\\n    vec3 col2 = vec3(vColor.x,vColor.x,1.0-vColor.y);\\n    color = col*col2;\\n\\t\\talpha = vColor.x;\\n  }\\n\\tif(inverted != 0){\\n\\t\\tcolor = vec3(1.0) - color;\\n\\t}\\n  gl_FragColor = vec4(color, alpha);\\n  \\n}\"","import vs from \"./shader.vert?raw\";\nimport fs from \"./shader.frag?raw\";\n\nexport default {\n  vs,\n  fs\n};\n","export function cramangle2threejsangle(phiCRAM: number, thetaCRAM: number): number[]{\n\n    // converts CRAM angle convention (in DEGREES) to ThreeJS angle convention (in RADIANS)\n    // accounts for coordinate system and symbol convention shift \n\n    let thetaThreeJS: number = (360-phiCRAM)*(Math.PI/180); \n    let phiThreeJS: number = thetaCRAM*(Math.PI/180); \n\n    return [phiThreeJS, thetaThreeJS];\n\n\n}","\n\ntype Destructor = () => void;\ntype Watcher<T> = (value: T, previousValue: T) => void;\n\nexport class Observable<T = any> {\n  public constructor(private v: T){}\n  private watchers = new Set<Watcher<T>>();\n  public get value(): T {\n    return this.v;\n  }\n  public set value(value: T) {\n    const old = this.v;\n    this.v = value;\n    this.watchers.forEach((watcher) => watcher(this.v, old))\n  }\n\n  public watch(callback: Watcher<T>): Destructor {\n    this.watchers.add(callback);\n    return () => this.watchers.delete(callback);\n  }\n\n  public toJSON(): string {\n    return JSON.stringify(this.v);\n  }\n\n  public toString(): string {\n    return String(this.v);\n  }\n}\n\nconst ensureArray = <T>(value: T|T[]) => value instanceof Array ? value : [value];\n\nexport default function observe<T = any>(value: T, watchers?: Watcher<T>[] | Watcher<T>){\n  const observable = new Observable(value); \n  watchers && ensureArray(watchers).forEach(watcher => observable.watch(watcher));\n  return observable;\n}\n\n","import { KVP } from \"../../common/key-value-pair\";\nimport { PlotData } from \"plotly.js\";\n\n// ── Named constants replacing magic numbers ──────────────────────────\n\n/** Offset along normal to avoid self-intersection when continuing a ray */\nexport const SELF_INTERSECTION_OFFSET = 0.01;\n\n// Re-exported from shared response-by-intensity-types\nexport { DEFAULT_INTENSITY_SAMPLE_RATE } from \"../shared/response-by-intensity-types\";\n\n/** Default initial SPL (dB) for impulse response calculations */\nexport const DEFAULT_INITIAL_SPL = 100;\n\n/** Extra time (seconds) appended to impulse response duration */\nexport const RESPONSE_TIME_PADDING = 0.05;\n\n// Re-exported from shared quick-estimate-types\nexport { QUICK_ESTIMATE_MAX_ORDER } from \"../shared/quick-estimate-types\";\n\n/** Maximum number of display points for downsampled IR charts */\nexport const MAX_DISPLAY_POINTS = 2000;\n\n// Re-exported from shared quick-estimate-types\nexport { RT60_DECAY_RATIO } from \"../shared/quick-estimate-types\";\n\n// Re-exported from shared tail-synthesis-types\nexport { HISTOGRAM_BIN_WIDTH, HISTOGRAM_NUM_BINS } from \"../shared/tail-synthesis-types\";\n\n/** Interval in milliseconds between convergence checks */\nexport const CONVERGENCE_CHECK_INTERVAL_MS = 500;\n\n// Re-exported from shared tail-synthesis-types\nexport { DEFAULT_TAIL_CROSSFADE_DURATION, MIN_TAIL_DECAY_RATE, MAX_TAIL_END_TIME } from \"../shared/tail-synthesis-types\";\n\n// ── Interfaces and types ─────────────────────────────────────────────\n\n// Re-exported from shared tail-synthesis-types\nexport type { DecayParameters } from \"../shared/tail-synthesis-types\";\n\n// Re-exported from shared quick-estimate-types\nexport type { QuickEstimateStepResult } from \"../shared/quick-estimate-types\";\n\n// Re-exported from shared response-by-intensity-types\nexport type { RayPathResult, ResponseByIntensity } from \"../shared/response-by-intensity-types\";\n\nexport type BandEnergy = number[];\n\nexport interface Chain {\n  angle_in?: number;\n  angle_out?: number;\n  total_time?: number;\n  time_rec?: number;\n  angle_rec?: number;\n  distance: number;\n  // point: THREE.Vector3;\n  point: [number, number, number];\n  object: string;\n  faceNormal: [number, number, number];\n  faceIndex: number;\n  faceMaterialIndex: number;\n  angle: number;\n  energy: number;\n  bandEnergy?: BandEnergy;\n}\n\n\nexport interface RayPath {\n  intersectedReceiver: boolean;\n  chain: Chain[];\n  chainLength: number;\n  energy: number; // used for visualization\n  bandEnergy?: BandEnergy;\n  time: number;\n  source: string;\n  initialPhi: number;\n  initialTheta: number;\n  totalLength: number;\n  /** Direction from which the ray arrives at the receiver (normalized, in receiver's local space) */\n  arrivalDirection?: [number, number, number];\n}\nexport interface EnergyTime {\n  time: number;\n  energy: {\n    frequency: number;\n    value: number;\n  }[];\n}\n// helper type\nexport type ChartData = {\n  label: string;\n  data: number[][];\n  x?: number[];\n  y?: number[];\n};\n\nexport interface ReceiverData {\n  id: string;\n  data: EnergyTime[];\n}\nexport class ReceiverData {\n  constructor(id: string) {\n    this.id = id;\n    this.data = [] as EnergyTime[];\n  }\n}\n\nexport type RayTracerSaveObject = {\n  name: string;\n  kind: \"ray-tracer\";\n  uuid: string;\n  autoCalculate: boolean;\n  roomID: string;\n  sourceIDs: string[];\n  surfaceIDs: string[];\n  receiverIDs: string[];\n  updateInterval: number;\n  passes: number;\n  pointSize: number;\n  reflectionOrder: number;\n  runningWithoutReceivers: boolean;\n  raysVisible: boolean;\n  pointsVisible: boolean;\n  invertedDrawStyle: boolean;\n  plotStyle: Partial<PlotData>;\n  paths: KVP<RayPath[]>;\n  frequencies: number[];\n  convergenceThreshold?: number;\n  autoStop?: boolean;\n  rrThreshold?: number;\n  maxStoredPaths?: number;\n  edgeDiffractionEnabled?: boolean;\n  lateReverbTailEnabled?: boolean;\n  tailCrossfadeTime?: number;\n  tailCrossfadeDuration?: number;\n  gpuEnabled?: boolean;\n  gpuBatchSize?: number;\n  hrtfSubjectId?: string;\n  headYaw?: number;\n  headPitch?: number;\n  headRoll?: number;\n}\n\nexport interface RayTracerParams {\n  name?: string;\n  roomID?: string;\n  sourceIDs?: string[];\n  surfaceIDs?: string[];\n  receiverIDs?: string[];\n  updateInterval?: number;\n  passes?: number;\n  pointSize?: number;\n  reflectionOrder?: number;\n  isRunning?: boolean;\n  runningWithoutReceivers?: boolean;\n  raysVisible?: boolean;\n  pointsVisible?: boolean;\n  invertedDrawStyle?: boolean;\n  plotStyle?: Partial<PlotData>;\n  uuid?: string;\n  paths?: KVP<RayPath[]>;\n  frequencies?: number[];\n  convergenceThreshold?: number;\n  autoStop?: boolean;\n  rrThreshold?: number;\n  maxStoredPaths?: number;\n  edgeDiffractionEnabled?: boolean;\n  lateReverbTailEnabled?: boolean;\n  tailCrossfadeTime?: number;\n  tailCrossfadeDuration?: number;\n  gpuEnabled?: boolean;\n  gpuBatchSize?: number;\n  hrtfSubjectId?: string;\n  headYaw?: number;\n  headPitch?: number;\n  headRoll?: number;\n}\nexport interface ConvergenceMetrics {\n  totalRays: number;\n  validRays: number;\n  estimatedT30: number[];        // per band, latest estimate\n  t30Mean: number[];             // running mean of T30 estimates\n  t30M2: number[];               // running M2 for Welford's variance\n  t30Count: number;              // number of T30 samples taken\n  convergenceRatio: number;      // max(std/mean) across bands\n}\n\nexport const defaults = {\n  name: \"Ray Tracer\",\n  roomID: \"\",\n  sourceIDs: [] as string[],\n  surfaceIDs: [] as string[],\n  receiverIDs: [] as string[],\n  updateInterval: 5,\n  reflectionOrder: 50,\n  isRunning: false,\n  runningWithoutReceivers: false,\n  passes: 100,\n  pointSize: 2,\n  raysVisible: true,\n  pointsVisible: true,\n  invertedDrawStyle: false,\n  paths: {} as KVP<RayPath[]>,\n  plotStyle: {\n    mode: \"lines\"\n  } as Partial<PlotData>,\n  frequencies: [125, 250, 500, 1000, 2000, 4000, 8000] as number[],\n  convergenceThreshold: 0.01,\n  autoStop: true,\n  rrThreshold: 0.1,\n  maxStoredPaths: 100000,\n  edgeDiffractionEnabled: false,\n  lateReverbTailEnabled: false,\n  tailCrossfadeTime: 0,\n  tailCrossfadeDuration: 0.05,\n  gpuEnabled: false,\n  gpuBatchSize: 10000,\n};\n\nexport enum DRAWSTYLE {\n  ENERGY = 0.0,\n  ANGLE = 1.0,\n  ANGLE_ENERGY = 2.0\n}\nexport interface DrawStyle {\n  ENERGY: 0.0;\n  ANGLE: 1.0;\n  ANGLE_ENERGY: 2.0;\n}\n\n// ── Helper functions ─────────────────────────────────────────────────\n\nexport function normalize(arr: Float32Array) {\n  let maxValue = Math.abs(arr[0]);\n  for (let i = 1; i < arr.length; i++){\n    if (Math.abs(arr[i]) > maxValue) {\n      maxValue = Math.abs(arr[i]);\n    }\n  }\n  if (maxValue !== 0) {\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] /= maxValue;\n    }\n  }\n  return arr;\n}\n","export function probability(prob: number){\n  return Math.random() < prob;\n}","import * as THREE from \"three\";\nimport Surface from \"../../objects/surface\";\nimport { probability } from '../../common/probability';\nimport { BandEnergy, Chain, RayPath, SELF_INTERSECTION_OFFSET } from \"./types\";\n\nconst { abs } = Math;\n\n// Pre-allocated scratch vectors to avoid per-ray allocations\nconst _negRd = new THREE.Vector3();\nconst _normalCopy = new THREE.Vector3();\nconst _normalScaled = new THREE.Vector3();\nconst _reflectedDir = new THREE.Vector3();\nconst _scatterCandidate = new THREE.Vector3();\nconst _offsetOrigin = new THREE.Vector3();\nconst _arrivalDir = new THREE.Vector3();\n\nconst _plane = new THREE.Plane();\nconst _pleq = new THREE.Vector4();\nconst _avec4 = new THREE.Vector4();\nconst _bvec4 = new THREE.Vector4();\nconst _cvec4 = new THREE.Vector4();\n\nexport function inFrontOf(a: THREE.Triangle, b: THREE.Triangle) {\n  a.getPlane(_plane);\n  _pleq.set(_plane.normal.x, _plane.normal.y, _plane.normal.z, _plane.constant);\n  _avec4.set(b.a.x, b.a.y, b.a.z, 1);\n  _bvec4.set(b.b.x, b.b.y, b.b.z, 1);\n  _cvec4.set(b.c.x, b.c.y, b.c.z, 1);\n  return _pleq.dot(_avec4) > 0 || _pleq.dot(_bvec4) > 0 || _pleq.dot(_cvec4) > 0;\n}\n\nexport function traceRay(\n  raycaster: THREE.Raycaster,\n  intersectableObjects: THREE.Object3D[],\n  frequencies: number[],\n  cachedAirAtt: number[],\n  rrThreshold: number,\n  ro: THREE.Vector3,\n  rd: THREE.Vector3,\n  order: number,\n  bandEnergy: BandEnergy,\n  source: string,\n  initialPhi: number,\n  initialTheta: number,\n  iter: number = 1,\n  chain: Partial<Chain>[] = [],\n): RayPath | undefined {\n  // normalize the ray\n  rd = rd.normalize();\n\n  // set the starting position\n  raycaster.ray.origin = ro;\n\n  // set the direction\n  raycaster.ray.direction = rd;\n\n  // find the surface that the ray intersects\n  const intersections = raycaster.intersectObjects(intersectableObjects, true);\n\n  // if there was an intersection\n  if (intersections.length > 0) {\n\n    // broadband average energy for scalar backward compat\n    const totalEnergy = bandEnergy.reduce((a, b) => a + b, 0);\n    const energy = bandEnergy.length > 0 ? totalEnergy / bandEnergy.length : 0;\n\n    //check to see if the intersection was with a receiver\n    if (intersections[0].object.userData?.kind === 'receiver') {\n      // find the incident angle\n      const angle = intersections[0].face && _negRd.copy(rd).multiplyScalar(-1).angleTo(intersections[0].face.normal);\n\n      // apply air absorption for the final segment to the receiver\n      const receiverSegmentDist = intersections[0].distance;\n      const receiverBandEnergy = bandEnergy.map((e, f) =>\n        e * Math.pow(10, -cachedAirAtt[f] * receiverSegmentDist / 10)\n      );\n\n      // broadband average energy for scalar backward compat (recompute after air absorption)\n      const receiverTotalEnergy = receiverBandEnergy.reduce((a, b) => a + b, 0);\n      const receiverEnergy = receiverBandEnergy.length > 0 ? receiverTotalEnergy / receiverBandEnergy.length : 0;\n\n      // push the intersection data onto the chain\n      chain.push({\n        object: intersections[0].object.parent!.uuid,\n        angle: angle!,\n        distance: intersections[0].distance,\n        faceNormal: [\n          intersections[0].face!.normal.x,\n          intersections[0].face!.normal.y,\n          intersections[0].face!.normal.z\n        ],\n        faceMaterialIndex: intersections[0].face!.materialIndex,\n        faceIndex: intersections[0].faceIndex!,\n        point: [intersections[0].point.x, intersections[0].point.y, intersections[0].point.z],\n        energy: receiverEnergy,\n        bandEnergy: [...receiverBandEnergy],\n      });\n\n      // Compute arrival direction (direction ray arrives FROM, normalized)\n      // This is the opposite of the ray direction (ray travels toward receiver)\n      _arrivalDir.copy(rd).normalize().negate();\n      const arrivalDirection: [number, number, number] = [_arrivalDir.x, _arrivalDir.y, _arrivalDir.z];\n\n      // end the chain here\n      return {\n        chain,\n        chainLength: chain.length,\n        intersectedReceiver: true,\n        energy: receiverEnergy,\n        bandEnergy: [...receiverBandEnergy],\n        source,\n        initialPhi,\n        initialTheta,\n        arrivalDirection,\n      } as RayPath;\n    } else {\n      // find the incident angle\n      const angle = intersections[0].face && _negRd.copy(rd).multiplyScalar(-1).angleTo(intersections[0].face.normal);\n\n      // push the intersection onto the chain\n      chain.push({\n        object: intersections[0].object.parent!.uuid,\n        angle: angle!,\n        distance: intersections[0].distance,\n        faceNormal: [\n          intersections[0].face!.normal.x,\n          intersections[0].face!.normal.y,\n          intersections[0].face!.normal.z\n        ],\n        faceMaterialIndex: intersections[0].face!.materialIndex,\n        faceIndex: intersections[0].faceIndex!,\n        point: [intersections[0].point.x, intersections[0].point.y, intersections[0].point.z],\n        energy,\n      });\n\n      if (intersections[0].object.parent instanceof Surface) {\n        intersections[0].object.parent.numHits += 1;\n      }\n\n      // get the normal direction of the intersection (copy to avoid mutating mesh data)\n      const normal = intersections[0].face && _normalCopy.copy(intersections[0].face.normal).normalize();\n\n      // find the reflected direction\n      let rr =\n        normal &&\n        intersections[0].face &&\n        _reflectedDir.copy(rd).sub(_normalScaled.copy(normal).multiplyScalar(rd.dot(normal)).multiplyScalar(2));\n\n      // compute energy-weighted broadband scattering for directional decision\n      const surface = intersections[0].object.parent as Surface;\n      const scatterCoeffs = frequencies.map(f => surface.scatteringFunction(f));\n      const totalEnergy = bandEnergy.reduce((a, b) => a + b, 0) || 1;\n      let broadbandScattering = 0;\n      for (let f = 0; f < frequencies.length; f++) {\n        broadbandScattering += scatterCoeffs[f] * (bandEnergy[f] || 0);\n      }\n      broadbandScattering /= totalEnergy;\n\n      if (probability(broadbandScattering)) {\n        // Cosine-weighted (Lambertian) hemisphere sampling via rejection method\n        do {\n          _scatterCandidate.set(\n            Math.random() * 2 - 1,\n            Math.random() * 2 - 1,\n            Math.random() * 2 - 1\n          );\n        } while (_scatterCandidate.lengthSq() > 1 || _scatterCandidate.lengthSq() < 1e-6);\n        _scatterCandidate.normalize();\n        // Offset along normal for cosine-weighted distribution\n        rr = _reflectedDir.copy(_scatterCandidate).add(normal!).normalize();\n      }\n\n      // apply per-band reflection loss\n      const segmentDistance = intersections[0].distance;\n      const newBandEnergy = frequencies.map((frequency, f) => {\n        const e = bandEnergy[f];\n        if (e == null) return 0;\n        // surface reflection\n        let energy = e * abs(surface.reflectionFunction(frequency, angle!));\n        // per-segment air absorption (intensity domain: /10)\n        energy *= Math.pow(10, -cachedAirAtt[f] * segmentDistance / 10);\n        return energy;\n      });\n\n      // Russian Roulette termination: unbiased probabilistic early termination\n      const maxEnergy = Math.max(...newBandEnergy);\n      if (rr && normal && iter < order + 1) {\n        if (maxEnergy < rrThreshold && maxEnergy > 0) {\n          const survivalProbability = maxEnergy / rrThreshold;\n          if (Math.random() > survivalProbability) {\n            // Terminate ray - expected value preserved (no bias)\n            const rrTotalEnergy = newBandEnergy.reduce((a, b) => a + b, 0);\n            const rrEnergy = newBandEnergy.length > 0 ? rrTotalEnergy / newBandEnergy.length : 0;\n            return { chain, chainLength: chain.length, source, intersectedReceiver: false, energy: rrEnergy, bandEnergy: [...newBandEnergy] } as RayPath;\n          }\n          // Boost surviving ray energy to compensate\n          for (let f = 0; f < newBandEnergy.length; f++) {\n            newBandEnergy[f] /= survivalProbability;\n          }\n        }\n        if (maxEnergy > 0) {\n          // recurse\n          return traceRay(\n            raycaster,\n            intersectableObjects,\n            frequencies,\n            cachedAirAtt,\n            rrThreshold,\n            _offsetOrigin.copy(intersections[0].point).addScaledVector(normal, SELF_INTERSECTION_OFFSET),\n            rr,\n            order,\n            newBandEnergy,\n            source,\n            initialPhi,\n            initialTheta,\n            iter + 1,\n            chain,\n          );\n        }\n      }\n    }\n    return { chain, chainLength: chain.length, source, intersectedReceiver: false } as RayPath;\n  }\n}\n","import * as ac from \"../acoustics\";\nimport Surface from \"../../objects/surface\";\nimport Receiver from \"../../objects/receiver\";\nimport { useContainer } from \"../../store\";\nimport { audioEngine } from \"../../audio-engine/audio-engine\";\nimport { RayPath, normalize, RESPONSE_TIME_PADDING, DEFAULT_INITIAL_SPL } from \"./types\";\nimport { extractDecayParameters, synthesizeTail, assembleFinalIR } from \"./tail-synthesis\";\n\nexport interface TailOptions {\n  energyHistogram: Float32Array[];\n  crossfadeTime: number;\n  crossfadeDuration: number;\n  histogramBinWidth: number;\n  frequencies: number[];\n}\n\nconst { floor, abs, max: mathMax } = Math;\nconst coinFlip = () => Math.random() > 0.5;\n\n// Webpack 5 native worker support\nconst FilterWorker = () => new Worker(new URL('../../audio-engine/filter.worker.ts', import.meta.url));\n\nexport function arrivalPressure(\n  initialSPL: number[],\n  freqs: number[],\n  path: RayPath,\n  receiverGain: number = 1.0,\n  temperature: number = 20,\n): number[] {\n  const intensities = ac.P2I(ac.Lp2P(initialSPL)) as number[];\n\n  if (path.bandEnergy && path.bandEnergy.length === freqs.length) {\n    // New path: per-band energy (including air absorption and source directivity) already tracked during tracing\n    for (let i = 0; i < freqs.length; i++) {\n      intensities[i] *= path.bandEnergy[i];\n    }\n    // convert back to pressure (no post-hoc air absorption needed), apply receiver directivity gain\n    const pressures = ac.Lp2P(ac.P2Lp(ac.I2P(intensities)) as number[]) as number[];\n    if (receiverGain !== 1.0) {\n      for (let i = 0; i < pressures.length; i++) pressures[i] *= receiverGain;\n    }\n    return pressures;\n  }\n\n  // Legacy path: re-walk chain (backward compat)\n  path.chain.slice(0, -1).forEach(p => {\n    const surface = useContainer.getState().containers[p.object] as Surface;\n    intensities.forEach((I, i) => {\n      const R = abs(surface.reflectionFunction(freqs[i], p.angle));\n      intensities[i] = I * R;\n    });\n  });\n\n  // convert back to SPL\n  const arrivalLp = ac.P2Lp(ac.I2P(intensities)) as number[];\n\n  // apply air absorption (dB/m) — only for legacy paths\n  const airAttenuationdB = ac.airAttenuation(freqs, temperature);\n  freqs.forEach((_, f) => arrivalLp[f] -= airAttenuationdB[f] * path.totalLength);\n\n  // convert back to pressure, apply receiver directivity gain\n  const pressures = ac.Lp2P(arrivalLp) as number[];\n  if (receiverGain !== 1.0) {\n    for (let i = 0; i < pressures.length; i++) pressures[i] *= receiverGain;\n  }\n  return pressures;\n}\n\nexport async function calculateImpulseResponseForPair(\n  sourceId: string,\n  receiverId: string,\n  paths: RayPath[],\n  initialSPL = DEFAULT_INITIAL_SPL,\n  frequencies: number[],\n  temperature: number,\n  sampleRate = audioEngine.sampleRate,\n  tailOptions?: TailOptions,\n): Promise<{ signal: Float32Array; normalizedSignal: Float32Array }> {\n  if (paths.length === 0) throw Error(\"No rays have been traced for this pair\");\n\n  let sorted = paths.sort((a, b) => a.time - b.time) as RayPath[];\n\n  const totalTime = sorted[sorted.length - 1].time + RESPONSE_TIME_PADDING;\n\n  const spls = Array(frequencies.length).fill(initialSPL);\n\n  const numberOfSamples = floor(sampleRate * totalTime) * 2;\n\n  let samples: Array<Float32Array> = [];\n  for (let f = 0; f < frequencies.length; f++) {\n    samples.push(new Float32Array(numberOfSamples));\n  }\n\n  // add in raytracer paths (apply receiver directivity)\n  const recForPair = useContainer.getState().containers[receiverId] as Receiver;\n  for (let i = 0; i < sorted.length; i++) {\n    const randomPhase = coinFlip() ? 1 : -1;\n    const t = sorted[i].time;\n    const dir = sorted[i].arrivalDirection || [0, 0, 1] as [number, number, number];\n    const recGain = recForPair.getGain(dir as [number, number, number]);\n    const p = arrivalPressure(spls, frequencies, sorted[i], recGain, temperature).map(x => x * randomPhase);\n    const roundedSample = floor(t * sampleRate);\n\n    for (let f = 0; f < frequencies.length; f++) {\n      samples[f][roundedSample] += p[f];\n    }\n  }\n\n  // Apply late reverberation tail synthesis if enabled\n  if (tailOptions && tailOptions.energyHistogram && tailOptions.energyHistogram.length > 0) {\n    const decayParams = extractDecayParameters(\n      tailOptions.energyHistogram, tailOptions.frequencies,\n      tailOptions.crossfadeTime, tailOptions.histogramBinWidth\n    );\n    const { tailSamples, tailStartSample } = synthesizeTail(\n      decayParams, sampleRate\n    );\n    const crossfadeDurationSamples = floor(tailOptions.crossfadeDuration * sampleRate);\n    samples = assembleFinalIR(samples, tailSamples, tailStartSample, crossfadeDurationSamples);\n\n    // Re-pad for FFT: ensure samples are doubled for the filter worker\n    const maxLen = samples.reduce((m, s) => mathMax(m, s.length), 0);\n    const paddedLength = maxLen * 2;\n    for (let f = 0; f < frequencies.length; f++) {\n      if (samples[f].length < paddedLength) {\n        const padded = new Float32Array(paddedLength);\n        padded.set(samples[f]);\n        samples[f] = padded;\n      }\n    }\n  }\n\n  const worker = FilterWorker();\n\n  return new Promise((resolve, reject) => {\n    worker.postMessage({ samples });\n    worker.onmessage = (event) => {\n      const filteredSamples = event.data.samples as Float32Array[];\n\n      const signal = new Float32Array(filteredSamples[0].length >> 1);\n\n      for (let i = 0; i < filteredSamples.length; i++) {\n        for (let j = 0; j < signal.length; j++) {\n          signal[j] += filteredSamples[i][j];\n        }\n      }\n\n      const normalizedSignal = normalize(signal.slice());\n\n      worker.terminate();\n      resolve({ signal, normalizedSignal });\n    };\n    worker.onerror = (error) => {\n      worker.terminate();\n      reject(error);\n    };\n  });\n}\n\nexport async function calculateImpulseResponseForDisplay(\n  receiverIDs: string[],\n  sourceIDs: string[],\n  paths: Record<string, RayPath[]>,\n  initialSPL = DEFAULT_INITIAL_SPL,\n  frequencies: number[],\n  temperature: number,\n  sampleRate = audioEngine.sampleRate,\n  tailOptions?: TailOptions,\n): Promise<{ signal: Float32Array; normalizedSignal: Float32Array }> {\n  if (receiverIDs.length == 0) throw Error(\"No receivers have been assigned to the raytracer\");\n  if (sourceIDs.length == 0) throw Error(\"No sources have been assigned to the raytracer\");\n  if (paths[receiverIDs[0]].length == 0) throw Error(\"No rays have been traced yet\");\n\n  let sorted = paths[receiverIDs[0]].sort((a, b) => a.time - b.time) as RayPath[];\n\n  const totalTime = sorted[sorted.length - 1].time + RESPONSE_TIME_PADDING;\n\n  const spls = Array(frequencies.length).fill(initialSPL);\n\n  const numberOfSamples = floor(sampleRate * totalTime) * 2;\n\n  let samples: Array<Float32Array> = [];\n  for (let f = 0; f < frequencies.length; f++) {\n    samples.push(new Float32Array(numberOfSamples));\n  }\n\n  // add in raytracer paths (apply receiver directivity)\n  const recForDisplay = useContainer.getState().containers[receiverIDs[0]] as Receiver;\n  for (let i = 0; i < sorted.length; i++) {\n    const randomPhase = coinFlip() ? 1 : -1;\n    const t = sorted[i].time;\n    const dir = sorted[i].arrivalDirection || [0, 0, 1] as [number, number, number];\n    const recGain = recForDisplay.getGain(dir as [number, number, number]);\n    const p = arrivalPressure(spls, frequencies, sorted[i], recGain, temperature).map(x => x * randomPhase);\n    const roundedSample = floor(t * sampleRate);\n\n    for (let f = 0; f < frequencies.length; f++) {\n      samples[f][roundedSample] += p[f];\n    }\n  }\n\n  // Apply late reverberation tail synthesis if enabled\n  if (tailOptions && tailOptions.energyHistogram && tailOptions.energyHistogram.length > 0) {\n    const decayParams = extractDecayParameters(\n      tailOptions.energyHistogram, tailOptions.frequencies,\n      tailOptions.crossfadeTime, tailOptions.histogramBinWidth\n    );\n    const { tailSamples, tailStartSample } = synthesizeTail(\n      decayParams, sampleRate\n    );\n    const crossfadeDurationSamples = floor(tailOptions.crossfadeDuration * sampleRate);\n    samples = assembleFinalIR(samples, tailSamples, tailStartSample, crossfadeDurationSamples);\n\n    // Re-pad for FFT\n    const maxLen = samples.reduce((m, s) => mathMax(m, s.length), 0);\n    const paddedLength = maxLen * 2;\n    for (let f = 0; f < frequencies.length; f++) {\n      if (samples[f].length < paddedLength) {\n        const padded = new Float32Array(paddedLength);\n        padded.set(samples[f]);\n        samples[f] = padded;\n      }\n    }\n  }\n\n  const worker = FilterWorker();\n\n  return new Promise((resolve, reject) => {\n    worker.postMessage({ samples });\n    worker.onmessage = (event) => {\n      const filteredSamples = event.data.samples as Float32Array[];\n\n      const signal = new Float32Array(filteredSamples[0].length >> 1);\n\n      for (let i = 0; i < filteredSamples.length; i++) {\n        for (let j = 0; j < signal.length; j++) {\n          signal[j] += filteredSamples[i][j];\n        }\n      }\n\n      const normalizedSignal = normalize(signal.slice());\n\n      worker.terminate();\n      resolve({ signal, normalizedSignal });\n    };\n    worker.onerror = (error) => {\n      worker.terminate();\n      reject(error);\n    };\n  });\n}\n","import * as ac from \"../acoustics\";\nimport Surface from \"../../objects/surface\";\nimport Source from \"../../objects/source\";\nimport Receiver from \"../../objects/receiver\";\nimport Room from \"../../objects/room\";\nimport { useContainer } from \"../../store\";\nimport { KVP } from \"../../common/key-value-pair\";\nimport {\n  RayPath, RayPathResult, ResponseByIntensity, ChartData, EnergyTime, ReceiverData,\n} from \"./types\";\n\n// Re-export shared functions\nexport { resampleResponseByIntensity, calculateT20, calculateT30, calculateT60 } from \"../shared/response-by-intensity\";\n\nimport { resampleResponseByIntensity } from \"../shared/response-by-intensity\";\n\nconst { abs } = Math;\n\nexport function reflectionLossFunction(room: Room, raypath: RayPath, frequency: number): number {\n  const chain = raypath.chain.slice(0, -1);\n  if (chain && chain.length > 0) {\n    let magnitude = 1;\n    for (let k = 0; k < chain.length; k++) {\n      const intersection = chain[k];\n      const surface = room.surfaceMap[intersection.object] as Surface;\n      const angle = intersection[\"angle\"] || 0;\n      magnitude = magnitude * abs(surface.reflectionFunction(frequency, angle));\n    }\n    return magnitude;\n  }\n  return 1;\n}\n\n//TODO change this name to something more appropriate\nexport function calculateReflectionLoss(\n  paths: KVP<RayPath[]>,\n  room: Room,\n  receiverIDs: string[],\n  frequencies: number[]\n): [ReceiverData[], ChartData[]] {\n  // reset the receiver data\n  const allReceiverData = [] as ReceiverData[];\n\n  // helper function\n  const dataset = (label: string, data: number[][]) => ({ label, data });\n\n  // for the chart\n  const chartdata = [] as ChartData[];\n  if (frequencies) {\n    for (let i = 0; i < frequencies.length; i++) {\n      chartdata.push(dataset(frequencies[i].toString(), []));\n    }\n  }\n\n  // pathkeys.length should equal the number of receivers in the scene\n  const pathkeys = Object.keys(paths);\n\n  // for each receiver's path in the total path array\n  for (let i = 0; i < pathkeys.length; i++) {\n    // init contribution array\n    allReceiverData.push({\n      id: pathkeys[i],\n      data: [] as EnergyTime[]\n    });\n\n    // for each path's chain of intersections\n    for (let j = 0; j < paths[pathkeys[i]].length; j++) {\n      // the individual ray path which holds intersection data\n      const raypath = paths[pathkeys[i]][j];\n\n      let refloss: any;\n      // if there was a given frequency array\n      if (frequencies) {\n        // map the frequencies to reflection loss\n        refloss = frequencies.map((freq) => ({\n          frequency: freq,\n          value: reflectionLossFunction(room, raypath, freq)\n        }));\n        frequencies.forEach((f, i) => {\n          chartdata[i].data.push([raypath.time!, reflectionLossFunction(room, raypath, f)]);\n        });\n      } else {\n        // if no frequencies given, just give back the function that calculates the reflection loss\n        refloss = (freq: number) => reflectionLossFunction(room, raypath, freq);\n      }\n      allReceiverData[allReceiverData.length - 1].data.push({\n        time: raypath.time!,\n        energy: refloss\n      });\n    }\n    allReceiverData[allReceiverData.length - 1].data = allReceiverData[\n      allReceiverData.length - 1\n    ].data.sort((a, b) => a.time - b.time);\n  }\n  for (let i = 0; i < chartdata.length; i++) {\n    chartdata[i].data = chartdata[i].data.sort((a, b) => a[0] - b[0]);\n    chartdata[i].x = chartdata[i].data.map((x) => x[0]);\n    chartdata[i].y = chartdata[i].data.map((x) => x[1]);\n  }\n  return [allReceiverData, chartdata];\n}\n\nexport function calculateResponseByIntensity(\n  indexedPaths: KVP<KVP<RayPath[]>>,\n  receiverIDs: string[],\n  sourceIDs: string[],\n  frequencies: number[],\n  temperature: number,\n  intensitySampleRate: number\n): KVP<KVP<ResponseByIntensity>> | undefined {\n  const paths = indexedPaths;\n\n  // sound speed in m/s\n  const soundSpeed = ac.soundSpeed(temperature);\n\n  // attenuation in dB/m\n  const airAttenuationdB = ac.airAttenuation(frequencies, temperature);\n\n  const responseByIntensity = {} as KVP<KVP<ResponseByIntensity>>;\n\n  // for each receiver\n  for (const receiverKey in paths) {\n    responseByIntensity[receiverKey] = {} as KVP<ResponseByIntensity>;\n    const recForIntensity = useContainer.getState().containers[receiverKey] as Receiver;\n\n    // for each source\n    for (const sourceKey in paths[receiverKey]) {\n      responseByIntensity[receiverKey][sourceKey] = {\n        freqs: frequencies,\n        response: [] as RayPathResult[]\n      };\n\n      // for each path\n      for (let i = 0; i < paths[receiverKey][sourceKey].length; i++) {\n\n        // propogagtion time\n        let time = 0;\n\n        // ray initial intensity\n        // const Iray = Itotal / (useContainer.getState().containers[sourceKey] as Source).numRays;\n\n        // initial intensity at each frequency\n        let IrayArray: number[] = [];\n        let phi = paths[receiverKey][sourceKey][i].initialPhi;\n        let theta = paths[receiverKey][sourceKey][i].initialTheta;\n\n        let srcDirectivityHandler = (useContainer.getState().containers[sourceKey] as Source).directivityHandler;\n\n        for(let findex = 0; findex<frequencies.length; findex++){\n          IrayArray[findex] = ac.P2I(srcDirectivityHandler.getPressureAtPosition(0,frequencies[findex],phi,theta)) as number;\n        }\n\n        // apply receiver directivity gain (intensity domain: gain²)\n        const pathObj = paths[receiverKey][sourceKey][i];\n        const dir = pathObj.arrivalDirection || [0, 0, 1] as [number, number, number];\n        const recGainIntensity = recForIntensity.getGain(dir as [number, number, number]);\n        const recGainSq = recGainIntensity * recGainIntensity;\n        if (recGainSq !== 1.0) {\n          for (let findex = 0; findex < frequencies.length; findex++) {\n            IrayArray[findex] *= recGainSq;\n          }\n        }\n\n        // for each intersection\n        for (let j = 0; j < paths[receiverKey][sourceKey][i].chain.length; j++) {\n          // intersected angle wrt normal, and the distance traveled\n          const { angle, distance } = paths[receiverKey][sourceKey][i].chain[j];\n\n          time += distance / soundSpeed;\n\n          // the intersected surface\n          // const surface = paths[receiverKey][sourceKey][i].chain[j].object.parent as Surface;\n          const id = paths[receiverKey][sourceKey][i].chain[j].object;\n\n          const surface = useContainer.getState().containers[id] || null;\n\n          // for each frequency\n          for (let f = 0; f < frequencies.length; f++) {\n            const freq = frequencies[f];\n            let coefficient = 1;\n            if (surface && surface.kind === 'surface') {\n              coefficient = (surface as Surface).reflectionFunction(freq, angle);\n              // coefficient = 1 - (surface as Surface).absorptionFunction(freq);\n            }\n            IrayArray[f] = ac.P2I(\n              ac.Lp2P((ac.P2Lp(ac.I2P(IrayArray[f] * coefficient)) as number) - airAttenuationdB[f] * distance)\n            ) as number;\n          }\n        }\n        const level = ac.P2Lp(ac.I2P(IrayArray)) as number[];\n        responseByIntensity[receiverKey][sourceKey].response.push({\n          time,\n          level,\n          bounces: paths[receiverKey][sourceKey][i].chain.length\n        });\n      }\n      responseByIntensity[receiverKey][sourceKey].response.sort((a, b) => a.time - b.time);\n    }\n  }\n\n  return resampleResponseByIntensity(responseByIntensity, intensitySampleRate);\n}\n\n","import { KVP } from \"../../common/key-value-pair\";\nimport { RayPath, Chain } from \"./types\";\n\n// ── V2 magic number for format detection ─────────────────────────────\nconst V2_MAGIC = -2.0;\n\n// ── V1 format (legacy, kept for backward compatibility) ──────────────\n\nfunction pathsToLinearBufferV1(paths: KVP<RayPath[]>): Float32Array {\n  const uuidToLinearBuffer = (uuid: string) => uuid.split(\"\").map((x: string) => x.charCodeAt(0));\n  const chainArrayToLinearBuffer = (chainArray: Chain[]) => {\n    return chainArray\n      .map((chain: Chain) => [\n        ...uuidToLinearBuffer(chain.object), // 36x8\n        chain.angle, // 1x32\n        chain.distance, // 1x32\n        chain.energy, // 1x32\n        chain.faceIndex, // 1x8\n        chain.faceMaterialIndex, // 1x8\n        ...chain.faceNormal, // 3x32\n        ...chain.point // 3x32\n      ])\n      .flat();\n  };\n  const buffer = new Float32Array(\n    Object.keys(paths)\n      .map((key) => {\n        const pathBuffer = paths[key]\n          .map((path) => {\n            return [\n              ...uuidToLinearBuffer(path.source),\n              path.chainLength,\n              path.time,\n              Number(path.intersectedReceiver),\n              path.energy,\n              ...chainArrayToLinearBuffer(path.chain)\n            ];\n          })\n          .flat();\n        return [...uuidToLinearBuffer(key), pathBuffer.length, ...pathBuffer];\n      })\n      .flat()\n  );\n  return buffer;\n}\n\nfunction linearBufferToPathsV1(linearBuffer: Float32Array): KVP<RayPath[]> {\n  const uuidLength = 36;\n  const chainItemLength = 47;\n  const decodeUUID = (buffer: Float32Array) => String.fromCharCode(...buffer);\n  const decodeChainItem = (chainItem: Float32Array) => {\n    let o = 0;\n    const object = decodeUUID(chainItem.slice(o, (o += uuidLength)));\n    const angle = chainItem[o++];\n    const distance = chainItem[o++];\n    const energy = chainItem[o++];\n    const faceIndex = chainItem[o++];\n    const faceMaterialIndex = chainItem[o++];\n    const faceNormal = [chainItem[o++], chainItem[o++], chainItem[o++]];\n    const point = [chainItem[o++], chainItem[o++], chainItem[o++]];\n    return {\n      object,\n      angle,\n      distance,\n      energy,\n      faceIndex,\n      faceMaterialIndex,\n      faceNormal,\n      point\n    } as Chain;\n  };\n  const decodePathBuffer = (buffer: Float32Array) => {\n    const paths = [] as RayPath[];\n    let o = 0;\n    while (o < buffer.length) {\n      const source = decodeUUID(buffer.slice(o, (o += uuidLength)));\n      const chainLength = buffer[o++];\n      const time = buffer[o++];\n      const intersectedReceiver = Boolean(buffer[o++]);\n      const energy = buffer[o++];\n      const chain = [] as Chain[];\n      for (let i = 0; i < chainLength; i++) {\n        chain.push(decodeChainItem(buffer.slice(o, (o += chainItemLength))));\n      }\n      paths.push({\n        source,\n        chainLength,\n        time,\n        intersectedReceiver,\n        energy,\n        chain\n      } as RayPath);\n    }\n    return paths as RayPath[];\n  };\n  let offset = 0;\n  const pathsObj = {} as KVP<RayPath[]>;\n  while (offset < linearBuffer.length) {\n    const uuid = decodeUUID(linearBuffer.slice(offset, (offset += uuidLength)));\n    const pathBufferLength = linearBuffer[offset++];\n    const paths = decodePathBuffer(linearBuffer.slice(offset, (offset += pathBufferLength)));\n    pathsObj[uuid] = paths;\n  }\n  return pathsObj;\n}\n\n// ── V2 format (compact binary with UUID lookup table) ────────────────\n//\n// Layout:\n//   [MAGIC=-2.0] [numUUIDs]\n//   [uuid0_c0..uuid0_c35] [uuid1_c0..uuid1_c35] ...   (lookup table)\n//   [receiverIdx] [pathBufLen]\n//     [sourceIdx] [chainLen] [time] [isReceiver] [energy]\n//       [objectIdx] [angle] [dist] [energy] [faceIdx] [matIdx] [nx] [ny] [nz] [px] [py] [pz]\n//     ...\n//   ...\n//\n// Per chain entry: 12 floats (vs 47 in V1). ~75% reduction.\n\nfunction pathsToLinearBufferV2(paths: KVP<RayPath[]>): Float32Array {\n  // Build UUID lookup table\n  const uuidSet = new Set<string>();\n  for (const key of Object.keys(paths)) {\n    uuidSet.add(key);\n    for (const path of paths[key]) {\n      uuidSet.add(path.source);\n      for (const chain of path.chain) {\n        uuidSet.add(chain.object);\n      }\n    }\n  }\n  const uuidList = Array.from(uuidSet);\n  const uuidToIndex = new Map<string, number>();\n  for (let i = 0; i < uuidList.length; i++) {\n    uuidToIndex.set(uuidList[i], i);\n  }\n\n  // Pre-calculate total size\n  const uuidTableSize = 2 + uuidList.length * 36; // magic + numUUIDs + all UUID chars\n  let dataSize = 0;\n  for (const key of Object.keys(paths)) {\n    // receiverIdx + pathBufLen\n    dataSize += 2;\n    for (const path of paths[key]) {\n      // sourceIdx + chainLen + time + isReceiver + energy\n      dataSize += 5;\n      // 12 floats per chain entry\n      dataSize += path.chain.length * 12;\n    }\n  }\n\n  const buffer = new Float32Array(uuidTableSize + dataSize);\n  let o = 0;\n\n  // Write header\n  buffer[o++] = V2_MAGIC;\n  buffer[o++] = uuidList.length;\n\n  // Write UUID lookup table\n  for (const uuid of uuidList) {\n    for (let c = 0; c < 36; c++) {\n      buffer[o++] = uuid.charCodeAt(c);\n    }\n  }\n\n  // Write path data\n  for (const key of Object.keys(paths)) {\n    buffer[o++] = uuidToIndex.get(key)!;\n\n    // Calculate path buffer length for this receiver\n    let pathBufLen = 0;\n    for (const path of paths[key]) {\n      pathBufLen += 5 + path.chain.length * 12;\n    }\n    buffer[o++] = pathBufLen;\n\n    for (const path of paths[key]) {\n      buffer[o++] = uuidToIndex.get(path.source)!;\n      buffer[o++] = path.chain.length;\n      buffer[o++] = path.time;\n      buffer[o++] = Number(path.intersectedReceiver);\n      buffer[o++] = path.energy;\n\n      for (const chain of path.chain) {\n        buffer[o++] = uuidToIndex.get(chain.object)!;\n        buffer[o++] = chain.angle;\n        buffer[o++] = chain.distance;\n        buffer[o++] = chain.energy;\n        buffer[o++] = chain.faceIndex;\n        buffer[o++] = chain.faceMaterialIndex;\n        buffer[o++] = chain.faceNormal[0];\n        buffer[o++] = chain.faceNormal[1];\n        buffer[o++] = chain.faceNormal[2];\n        buffer[o++] = chain.point[0];\n        buffer[o++] = chain.point[1];\n        buffer[o++] = chain.point[2];\n      }\n    }\n  }\n\n  return buffer;\n}\n\nfunction linearBufferToPathsV2(linearBuffer: Float32Array): KVP<RayPath[]> {\n  let o = 0;\n\n  // Read header\n  o++; // skip magic\n  const numUUIDs = linearBuffer[o++];\n\n  // Validate header\n  if (!Number.isFinite(numUUIDs) || numUUIDs < 0 || numUUIDs !== (numUUIDs | 0)) {\n    throw new Error('Invalid V2 buffer: bad numUUIDs');\n  }\n  if (o + numUUIDs * 36 > linearBuffer.length) {\n    throw new Error('Invalid V2 buffer: UUID table exceeds buffer length');\n  }\n\n  // Read UUID lookup table\n  const uuidList: string[] = [];\n  for (let i = 0; i < numUUIDs; i++) {\n    const chars: number[] = [];\n    for (let c = 0; c < 36; c++) {\n      chars.push(linearBuffer[o++]);\n    }\n    uuidList.push(String.fromCharCode(...chars));\n  }\n\n  // Read path data\n  const pathsObj = {} as KVP<RayPath[]>;\n  while (o < linearBuffer.length) {\n    const receiverIdx = linearBuffer[o++];\n    if (receiverIdx < 0 || receiverIdx >= uuidList.length) {\n      throw new Error('Invalid V2 buffer: receiver index out of range');\n    }\n    const receiverUuid = uuidList[receiverIdx];\n    const pathBufLen = linearBuffer[o++];\n    if (!Number.isFinite(pathBufLen) || pathBufLen < 0) {\n      throw new Error('Invalid V2 buffer: bad pathBufLen');\n    }\n    const endOffset = Math.min(o + pathBufLen, linearBuffer.length);\n\n    const paths = [] as RayPath[];\n    while (o < endOffset) {\n      const source = uuidList[linearBuffer[o++]];\n      const chainLength = linearBuffer[o++];\n      const time = linearBuffer[o++];\n      const intersectedReceiver = Boolean(linearBuffer[o++]);\n      const energy = linearBuffer[o++];\n\n      const chain = [] as Chain[];\n      for (let i = 0; i < chainLength; i++) {\n        const object = uuidList[linearBuffer[o++]];\n        const angle = linearBuffer[o++];\n        const distance = linearBuffer[o++];\n        const chainEnergy = linearBuffer[o++];\n        const faceIndex = linearBuffer[o++];\n        const faceMaterialIndex = linearBuffer[o++];\n        const faceNormal: [number, number, number] = [linearBuffer[o++], linearBuffer[o++], linearBuffer[o++]];\n        const point: [number, number, number] = [linearBuffer[o++], linearBuffer[o++], linearBuffer[o++]];\n        chain.push({\n          object,\n          angle,\n          distance,\n          energy: chainEnergy,\n          faceIndex,\n          faceMaterialIndex,\n          faceNormal,\n          point,\n        } as Chain);\n      }\n\n      paths.push({\n        source,\n        chainLength,\n        time,\n        intersectedReceiver,\n        energy,\n        chain,\n      } as RayPath);\n    }\n\n    pathsObj[receiverUuid] = paths;\n  }\n\n  return pathsObj;\n}\n\n// ── Public API with auto-detection ───────────────────────────────────\n\nexport function pathsToLinearBuffer(paths: KVP<RayPath[]>): Float32Array {\n  return pathsToLinearBufferV2(paths);\n}\n\nexport function linearBufferToPaths(linearBuffer: Float32Array): KVP<RayPath[]> {\n  if (linearBuffer.length === 0) return {} as KVP<RayPath[]>;\n\n  // V1 detection: first byte is a UUID charCode (48-122); V2: first byte is -2.0\n  if (linearBuffer[0] === V2_MAGIC) {\n    return linearBufferToPathsV2(linearBuffer);\n  }\n  return linearBufferToPathsV1(linearBuffer);\n}\n\n// Expose V1 for backward-compat testing\nexport { pathsToLinearBufferV1, linearBufferToPathsV1 };\n","import * as ac from \"../acoustics\";\nimport { useContainer } from \"../../store\";\nimport Receiver from \"../../objects/receiver\";\nimport FileSaver from \"file-saver\";\nimport { KVP } from \"../../common/key-value-pair\";\nimport { RayPath, DEFAULT_INITIAL_SPL, RESPONSE_TIME_PADDING } from \"./types\";\nimport {\n  playImpulseResponse as sharedPlayIR,\n  downloadImpulseResponse as sharedDownloadIR,\n  downloadAmbisonicImpulseResponse as sharedDownloadAmbisonicIR,\n  playBinauralImpulseResponse as sharedPlayBinauralIR,\n  downloadBinauralImpulseResponse as sharedDownloadBinauralIR,\n} from \"../shared/export-playback\";\n\nconst { floor, abs } = Math;\nconst coinFlip = () => Math.random() > 0.5;\n\nconst RAYTRACER_EVENT = \"RAYTRACER_SET_PROPERTY\";\n\n/**\n * Download per-octave impulse responses as individual WAV files.\n * (Raytracer-specific: uses RayPath structure)\n */\nexport function downloadImpulses(\n  paths: KVP<RayPath[]>,\n  receiverIDs: string[],\n  sourceIDs: string[],\n  arrivalPressureFn: (spls: number[], freqs: number[], path: RayPath, receiverGain: number) => number[],\n  filename: string,\n  initialSPL: number = DEFAULT_INITIAL_SPL,\n  frequencies: number[] = ac.Octave(125, 8000),\n  sampleRate: number = 44100\n) {\n  if(receiverIDs.length === 0) throw Error(\"No receivers have been assigned to the raytracer\");\n  if(sourceIDs.length === 0) throw Error(\"No sources have been assigned to the raytracer\");\n  if(paths[receiverIDs[0]].length === 0) throw Error(\"No rays have been traced yet\");\n\n  const sorted = paths[receiverIDs[0]].sort((a,b)=>a.time - b.time) as RayPath[];\n  const totalTime = sorted[sorted.length - 1].time + RESPONSE_TIME_PADDING;\n\n  const spls = Array(frequencies.length).fill(initialSPL);\n  const numberOfSamples = floor(sampleRate * totalTime);\n\n  const samples: Array<Float32Array> = [];\n  for(let f = 0; f<frequencies.length; f++){\n    samples.push(new Float32Array(numberOfSamples));\n  }\n  let max = 0;\n  const recForDownload = useContainer.getState().containers[receiverIDs[0]] as Receiver;\n  for(let i = 0; i<sorted.length; i++){\n    const randomPhase = coinFlip() ? 1 : -1;\n    const t = sorted[i].time;\n    const dir = sorted[i].arrivalDirection || [0, 0, 1] as [number, number, number];\n    const recGain = recForDownload.getGain(dir as [number, number, number]);\n    const p = arrivalPressureFn(spls, frequencies, sorted[i], recGain).map(x => x * randomPhase);\n    const roundedSample = floor(t * sampleRate);\n\n    for(let f = 0; f<frequencies.length; f++){\n      samples[f][roundedSample] += p[f];\n      if(abs(samples[f][roundedSample]) > max){\n        max = abs(samples[f][roundedSample]);\n      }\n    }\n  }\n\n  for(let f = 0; f<frequencies.length; f++){\n    const blob = ac.wavAsBlob([ac.normalize(samples[f])], { sampleRate, bitDepth: 32 });\n    FileSaver.saveAs(blob, `${frequencies[f]}_${filename}.wav`);\n  }\n}\n\n// Re-export shared functions with RAYTRACER_SET_PROPERTY event name bound\n\nexport async function playImpulseResponse(\n  impulseResponse: AudioBuffer | undefined,\n  calculateImpulseResponse: () => Promise<AudioBuffer>,\n  uuid: string\n): Promise<{ impulseResponse: AudioBuffer }> {\n  return sharedPlayIR(impulseResponse, calculateImpulseResponse, uuid, RAYTRACER_EVENT);\n}\n\nexport async function downloadImpulseResponse(\n  impulseResponse: AudioBuffer | undefined,\n  calculateImpulseResponse: () => Promise<AudioBuffer>,\n  filename: string,\n  sampleRate?: number\n): Promise<{ impulseResponse: AudioBuffer }> {\n  return sharedDownloadIR(impulseResponse, calculateImpulseResponse, filename, sampleRate);\n}\n\nexport async function downloadAmbisonicImpulseResponse(\n  ambisonicImpulseResponse: AudioBuffer | undefined,\n  calculateAmbisonicImpulseResponse: (order: number) => Promise<AudioBuffer>,\n  ambisonicOrder: number,\n  order: number = 1,\n  filename: string\n): Promise<{ ambisonicImpulseResponse: AudioBuffer; ambisonicOrder: number }> {\n  return sharedDownloadAmbisonicIR(ambisonicImpulseResponse, calculateAmbisonicImpulseResponse, ambisonicOrder, order, filename);\n}\n\nexport async function playBinauralImpulseResponse(\n  binauralImpulseResponse: AudioBuffer | undefined,\n  calculateBinauralImpulseResponse: () => Promise<AudioBuffer>,\n  uuid: string\n): Promise<{ binauralImpulseResponse: AudioBuffer }> {\n  return sharedPlayBinauralIR(binauralImpulseResponse, calculateBinauralImpulseResponse, uuid, RAYTRACER_EVENT);\n}\n\nexport async function downloadBinauralImpulseResponse(\n  binauralImpulseResponse: AudioBuffer | undefined,\n  calculateBinauralImpulseResponse: () => Promise<AudioBuffer>,\n  filename: string\n): Promise<{ binauralImpulseResponse: AudioBuffer }> {\n  return sharedDownloadBinauralIR(binauralImpulseResponse, calculateBinauralImpulseResponse, filename);\n}\n","import linearRegression from \"../../common/linear-regression\";\nimport { emit } from \"../../messenger\";\nimport { KVP } from \"../../common/key-value-pair\";\nimport { RayPath, ConvergenceMetrics } from \"./types\";\n\n/**\n * Reset convergence state for a new simulation run.\n *\n * @param numFrequencies - Number of frequency bands\n * @returns An object containing the fresh convergenceMetrics and energyHistogram\n */\nexport function resetConvergenceState(numFrequencies: number): {\n  convergenceMetrics: ConvergenceMetrics;\n  energyHistogram: KVP<Float32Array[]>;\n  lastConvergenceCheck: number;\n} {\n  const convergenceMetrics: ConvergenceMetrics = {\n    totalRays: 0,\n    validRays: 0,\n    estimatedT30: new Array(numFrequencies).fill(0),\n    t30Mean: new Array(numFrequencies).fill(0),\n    t30M2: new Array(numFrequencies).fill(0),\n    t30Count: 0,\n    convergenceRatio: Infinity,\n  };\n  const energyHistogram = {} as KVP<Float32Array[]>;\n  const lastConvergenceCheck = Date.now();\n  return { convergenceMetrics, energyHistogram, lastConvergenceCheck };\n}\n\n/**\n * Compute T30 from Schroeder backward integration of the energy histogram\n * and update convergence metrics using Welford's online algorithm.\n *\n * @param convergenceMetrics - The current convergence metrics (mutated in place)\n * @param energyHistogram - The energy histogram keyed by receiver ID\n * @param frequencies - Frequency bands array\n * @param receiverIDs - Ordered array of receiver IDs\n * @param numCheckedPaths - Total number of checked paths\n * @param validRayCount - Total number of valid rays\n * @param histogramBinWidth - Width of each histogram bin in seconds\n * @param histogramNumBins - Total number of histogram bins\n * @param uuid - Solver UUID for emitting property updates\n */\nexport function updateConvergenceMetrics(\n  convergenceMetrics: ConvergenceMetrics,\n  energyHistogram: KVP<Float32Array[]>,\n  frequencies: number[],\n  receiverIDs: string[],\n  numCheckedPaths: number,\n  validRayCount: number,\n  histogramBinWidth: number,\n  histogramNumBins: number,\n  uuid: string\n): void {\n  convergenceMetrics.totalRays = numCheckedPaths;\n  convergenceMetrics.validRays = validRayCount;\n\n  // Choose a stable receiver with data for convergence metrics\n  const receiverIdsWithData = Object.keys(energyHistogram);\n  if (receiverIdsWithData.length === 0) return;\n\n  let receiverId: string | undefined;\n\n  // Prefer stable ordering via receiverIDs\n  if (receiverIDs.length > 0) {\n    for (const id of receiverIDs) {\n      const hist = energyHistogram[id];\n      if (hist && hist.length > 0) {\n        receiverId = id;\n        break;\n      }\n    }\n  }\n\n  // Fallback: lexicographically smallest ID with data\n  if (!receiverId) {\n    const sortedIds = receiverIdsWithData.slice().sort();\n    for (const id of sortedIds) {\n      const hist = energyHistogram[id];\n      if (hist && hist.length > 0) {\n        receiverId = id;\n        break;\n      }\n    }\n  }\n\n  if (!receiverId) return;\n\n  const histograms = energyHistogram[receiverId];\n  if (!histograms || histograms.length === 0) return;\n\n  const numBands = frequencies.length;\n  const t30Estimates = new Array(numBands).fill(0);\n\n  for (let f = 0; f < numBands; f++) {\n    const histogram = histograms[f];\n\n    // Find last non-zero bin\n    let lastBin = 0;\n    for (let b = histogramNumBins - 1; b >= 0; b--) {\n      if (histogram[b] > 0) { lastBin = b; break; }\n    }\n    if (lastBin < 2) { t30Estimates[f] = 0; continue; }\n\n    // Schroeder backward integration\n    const schroeder = new Float32Array(lastBin + 1);\n    schroeder[lastBin] = histogram[lastBin];\n    for (let b = lastBin - 1; b >= 0; b--) {\n      schroeder[b] = schroeder[b + 1] + histogram[b];\n    }\n\n    // Convert to dB (relative to max)\n    const maxVal = schroeder[0];\n    if (maxVal <= 0) { t30Estimates[f] = 0; continue; }\n\n    // Find -5dB and -35dB points for T30 estimation\n    const db5 = maxVal * Math.pow(10, -5 / 10);\n    const db35 = maxVal * Math.pow(10, -35 / 10);\n    let idx5 = -1, idx35 = -1;\n\n    for (let b = 0; b <= lastBin; b++) {\n      if (idx5 < 0 && schroeder[b] <= db5) idx5 = b;\n      if (idx35 < 0 && schroeder[b] <= db35) idx35 = b;\n    }\n\n    if (idx5 >= 0 && idx35 > idx5) {\n      // Linear regression in log domain between -5dB and -35dB\n      const times: number[] = [];\n      const levelsDb: number[] = [];\n\n      for (let b = idx5; b <= idx35; b++) {\n        const value = schroeder[b];\n        if (value > 0) {\n          times.push(b * histogramBinWidth);\n          levelsDb.push(10 * Math.log10(value / maxVal));\n        }\n      }\n\n      if (times.length >= 2) {\n        const regression = linearRegression(times, levelsDb);\n        const slope = regression.m;\n        // T60: time for 60 dB decay, extrapolated from decay slope in dB/s\n        t30Estimates[f] = slope < 0 ? 60 / -slope : 0;\n      }\n    }\n  }\n\n  convergenceMetrics.estimatedT30 = t30Estimates;\n\n  // Welford's online algorithm for running mean and variance\n  convergenceMetrics.t30Count += 1;\n  const n = convergenceMetrics.t30Count;\n\n  let maxRatio = 0;\n  let validBandCount = 0;\n  for (let f = 0; f < numBands; f++) {\n    const val = t30Estimates[f];\n    const oldMean = convergenceMetrics.t30Mean[f];\n    const newMean = oldMean + (val - oldMean) / n;\n    const oldM2 = convergenceMetrics.t30M2[f];\n    const newM2 = oldM2 + (val - oldMean) * (val - newMean);\n    convergenceMetrics.t30Mean[f] = newMean;\n    convergenceMetrics.t30M2[f] = newM2;\n\n    // Coefficient of variation: std / mean (skip bands with no valid T30)\n    if (n >= 2 && newMean > 0) {\n      const variance = newM2 / (n - 1);\n      const ratio = Math.sqrt(variance) / newMean;\n      if (ratio > maxRatio) maxRatio = ratio;\n      validBandCount++;\n    }\n    // Bands with zero/invalid T30 are excluded from convergence check\n  }\n  // Only report convergence if at least one band has a valid estimate\n  convergenceMetrics.convergenceRatio = validBandCount > 0 ? maxRatio : Infinity;\n\n  // Emit update so UI can display metrics\n  emit(\"RAYTRACER_SET_PROPERTY\", {\n    uuid: uuid,\n    property: \"convergenceMetrics\",\n    value: { ...convergenceMetrics }\n  });\n}\n\n/**\n * Add a ray path's energy to the convergence histogram.\n *\n * @param energyHistogram - The energy histogram (mutated in place)\n * @param receiverId - The receiver UUID\n * @param path - The ray path to add\n * @param frequencies - Frequency bands array\n * @param soundSpeed - Speed of sound in m/s\n * @param histogramBinWidth - Width of each histogram bin in seconds\n * @param histogramNumBins - Total number of histogram bins\n */\nexport function addToEnergyHistogram(\n  energyHistogram: KVP<Float32Array[]>,\n  receiverId: string,\n  path: RayPath,\n  frequencies: number[],\n  soundSpeed: number,\n  histogramBinWidth: number,\n  histogramNumBins: number\n): void {\n  if (!energyHistogram[receiverId]) {\n    energyHistogram[receiverId] = [];\n    for (let f = 0; f < frequencies.length; f++) {\n      energyHistogram[receiverId].push(new Float32Array(histogramNumBins));\n    }\n  }\n  // Compute total time from chain distances\n  let totalTime = 0;\n  for (let k = 0; k < path.chain.length; k++) {\n    totalTime += path.chain[k].distance;\n  }\n  totalTime /= soundSpeed;\n  const bin = Math.floor(totalTime / histogramBinWidth);\n  if (bin >= 0 && bin < histogramNumBins && path.bandEnergy) {\n    for (let f = 0; f < frequencies.length; f++) {\n      energyHistogram[receiverId][f][bin] += path.bandEnergy[f] || 0;\n    }\n  }\n}\n","/**\n * Merges all surface geometries into flat GPU-friendly typed-array buffers and\n * builds a linearised BVH suitable for iterative traversal in WGSL.\n */\nimport * as THREE from 'three';\nimport Room from '../../../objects/room';\nimport Surface from '../../../objects/surface';\nimport Receiver from '../../../objects/receiver';\nimport { useContainer } from '../../../store';\n\n// ── Types ────────────────────────────────────────────────────────────\n\nexport interface GpuSceneBuffers {\n  /** Linearised BVH nodes — 8 floats each (see flattenBvh). */\n  bvhNodes: Float32Array;\n  /** Triangle vertices — 9 floats per triangle (3 verts × xyz). */\n  triangleVertices: Float32Array;\n  /** Maps triangle index → surface index. */\n  triangleSurfaceIndex: Uint32Array;\n  /** Per-triangle face normal (3 floats). */\n  triangleNormals: Float32Array;\n  /**\n   * Per-surface acoustic data at each frequency band.\n   * Layout: surfaceCount × numFreqs × 2 (absorption, scattering).\n   */\n  surfaceAcousticData: Float32Array;\n  /** Receiver spheres — 4 floats each (x, y, z, radius). */\n  receiverSpheres: Float32Array;\n  triangleCount: number;\n  nodeCount: number;\n  surfaceCount: number;\n  receiverCount: number;\n  /** surface index → surface UUID */\n  surfaceUuidMap: string[];\n  /** receiver index → receiver UUID */\n  receiverUuidMap: string[];\n}\n\n// ── Internal BVH node (tree form, then linearised) ───────────────────\n\ninterface BvhNode {\n  boundsMin: [number, number, number];\n  boundsMax: [number, number, number];\n  // Leaf: triStart/triCount; Internal: left/right child index after flattening\n  left: BvhNode | null;\n  right: BvhNode | null;\n  triStart: number;\n  triCount: number;\n}\n\n// ── Public API ───────────────────────────────────────────────────────\n\n/**\n * Build all GPU buffers for the given room geometry.\n *\n * @param room         The Room object containing surfaces.\n * @param receiverIDs  UUIDs of receivers that should be checked for intersection.\n * @param frequencies  Octave-band center frequencies.\n */\nexport function buildGpuSceneBuffers(\n  room: Room,\n  receiverIDs: string[],\n  frequencies: number[],\n): GpuSceneBuffers {\n  const surfaces = room.allSurfaces as Surface[];\n  const containers = useContainer.getState().containers;\n\n  // ── 1. Merge triangles from all surfaces ────────────────────────\n\n  const surfaceUuidMap: string[] = [];\n  const allVerts: number[] = [];\n  const allNormals: number[] = [];\n  const allSurfIdx: number[] = [];\n\n  for (let si = 0; si < surfaces.length; si++) {\n    const surface = surfaces[si];\n    surfaceUuidMap.push(surface.uuid);\n\n    const mesh = surface.mesh;\n    const geo = mesh.geometry;\n    const posAttr = geo.getAttribute('position') as THREE.BufferAttribute;\n    const indexAttr = geo.getIndex();\n\n    // Ensure matrixWorld is up to date\n    mesh.updateMatrixWorld(true);\n    const mat = mesh.matrixWorld;\n\n    if (indexAttr) {\n      // Indexed geometry\n      for (let i = 0; i < indexAttr.count; i += 3) {\n        for (let v = 0; v < 3; v++) {\n          const idx = indexAttr.getX(i + v);\n          const vert = new THREE.Vector3(\n            posAttr.getX(idx), posAttr.getY(idx), posAttr.getZ(idx)\n          ).applyMatrix4(mat);\n          allVerts.push(vert.x, vert.y, vert.z);\n        }\n        // Compute face normal from the 3 world-space vertices\n        const base = allVerts.length - 9;\n        const n = computeFaceNormal(\n          allVerts[base], allVerts[base + 1], allVerts[base + 2],\n          allVerts[base + 3], allVerts[base + 4], allVerts[base + 5],\n          allVerts[base + 6], allVerts[base + 7], allVerts[base + 8],\n        );\n        allNormals.push(n[0], n[1], n[2]);\n        allSurfIdx.push(si);\n      }\n    } else {\n      // Non-indexed geometry\n      for (let i = 0; i < posAttr.count; i += 3) {\n        for (let v = 0; v < 3; v++) {\n          const vert = new THREE.Vector3(\n            posAttr.getX(i + v), posAttr.getY(i + v), posAttr.getZ(i + v)\n          ).applyMatrix4(mat);\n          allVerts.push(vert.x, vert.y, vert.z);\n        }\n        const base = allVerts.length - 9;\n        const n = computeFaceNormal(\n          allVerts[base], allVerts[base + 1], allVerts[base + 2],\n          allVerts[base + 3], allVerts[base + 4], allVerts[base + 5],\n          allVerts[base + 6], allVerts[base + 7], allVerts[base + 8],\n        );\n        allNormals.push(n[0], n[1], n[2]);\n        allSurfIdx.push(si);\n      }\n    }\n  }\n\n  const triangleCount = allSurfIdx.length;\n  const triangleVertices = new Float32Array(allVerts);\n  const triangleNormals = new Float32Array(allNormals);\n  const triangleSurfaceIndex = new Uint32Array(allSurfIdx);\n\n  // ── 2. Build BVH ──────────────────────────────────────────────────\n\n  // Centroid array for SAH-like median split\n  const centroids = new Float32Array(triangleCount * 3);\n  for (let t = 0; t < triangleCount; t++) {\n    const b = t * 9;\n    centroids[t * 3] = (triangleVertices[b] + triangleVertices[b + 3] + triangleVertices[b + 6]) / 3;\n    centroids[t * 3 + 1] = (triangleVertices[b + 1] + triangleVertices[b + 4] + triangleVertices[b + 7]) / 3;\n    centroids[t * 3 + 2] = (triangleVertices[b + 2] + triangleVertices[b + 5] + triangleVertices[b + 8]) / 3;\n  }\n\n  // Indices array — we reorder this but keep original buffers; the BVH\n  // references triangles via these indices which map to the *original* arrays.\n  const indices = new Uint32Array(triangleCount);\n  for (let i = 0; i < triangleCount; i++) indices[i] = i;\n\n  const root = buildBvhNode(triangleVertices, centroids, indices, 0, triangleCount, 0);\n\n  // After building the BVH, reorder the triangle data according to the index\n  // ordering so that leaves reference contiguous spans in the arrays.\n  const reorderedVerts = new Float32Array(triangleCount * 9);\n  const reorderedNormals = new Float32Array(triangleCount * 3);\n  const reorderedSurfIdx = new Uint32Array(triangleCount);\n  for (let i = 0; i < triangleCount; i++) {\n    const src = indices[i];\n    reorderedVerts.set(triangleVertices.subarray(src * 9, src * 9 + 9), i * 9);\n    reorderedNormals.set(triangleNormals.subarray(src * 3, src * 3 + 3), i * 3);\n    reorderedSurfIdx[i] = triangleSurfaceIndex[src];\n  }\n\n  // Flatten BVH to linear array\n  const { nodeArray, nodeCount } = flattenBvh(root);\n\n  // ── 3. Surface acoustic data ──────────────────────────────────────\n\n  const numFreqs = frequencies.length;\n  const surfaceAcousticData = new Float32Array(surfaces.length * numFreqs * 2);\n  for (let si = 0; si < surfaces.length; si++) {\n    const surface = surfaces[si];\n    for (let fi = 0; fi < numFreqs; fi++) {\n      const offset = (si * numFreqs + fi) * 2;\n      surfaceAcousticData[offset] = surface.absorptionFunction(frequencies[fi]);\n      surfaceAcousticData[offset + 1] = surface.scatteringFunction(frequencies[fi]);\n    }\n  }\n\n  // ── 4. Receiver spheres ───────────────────────────────────────────\n\n  const receiverUuidMap: string[] = [];\n  const receiverData: number[] = [];\n  for (const id of receiverIDs) {\n    const rec = containers[id] as Receiver | undefined;\n    if (rec) {\n      receiverUuidMap.push(id);\n      // Base geometry radius is 0.1; account for world-space scale\n      const baseRadius = 0.1;\n      const s = rec.scale;\n      const maxScale = Math.max(Math.abs(s.x), Math.abs(s.y), Math.abs(s.z));\n      receiverData.push(rec.position.x, rec.position.y, rec.position.z, baseRadius * maxScale);\n    }\n  }\n\n  return {\n    bvhNodes: nodeArray,\n    triangleVertices: reorderedVerts,\n    triangleSurfaceIndex: reorderedSurfIdx,\n    triangleNormals: reorderedNormals,\n    surfaceAcousticData,\n    receiverSpheres: new Float32Array(receiverData),\n    triangleCount,\n    nodeCount,\n    surfaceCount: surfaces.length,\n    receiverCount: receiverUuidMap.length,\n    surfaceUuidMap,\n    receiverUuidMap,\n  };\n}\n\n// ── BVH construction (recursive midpoint split on longest axis) ──────\n\nconst MAX_LEAF_TRIS = 8;\nconst MAX_DEPTH = 64;\n\nfunction buildBvhNode(\n  verts: Float32Array,\n  centroids: Float32Array,\n  indices: Uint32Array,\n  start: number,\n  end: number,\n  depth: number,\n): BvhNode {\n  // Compute bounds over [start, end)\n  let minX = Infinity, minY = Infinity, minZ = Infinity;\n  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n  for (let i = start; i < end; i++) {\n    const ti = indices[i];\n    for (let v = 0; v < 3; v++) {\n      const b = ti * 9 + v * 3;\n      const x = verts[b], y = verts[b + 1], z = verts[b + 2];\n      if (x < minX) minX = x; if (x > maxX) maxX = x;\n      if (y < minY) minY = y; if (y > maxY) maxY = y;\n      if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;\n    }\n  }\n\n  const count = end - start;\n  if (count <= MAX_LEAF_TRIS || depth >= MAX_DEPTH) {\n    return { boundsMin: [minX, minY, minZ], boundsMax: [maxX, maxY, maxZ], left: null, right: null, triStart: start, triCount: count };\n  }\n\n  // Split along the longest axis at centroid midpoint\n  const dx = maxX - minX, dy = maxY - minY, dz = maxZ - minZ;\n  const axis = dx >= dy && dx >= dz ? 0 : (dy >= dz ? 1 : 2);\n\n  // Find centroid midpoint along this axis\n  let centroidMin = Infinity, centroidMax = -Infinity;\n  for (let i = start; i < end; i++) {\n    const c = centroids[indices[i] * 3 + axis];\n    if (c < centroidMin) centroidMin = c;\n    if (c > centroidMax) centroidMax = c;\n  }\n  const split = (centroidMin + centroidMax) * 0.5;\n\n  // Partition indices around split\n  let mid = start;\n  for (let i = start; i < end; i++) {\n    if (centroids[indices[i] * 3 + axis] < split) {\n      // swap indices[i] and indices[mid]\n      const tmp = indices[mid];\n      indices[mid] = indices[i];\n      indices[i] = tmp;\n      mid++;\n    }\n  }\n\n  // Fallback: if all went to one side, split in half\n  if (mid === start || mid === end) {\n    mid = (start + end) >> 1;\n  }\n\n  const left = buildBvhNode(verts, centroids, indices, start, mid, depth + 1);\n  const right = buildBvhNode(verts, centroids, indices, mid, end, depth + 1);\n\n  return { boundsMin: [minX, minY, minZ], boundsMax: [maxX, maxY, maxZ], left, right, triStart: -1, triCount: -1 };\n}\n\n// ── Flatten BVH into a linear Float32Array ──────────────────────────\n//\n// Each node occupies 8 floats:\n//   [boundsMinX, boundsMinY, boundsMinZ, data0,\n//    boundsMaxX, boundsMaxY, boundsMaxZ, data1]\n//\n// Internal node: data0 = left child index, data1 = right child index\n// Leaf node:     data0 = triStart,         data1 = triCount | 0x80000000\n\nfunction flattenBvh(root: BvhNode): { nodeArray: Float32Array; nodeCount: number } {\n  // First pass: count nodes\n  let count = 0;\n  const stack: BvhNode[] = [root];\n  while (stack.length > 0) {\n    const node = stack.pop()!;\n    count++;\n    if (node.left) stack.push(node.left);\n    if (node.right) stack.push(node.right);\n  }\n\n  const nodeArray = new Float32Array(count * 8);\n  let nextIndex = 0;\n\n  function write(node: BvhNode): number {\n    const myIndex = nextIndex++;\n    const off = myIndex * 8;\n    nodeArray[off] = node.boundsMin[0];\n    nodeArray[off + 1] = node.boundsMin[1];\n    nodeArray[off + 2] = node.boundsMin[2];\n    nodeArray[off + 4] = node.boundsMax[0];\n    nodeArray[off + 5] = node.boundsMax[1];\n    nodeArray[off + 6] = node.boundsMax[2];\n\n    // Use a Uint32Array view to write integer data into the f32 buffer,\n    // since the WGSL shader reads these slots via bitcast<u32>().\n    const u32View = new Uint32Array(nodeArray.buffer);\n\n    if (node.left && node.right) {\n      // Internal: reserve slots for children indices, fill after recursion\n      const leftIdx = write(node.left);\n      const rightIdx = write(node.right);\n      u32View[off + 3] = leftIdx;\n      u32View[off + 7] = rightIdx;\n    } else {\n      // Leaf: triStart in data0, triCount | leaf flag in data1\n      u32View[off + 3] = node.triStart;\n      u32View[off + 7] = (node.triCount | 0x80000000) >>> 0;\n    }\n\n    return myIndex;\n  }\n\n  write(root);\n\n  return { nodeArray, nodeCount: count };\n}\n\n// ── Helpers ──────────────────────────────────────────────────────────\n\nfunction computeFaceNormal(\n  ax: number, ay: number, az: number,\n  bx: number, by: number, bz: number,\n  cx: number, cy: number, cz: number,\n): [number, number, number] {\n  const e1x = bx - ax, e1y = by - ay, e1z = bz - az;\n  const e2x = cx - ax, e2y = cy - ay, e2z = cz - az;\n  let nx = e1y * e2z - e1z * e2y;\n  let ny = e1z * e2x - e1x * e2z;\n  let nz = e1x * e2y - e1y * e2x;\n  const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n  if (len > 1e-10) { nx /= len; ny /= len; nz /= len; }\n  return [nx, ny, nz];\n}\n","export default \"// ─── GPU Ray Tracer Compute Shader ───────────────────────────────────\\n// Traces one ray per thread through all bounces using an iterative BVH\\n// traversal and Moller–Trumbore ray-triangle intersection.\\n//\\n// Mirrors the CPU implementation in ray-core.ts.\\n\\n// Constants\\nconst MAX_BOUNCES: u32 = 64u;\\nconst MAX_BANDS: u32 = 7u;\\nconst BVH_STACK_SIZE: u32 = 64u;\\nconst SELF_INTERSECTION_OFFSET: f32 = 0.01;\\nconst PI: f32 = 3.14159265358979;\\nconst EPSILON: f32 = 1e-6;\\n\\n// ─── Structures ──────────────────────────────────────────────────────\\n\\nstruct Params {\\n  numRays: u32,\\n  maxBounces: u32,\\n  numBands: u32,\\n  numReceivers: u32,\\n  numTriangles: u32,\\n  numNodes: u32,\\n  numSurfaces: u32,\\n  batchSeed: u32,\\n  rrThreshold: f32,\\n  _pad0: f32,\\n  _pad1: f32,\\n  _pad2: f32,\\n  // Per-band air attenuation in dB/m (up to MAX_BANDS), packed into vec4s\\n  // to satisfy uniform buffer layout rules (array<f32> has 16-byte stride).\\n  // airAttPacked[0] = (band0, band1, band2, band3)\\n  // airAttPacked[1] = (band4, band5, band6, unused)\\n  airAttPacked: array<vec4<f32>, 2>,\\n}\\n\\nfn getAirAtt(band: u32) -> f32 {\\n  return params.airAttPacked[band / 4u][band % 4u];\\n}\\n\\n// Per-bounce output written to the chain buffer\\nstruct ChainEntry {\\n  px: f32, py: f32, pz: f32,\\n  distance: f32,\\n  surfaceIndex: u32,\\n  _pad0: u32,\\n  angle: f32,\\n  energy: f32,\\n  bandEnergy: array<f32, 7>,\\n  _pad1: f32,\\n}\\n\\n// Per-ray output\\nstruct RayOutput {\\n  chainLength: u32,\\n  intersectedReceiver: u32, // 0 or 1\\n  receiverIndex: u32,\\n  arrivalDirX: f32,\\n  arrivalDirY: f32,\\n  arrivalDirZ: f32,\\n  _pad0: f32,\\n  _pad1: f32,\\n  finalBandEnergy: array<f32, 7>,\\n  _pad2: f32,\\n}\\n\\n// Per-ray input\\nstruct RayInput {\\n  ox: f32, oy: f32, oz: f32,\\n  dx: f32, dy: f32, dz: f32,\\n  initialPhi: f32,\\n  initialTheta: f32,\\n  bandEnergy: array<f32, 7>,\\n  _pad: f32,\\n}\\n\\n// ─── Bindings ────────────────────────────────────────────────────────\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bvhNodes: array<f32>;\\n@group(0) @binding(2) var<storage, read> triVerts: array<f32>;\\n@group(0) @binding(3) var<storage, read> triSurfIndex: array<u32>;\\n@group(0) @binding(4) var<storage, read> triNormals: array<f32>;\\n@group(0) @binding(5) var<storage, read> surfAcoustic: array<f32>;\\n@group(0) @binding(6) var<storage, read> receiverSpheres: array<f32>;\\n@group(0) @binding(7) var<storage, read> rayInputs: array<RayInput>;\\n@group(0) @binding(8) var<storage, read_write> rayOutputs: array<RayOutput>;\\n@group(0) @binding(9) var<storage, read_write> chainBuffer: array<ChainEntry>;\\n\\n// ─── RNG (PCG hash) ─────────────────────────────────────────────────\\n\\nfn pcg_hash(input: u32) -> u32 {\\n  var state = input * 747796405u + 2891336453u;\\n  var word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\\n  return (word >> 22u) ^ word;\\n}\\n\\nfn rand(seed: ptr<function, u32>) -> f32 {\\n  *seed = pcg_hash(*seed);\\n  return f32(*seed) / 4294967295.0;\\n}\\n\\n// ─── Vector helpers ─────────────────────────────────────────────────\\n\\nfn dot3(ax: f32, ay: f32, az: f32, bx: f32, by: f32, bz: f32) -> f32 {\\n  return ax * bx + ay * by + az * bz;\\n}\\n\\nfn length3(x: f32, y: f32, z: f32) -> f32 {\\n  return sqrt(x * x + y * y + z * z);\\n}\\n\\nfn normalize3(x: f32, y: f32, z: f32) -> vec3<f32> {\\n  let len = length3(x, y, z);\\n  if (len < EPSILON) { return vec3<f32>(0.0, 1.0, 0.0); }\\n  return vec3<f32>(x / len, y / len, z / len);\\n}\\n\\n// ─── Ray-AABB slab test ─────────────────────────────────────────────\\n\\nfn rayAabbIntersect(\\n  ox: f32, oy: f32, oz: f32,\\n  invDx: f32, invDy: f32, invDz: f32,\\n  bminX: f32, bminY: f32, bminZ: f32,\\n  bmaxX: f32, bmaxY: f32, bmaxZ: f32,\\n  tMax: f32,\\n) -> bool {\\n  var t1 = (bminX - ox) * invDx;\\n  var t2 = (bmaxX - ox) * invDx;\\n  var tNear = min(t1, t2);\\n  var tFar = max(t1, t2);\\n\\n  t1 = (bminY - oy) * invDy;\\n  t2 = (bmaxY - oy) * invDy;\\n  tNear = max(tNear, min(t1, t2));\\n  tFar = min(tFar, max(t1, t2));\\n\\n  t1 = (bminZ - oz) * invDz;\\n  t2 = (bmaxZ - oz) * invDz;\\n  tNear = max(tNear, min(t1, t2));\\n  tFar = min(tFar, max(t1, t2));\\n\\n  return tNear <= tFar && tFar >= 0.0 && tNear < tMax;\\n}\\n\\n// ─── Moller–Trumbore ray-triangle intersection ──────────────────────\\n\\nfn rayTriIntersect(\\n  ox: f32, oy: f32, oz: f32,\\n  dx: f32, dy: f32, dz: f32,\\n  triIdx: u32,\\n) -> vec2<f32> {\\n  // Returns (t, 0) on hit, (-1, 0) on miss\\n  let b = triIdx * 9u;\\n  let v0x = triVerts[b]; let v0y = triVerts[b + 1u]; let v0z = triVerts[b + 2u];\\n  let v1x = triVerts[b + 3u]; let v1y = triVerts[b + 4u]; let v1z = triVerts[b + 5u];\\n  let v2x = triVerts[b + 6u]; let v2y = triVerts[b + 7u]; let v2z = triVerts[b + 8u];\\n\\n  let e1x = v1x - v0x; let e1y = v1y - v0y; let e1z = v1z - v0z;\\n  let e2x = v2x - v0x; let e2y = v2y - v0y; let e2z = v2z - v0z;\\n\\n  // h = cross(d, e2)\\n  let hx = dy * e2z - dz * e2y;\\n  let hy = dz * e2x - dx * e2z;\\n  let hz = dx * e2y - dy * e2x;\\n\\n  let a = e1x * hx + e1y * hy + e1z * hz;\\n  if (abs(a) < EPSILON) { return vec2<f32>(-1.0, 0.0); }\\n\\n  let f_inv = 1.0 / a;\\n  let sx = ox - v0x; let sy = oy - v0y; let sz = oz - v0z;\\n  let u = f_inv * (sx * hx + sy * hy + sz * hz);\\n  if (u < 0.0 || u > 1.0) { return vec2<f32>(-1.0, 0.0); }\\n\\n  // q = cross(s, e1)\\n  let qx = sy * e1z - sz * e1y;\\n  let qy = sz * e1x - sx * e1z;\\n  let qz = sx * e1y - sy * e1x;\\n  let v = f_inv * (dx * qx + dy * qy + dz * qz);\\n  if (v < 0.0 || u + v > 1.0) { return vec2<f32>(-1.0, 0.0); }\\n\\n  let t = f_inv * (e2x * qx + e2y * qy + e2z * qz);\\n  if (t < EPSILON) { return vec2<f32>(-1.0, 0.0); }\\n\\n  return vec2<f32>(t, 0.0);\\n}\\n\\n// ─── Ray-sphere intersection ────────────────────────────────────────\\n\\nfn raySphereIntersect(\\n  ox: f32, oy: f32, oz: f32,\\n  dx: f32, dy: f32, dz: f32,\\n  cx: f32, cy: f32, cz: f32,\\n  r: f32,\\n) -> f32 {\\n  let lx = cx - ox; let ly = cy - oy; let lz = cz - oz;\\n  let tca = lx * dx + ly * dy + lz * dz;\\n  let d2 = lx * lx + ly * ly + lz * lz - tca * tca;\\n  let r2 = r * r;\\n  if (d2 > r2) { return -1.0; }\\n  let thc = sqrt(r2 - d2);\\n  var t0 = tca - thc;\\n  let t1 = tca + thc;\\n  if (t0 < EPSILON) { t0 = t1; }\\n  if (t0 < EPSILON) { return -1.0; }\\n  return t0;\\n}\\n\\n// ─── BVH traversal — find closest triangle hit ─────────────────────\\n\\nstruct HitResult {\\n  t: f32,\\n  triIdx: u32,\\n  hit: bool,\\n}\\n\\nfn traceClosest(\\n  ox: f32, oy: f32, oz: f32,\\n  dx: f32, dy: f32, dz: f32,\\n) -> HitResult {\\n  var result: HitResult;\\n  result.t = 1e30;\\n  result.triIdx = 0u;\\n  result.hit = false;\\n\\n  let invDx = select(1e30, 1.0 / dx, abs(dx) > EPSILON);\\n  let invDy = select(1e30, 1.0 / dy, abs(dy) > EPSILON);\\n  let invDz = select(1e30, 1.0 / dz, abs(dz) > EPSILON);\\n\\n  var stack: array<u32, 64>;\\n  var stackPtr: u32 = 0u;\\n  stack[0] = 0u; // root node index\\n  stackPtr = 1u;\\n\\n  while (stackPtr > 0u) {\\n    stackPtr -= 1u;\\n    let nodeIdx = stack[stackPtr];\\n    let off = nodeIdx * 8u;\\n\\n    let bminX = bvhNodes[off];\\n    let bminY = bvhNodes[off + 1u];\\n    let bminZ = bvhNodes[off + 2u];\\n    let bmaxX = bvhNodes[off + 4u];\\n    let bmaxY = bvhNodes[off + 5u];\\n    let bmaxZ = bvhNodes[off + 6u];\\n\\n    if (!rayAabbIntersect(ox, oy, oz, invDx, invDy, invDz, bminX, bminY, bminZ, bmaxX, bmaxY, bmaxZ, result.t)) {\\n      continue;\\n    }\\n\\n    // Read data1 as u32 to check leaf flag\\n    let data1Bits = bitcast<u32>(bvhNodes[off + 7u]);\\n    let isLeaf = (data1Bits & 0x80000000u) != 0u;\\n\\n    if (isLeaf) {\\n      let triStart = bitcast<u32>(bvhNodes[off + 3u]);\\n      let triCount = data1Bits & 0x7FFFFFFFu;\\n      for (var i = 0u; i < triCount; i++) {\\n        let tri = triStart + i;\\n        let res = rayTriIntersect(ox, oy, oz, dx, dy, dz, tri);\\n        if (res.x > 0.0 && res.x < result.t) {\\n          result.t = res.x;\\n          result.triIdx = tri;\\n          result.hit = true;\\n        }\\n      }\\n    } else {\\n      let leftIdx = bitcast<u32>(bvhNodes[off + 3u]);\\n      let rightIdx = data1Bits;\\n      if (stackPtr < BVH_STACK_SIZE) {\\n        stack[stackPtr] = leftIdx;\\n        stackPtr += 1u;\\n      }\\n      if (stackPtr < BVH_STACK_SIZE) {\\n        stack[stackPtr] = rightIdx;\\n        stackPtr += 1u;\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n// ─── Reflection coefficient (matches CPU reflection-coefficient.ts) ──\\n\\nfn reflectionCoefficient(alpha: f32, theta: f32) -> f32 {\\n  let rootOneMinusAlpha = sqrt(max(1.0 - alpha, 0.0));\\n  let xi_o = (1.0 - rootOneMinusAlpha) / (1.0 + rootOneMinusAlpha);\\n  let cosTheta = abs(cos(theta));\\n  let xi_o_cosTheta = xi_o * cosTheta;\\n  let R = (xi_o_cosTheta - 1.0) / (xi_o_cosTheta + 1.0);\\n  return R * R;\\n}\\n\\n// ─── Main compute entry point ───────────────────────────────────────\\n\\n@compute @workgroup_size(64)\\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\\n  let rayIdx = gid.x;\\n  if (rayIdx >= params.numRays) { return; }\\n\\n  let inp = rayInputs[rayIdx];\\n  let numBands = min(params.numBands, MAX_BANDS);\\n  let maxBounces = min(params.maxBounces, MAX_BOUNCES);\\n\\n  var rngSeed: u32 = pcg_hash(rayIdx * 747796405u + params.batchSeed);\\n\\n  // Current ray state\\n  var ox = inp.ox; var oy = inp.oy; var oz = inp.oz;\\n  var dx = inp.dx; var dy = inp.dy; var dz = inp.dz;\\n  var d = normalize3(dx, dy, dz);\\n  dx = d.x; dy = d.y; dz = d.z;\\n\\n  var bandEnergy: array<f32, 7>;\\n  for (var b = 0u; b < numBands; b++) {\\n    bandEnergy[b] = inp.bandEnergy[b];\\n  }\\n\\n  // Output\\n  let chainBase = rayIdx * MAX_BOUNCES;\\n  var chainLen: u32 = 0u;\\n  var hitReceiver: u32 = 0u;\\n  var receiverIdx: u32 = 0u;\\n  var arrivalDir = vec3<f32>(0.0, 0.0, 0.0);\\n\\n  for (var bounce = 0u; bounce < maxBounces; bounce++) {\\n    // Check receiver spheres first (find closest)\\n    var closestRecT: f32 = 1e30;\\n    var closestRecIdx: u32 = 0u;\\n    var recHit = false;\\n    for (var ri = 0u; ri < params.numReceivers; ri++) {\\n      let rb = ri * 4u;\\n      let rcx = receiverSpheres[rb];\\n      let rcy = receiverSpheres[rb + 1u];\\n      let rcz = receiverSpheres[rb + 2u];\\n      let rr = receiverSpheres[rb + 3u];\\n      let t = raySphereIntersect(ox, oy, oz, dx, dy, dz, rcx, rcy, rcz, rr);\\n      if (t > 0.0 && t < closestRecT) {\\n        closestRecT = t;\\n        closestRecIdx = ri;\\n        recHit = true;\\n      }\\n    }\\n\\n    // BVH closest triangle hit\\n    let triHit = traceClosest(ox, oy, oz, dx, dy, dz);\\n\\n    // Receiver is closer than any surface — ray enters receiver\\n    if (recHit && closestRecT < triHit.t) {\\n      // Apply air absorption for receiver segment\\n      for (var b = 0u; b < numBands; b++) {\\n        bandEnergy[b] *= pow(10.0, -getAirAtt(b) * closestRecT / 10.0);\\n      }\\n\\n      // Compute mean energy\\n      var totalE: f32 = 0.0;\\n      for (var b = 0u; b < numBands; b++) { totalE += bandEnergy[b]; }\\n      let meanE = totalE / f32(numBands);\\n\\n      // Record chain entry at receiver position\\n      if (chainLen < MAX_BOUNCES) {\\n        let ci = chainBase + chainLen;\\n        chainBuffer[ci].px = ox + dx * closestRecT;\\n        chainBuffer[ci].py = oy + dy * closestRecT;\\n        chainBuffer[ci].pz = oz + dz * closestRecT;\\n        chainBuffer[ci].distance = closestRecT;\\n        // Store receiver index encoded as surface index + numSurfaces offset\\n        chainBuffer[ci].surfaceIndex = params.numSurfaces + closestRecIdx;\\n        chainBuffer[ci].angle = 0.0;\\n        chainBuffer[ci].energy = meanE;\\n        for (var b = 0u; b < numBands; b++) {\\n          chainBuffer[ci].bandEnergy[b] = bandEnergy[b];\\n        }\\n        chainLen += 1u;\\n      }\\n\\n      hitReceiver = 1u;\\n      receiverIdx = closestRecIdx;\\n      arrivalDir = normalize3(-dx, -dy, -dz);\\n      break;\\n    }\\n\\n    // No surface hit — ray escapes\\n    if (!triHit.hit) { break; }\\n\\n    // Surface hit\\n    let hitT = triHit.t;\\n    let hitTri = triHit.triIdx;\\n    let surfIdx = triSurfIndex[hitTri];\\n\\n    // Hit point\\n    let hx = ox + dx * hitT;\\n    let hy = oy + dy * hitT;\\n    let hz = oz + dz * hitT;\\n\\n    // Face normal\\n    let nb = hitTri * 3u;\\n    let nx = triNormals[nb];\\n    let ny = triNormals[nb + 1u];\\n    let nz = triNormals[nb + 2u];\\n\\n    // Incidence angle\\n    let negDdotN = -(dx * nx + dy * ny + dz * nz);\\n    let angle = acos(clamp(abs(negDdotN), 0.0, 1.0));\\n\\n    // Mean energy before reflection (for chain output)\\n    var totalEBefore: f32 = 0.0;\\n    for (var b = 0u; b < numBands; b++) { totalEBefore += bandEnergy[b]; }\\n    let meanEBefore = totalEBefore / f32(numBands);\\n\\n    // Record chain entry\\n    if (chainLen < MAX_BOUNCES) {\\n      let ci = chainBase + chainLen;\\n      chainBuffer[ci].px = hx;\\n      chainBuffer[ci].py = hy;\\n      chainBuffer[ci].pz = hz;\\n      chainBuffer[ci].distance = hitT;\\n      chainBuffer[ci].surfaceIndex = surfIdx;\\n      chainBuffer[ci].angle = angle;\\n      chainBuffer[ci].energy = meanEBefore;\\n      for (var b = 0u; b < numBands; b++) {\\n        chainBuffer[ci].bandEnergy[b] = bandEnergy[b];\\n      }\\n      chainLen += 1u;\\n    }\\n\\n    // Apply per-band reflection loss and air absorption\\n    var broadbandScatter: f32 = 0.0;\\n    var totalEForScatter: f32 = 0.0;\\n\\n    for (var b = 0u; b < numBands; b++) {\\n      let acousticOffset = (surfIdx * params.numBands + b) * 2u;\\n      let alpha = surfAcoustic[acousticOffset];\\n      let scatter = surfAcoustic[acousticOffset + 1u];\\n\\n      let R = reflectionCoefficient(alpha, angle);\\n      bandEnergy[b] *= abs(R);\\n      bandEnergy[b] *= pow(10.0, -getAirAtt(b) * hitT / 10.0);\\n\\n      broadbandScatter += scatter * bandEnergy[b];\\n      totalEForScatter += bandEnergy[b];\\n    }\\n\\n    if (totalEForScatter > 0.0) {\\n      broadbandScatter /= totalEForScatter;\\n    }\\n\\n    // Russian Roulette termination\\n    var maxE: f32 = 0.0;\\n    for (var b = 0u; b < numBands; b++) {\\n      maxE = max(maxE, bandEnergy[b]);\\n    }\\n\\n    if (maxE < params.rrThreshold && maxE > 0.0) {\\n      let survivalProb = maxE / params.rrThreshold;\\n      if (rand(&rngSeed) > survivalProb) {\\n        break; // Terminate\\n      }\\n      // Boost survivors\\n      for (var b = 0u; b < numBands; b++) {\\n        bandEnergy[b] /= survivalProb;\\n      }\\n    } else if (maxE <= 0.0) {\\n      break;\\n    }\\n\\n    // Compute reflected direction\\n    // Specular: r = d - 2(d·n)n\\n    let dDotN = dx * nx + dy * ny + dz * nz;\\n    var rx = dx - 2.0 * dDotN * nx;\\n    var ry = dy - 2.0 * dDotN * ny;\\n    var rz = dz - 2.0 * dDotN * nz;\\n\\n    // Scattering: probabilistic Lambert vs specular\\n    if (rand(&rngSeed) < broadbandScatter) {\\n      // Cosine-weighted hemisphere sampling (rejection + normal offset)\\n      var sx: f32; var sy: f32; var sz: f32; var lenSq: f32;\\n      loop {\\n        sx = rand(&rngSeed) * 2.0 - 1.0;\\n        sy = rand(&rngSeed) * 2.0 - 1.0;\\n        sz = rand(&rngSeed) * 2.0 - 1.0;\\n        lenSq = sx * sx + sy * sy + sz * sz;\\n        if (lenSq <= 1.0 && lenSq > 1e-6) { break; }\\n      }\\n      let invLen = 1.0 / sqrt(lenSq);\\n      sx *= invLen; sy *= invLen; sz *= invLen;\\n      // Offset along normal for cosine distribution\\n      rx = sx + nx;\\n      ry = sy + ny;\\n      rz = sz + nz;\\n    }\\n\\n    // Normalize reflected direction\\n    d = normalize3(rx, ry, rz);\\n    dx = d.x; dy = d.y; dz = d.z;\\n\\n    // Offset origin along normal to avoid self-intersection\\n    ox = hx + nx * SELF_INTERSECTION_OFFSET;\\n    oy = hy + ny * SELF_INTERSECTION_OFFSET;\\n    oz = hz + nz * SELF_INTERSECTION_OFFSET;\\n  }\\n\\n  // Write output\\n  rayOutputs[rayIdx].chainLength = chainLen;\\n  rayOutputs[rayIdx].intersectedReceiver = hitReceiver;\\n  rayOutputs[rayIdx].receiverIndex = receiverIdx;\\n  rayOutputs[rayIdx].arrivalDirX = arrivalDir.x;\\n  rayOutputs[rayIdx].arrivalDirY = arrivalDir.y;\\n  rayOutputs[rayIdx].arrivalDirZ = arrivalDir.z;\\n  for (var b = 0u; b < min(params.numBands, MAX_BANDS); b++) {\\n    rayOutputs[rayIdx].finalBandEnergy[b] = bandEnergy[b];\\n  }\\n}\\n\"","/**\n * CPU-side orchestrator that manages WebGPU resources and dispatches\n * the ray-trace compute shader.\n */\nimport { requestGpuContext } from './gpu-context';\nimport { buildGpuSceneBuffers } from './gpu-bvh';\nimport type { GpuSceneBuffers } from './gpu-bvh';\nimport type Room from '../../../objects/room';\nimport type { RayPath, Chain, BandEnergy } from '../types';\nimport shaderSource from './ray-trace.wgsl?raw';\n\n// ─── Constants matching WGSL ─────────────────────────────────────────\n\nconst MAX_BOUNCES = 64;\nconst MAX_BANDS = 7;\nconst WORKGROUP_SIZE = 64;\n\n// Byte sizes for GPU structs (must match WGSL layout exactly)\n// RayInput: 8 floats + 7 band + 1 pad = 16 floats = 64 bytes\nconst RAY_INPUT_FLOATS = 16;\nconst RAY_INPUT_BYTES = RAY_INPUT_FLOATS * 4;\n\n// RayOutput: 8 floats + 7 band + 1 pad = 16 floats = 64 bytes\nconst RAY_OUTPUT_FLOATS = 16;\nconst RAY_OUTPUT_BYTES = RAY_OUTPUT_FLOATS * 4;\n\n// ChainEntry: 8 floats + 7 band + 1 pad = 16 floats = 64 bytes\nconst CHAIN_ENTRY_FLOATS = 16;\nconst CHAIN_ENTRY_BYTES = CHAIN_ENTRY_FLOATS * 4;\n\n// Params uniform: see struct in WGSL\n// 8 u32/f32 + rrThreshold + 3 pad + 2×vec4 airAttPacked = 20 floats (80 bytes)\nconst PARAMS_FLOATS = 20;\nconst PARAMS_BYTES = PARAMS_FLOATS * 4;\n\nexport interface GpuRayTracerConfig {\n  reflectionOrder: number;\n  frequencies: number[];\n  cachedAirAtt: number[];\n  rrThreshold: number;\n}\n\nexport class GpuRayTracer {\n  private device: GPUDevice | null = null;\n  private pipeline: GPUComputePipeline | null = null;\n  private bindGroupLayout: GPUBindGroupLayout | null = null;\n\n  // Scene buffers\n  private sceneBuf: GpuSceneBuffers | null = null;\n  private gpuBvhNodes: GPUBuffer | null = null;\n  private gpuTriVerts: GPUBuffer | null = null;\n  private gpuTriSurfIdx: GPUBuffer | null = null;\n  private gpuTriNormals: GPUBuffer | null = null;\n  private gpuSurfAcoustic: GPUBuffer | null = null;\n  private gpuReceiverSpheres: GPUBuffer | null = null;\n\n  // Per-dispatch buffers\n  private gpuRayInputs: GPUBuffer | null = null;\n  private gpuRayOutputs: GPUBuffer | null = null;\n  private gpuChainBuffer: GPUBuffer | null = null;\n  private gpuParams: GPUBuffer | null = null;\n  private gpuReadbackOutput: GPUBuffer | null = null;\n  private gpuReadbackChain: GPUBuffer | null = null;\n\n  private config: GpuRayTracerConfig | null = null;\n  private maxBatchSize = 0;\n\n  /** The actual batch size after clamping to device limits. */\n  get effectiveBatchSize(): number { return this.maxBatchSize; }\n\n  async initialize(\n    room: Room,\n    receiverIDs: string[],\n    config: GpuRayTracerConfig,\n    requestedBatchSize: number,\n  ): Promise<boolean> {\n    const ctx = await requestGpuContext();\n    if (!ctx) return false;\n\n    this.device = ctx.device;\n    this.config = config;\n\n    // Clamp batchSize to fit within device storage buffer limits.\n    // The chain buffer is the largest: batchSize × MAX_BOUNCES × CHAIN_ENTRY_BYTES.\n    const maxStorageBinding = ctx.device.limits.maxStorageBufferBindingSize;\n    const maxBufSize = ctx.device.limits.maxBufferSize;\n    const perRayChainBytes = MAX_BOUNCES * CHAIN_ENTRY_BYTES;\n    const maxByLimits = Math.floor(Math.min(maxStorageBinding, maxBufSize) / perRayChainBytes);\n    if (maxByLimits < 1) {\n      console.error('[GPU RT] Device storage limits too small for even a single ray chain buffer');\n      return false;\n    }\n    const normalizedRequested = Math.max(1, requestedBatchSize);\n    const batchSize = Math.min(normalizedRequested, maxByLimits);\n    if (batchSize < normalizedRequested) {\n      console.warn(`[GPU RT] batchSize ${normalizedRequested} exceeds device limits; clamped to ${batchSize}`);\n    }\n    this.maxBatchSize = batchSize;\n\n    // Clamp reflection order\n    if (config.reflectionOrder > MAX_BOUNCES) {\n      console.warn(`[GPU RT] reflectionOrder ${config.reflectionOrder} clamped to ${MAX_BOUNCES}`);\n    }\n\n    // Truncate frequencies to MAX_BANDS so scene buffer stride matches shader indexing\n    const clampedFrequencies = config.frequencies.slice(0, MAX_BANDS);\n\n    // Build scene data\n    this.sceneBuf = buildGpuSceneBuffers(room, receiverIDs, clampedFrequencies);\n\n    // Create GPU storage buffers for scene\n    this.gpuBvhNodes = this.createStorageBuffer(this.sceneBuf.bvhNodes);\n    this.gpuTriVerts = this.createStorageBuffer(this.sceneBuf.triangleVertices);\n    this.gpuTriSurfIdx = this.createStorageBuffer(new Uint32Array(this.sceneBuf.triangleSurfaceIndex));\n    this.gpuTriNormals = this.createStorageBuffer(this.sceneBuf.triangleNormals);\n    this.gpuSurfAcoustic = this.createStorageBuffer(this.sceneBuf.surfaceAcousticData);\n\n    // Receiver spheres (may be empty — create a 16-byte dummy if so)\n    const recData = this.sceneBuf.receiverSpheres.length > 0\n      ? this.sceneBuf.receiverSpheres\n      : new Float32Array(4); // dummy\n    this.gpuReceiverSpheres = this.createStorageBuffer(recData);\n\n    // Per-dispatch buffers\n    const inputBytes = batchSize * RAY_INPUT_BYTES;\n    const outputBytes = batchSize * RAY_OUTPUT_BYTES;\n    const chainBytes = batchSize * MAX_BOUNCES * CHAIN_ENTRY_BYTES;\n\n    this.gpuRayInputs = this.device.createBuffer({\n      size: inputBytes,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    this.gpuRayOutputs = this.device.createBuffer({\n      size: outputBytes,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    this.gpuChainBuffer = this.device.createBuffer({\n      size: chainBytes,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n    this.gpuParams = this.device.createBuffer({\n      size: PARAMS_BYTES,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    // Readback buffers\n    this.gpuReadbackOutput = this.device.createBuffer({\n      size: outputBytes,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    this.gpuReadbackChain = this.device.createBuffer({\n      size: chainBytes,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    // Create compute pipeline\n    const shaderModule = this.device.createShaderModule({ code: shaderSource });\n    this.pipeline = this.device.createComputePipeline({\n      layout: 'auto',\n      compute: { module: shaderModule, entryPoint: 'main' },\n    });\n    this.bindGroupLayout = this.pipeline.getBindGroupLayout(0);\n\n    return true;\n  }\n\n  async traceBatch(\n    rayInputs: Float32Array,\n    rayCount: number,\n    batchSeed: number,\n  ): Promise<(RayPath | null)[]> {\n    if (!this.device || !this.pipeline || !this.sceneBuf || !this.config) {\n      throw new Error('[GPU RT] Not initialized');\n    }\n\n    if (rayCount > this.maxBatchSize) {\n      throw new Error(`[GPU RT] rayCount ${rayCount} exceeds maxBatchSize ${this.maxBatchSize}`);\n    }\n    if (rayCount === 0) return [];\n\n    const numBands = Math.min(this.config.frequencies.length, MAX_BANDS);\n\n    // Write params uniform\n    const paramsData = new ArrayBuffer(PARAMS_BYTES);\n    const paramsU32 = new Uint32Array(paramsData);\n    const paramsF32 = new Float32Array(paramsData);\n    paramsU32[0] = rayCount;\n    paramsU32[1] = Math.min(this.config.reflectionOrder, MAX_BOUNCES);\n    paramsU32[2] = numBands;\n    paramsU32[3] = this.sceneBuf.receiverCount;\n    paramsU32[4] = this.sceneBuf.triangleCount;\n    paramsU32[5] = this.sceneBuf.nodeCount;\n    paramsU32[6] = this.sceneBuf.surfaceCount;\n    paramsU32[7] = batchSeed;\n    paramsF32[8] = this.config.rrThreshold;\n    // pad slots 9,10,11\n    // airAttPacked: array<vec4<f32>, 2> starts at index 12\n    // vec4[0] = (band0..3) at indices 12-15, vec4[1] = (band4..6, pad) at 16-18\n    for (let i = 0; i < numBands; i++) {\n      paramsF32[12 + i] = this.config.cachedAirAtt[i];\n    }\n\n    this.device.queue.writeBuffer(this.gpuParams!, 0, paramsData as ArrayBuffer);\n\n    // Write ray inputs\n    this.device.queue.writeBuffer(\n      this.gpuRayInputs!, 0,\n      rayInputs.buffer as ArrayBuffer, rayInputs.byteOffset, rayCount * RAY_INPUT_BYTES,\n    );\n\n    // Create bind group\n    const bindGroup = this.device.createBindGroup({\n      layout: this.bindGroupLayout!,\n      entries: [\n        { binding: 0, resource: { buffer: this.gpuParams! } },\n        { binding: 1, resource: { buffer: this.gpuBvhNodes! } },\n        { binding: 2, resource: { buffer: this.gpuTriVerts! } },\n        { binding: 3, resource: { buffer: this.gpuTriSurfIdx! } },\n        { binding: 4, resource: { buffer: this.gpuTriNormals! } },\n        { binding: 5, resource: { buffer: this.gpuSurfAcoustic! } },\n        { binding: 6, resource: { buffer: this.gpuReceiverSpheres! } },\n        { binding: 7, resource: { buffer: this.gpuRayInputs! } },\n        { binding: 8, resource: { buffer: this.gpuRayOutputs! } },\n        { binding: 9, resource: { buffer: this.gpuChainBuffer! } },\n      ],\n    });\n\n    // Dispatch compute\n    const workgroups = Math.ceil(rayCount / WORKGROUP_SIZE);\n    const encoder = this.device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(this.pipeline!);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(workgroups);\n    pass.end();\n\n    // Copy outputs to readback\n    const outputBytes = rayCount * RAY_OUTPUT_BYTES;\n    const chainBytes = rayCount * MAX_BOUNCES * CHAIN_ENTRY_BYTES;\n    encoder.copyBufferToBuffer(this.gpuRayOutputs!, 0, this.gpuReadbackOutput!, 0, outputBytes);\n    encoder.copyBufferToBuffer(this.gpuChainBuffer!, 0, this.gpuReadbackChain!, 0, chainBytes);\n\n    this.device.queue.submit([encoder.finish()]);\n\n    // Map readback buffers\n    await this.gpuReadbackOutput!.mapAsync(GPUMapMode.READ, 0, outputBytes);\n    await this.gpuReadbackChain!.mapAsync(GPUMapMode.READ, 0, chainBytes);\n\n    const outputData = new Float32Array(this.gpuReadbackOutput!.getMappedRange(0, outputBytes).slice(0));\n    const chainData = new Float32Array(this.gpuReadbackChain!.getMappedRange(0, chainBytes).slice(0));\n\n    this.gpuReadbackOutput!.unmap();\n    this.gpuReadbackChain!.unmap();\n\n    // Parse results into RayPath[]\n    return this.parseResults(outputData, chainData, rayInputs, rayCount, numBands);\n  }\n\n  private parseResults(\n    outputData: Float32Array,\n    chainData: Float32Array,\n    rayInputs: Float32Array,\n    rayCount: number,\n    numBands: number,\n  ): (RayPath | null)[] {\n    // Returns a fixed-length array (1:1 with input rays) so callers can\n    // map each result back to the correct source by index.  Entries are\n    // null for rays that produced no intersections (chainLength === 0).\n    const paths: (RayPath | null)[] = new Array(rayCount);\n    const scene = this.sceneBuf!;\n\n    for (let r = 0; r < rayCount; r++) {\n      const outOff = r * RAY_OUTPUT_FLOATS;\n      const outU32 = new Uint32Array(outputData.buffer, outOff * 4, RAY_OUTPUT_FLOATS);\n      const chainLength = outU32[0];\n      const intersectedReceiver = outU32[1] !== 0;\n\n      if (chainLength === 0) {\n        paths[r] = null;\n        continue;\n      }\n\n      const arrivalDir: [number, number, number] = [\n        outputData[outOff + 3],\n        outputData[outOff + 4],\n        outputData[outOff + 5],\n      ];\n\n      const finalBandEnergy: BandEnergy = [];\n      for (let b = 0; b < numBands; b++) {\n        finalBandEnergy.push(outputData[outOff + 8 + b]);\n      }\n\n      // Parse chain entries\n      const chain: Chain[] = [];\n      const chainBase = r * MAX_BOUNCES;\n      for (let c = 0; c < chainLength; c++) {\n        const cOff = (chainBase + c) * CHAIN_ENTRY_FLOATS;\n        const cU32 = new Uint32Array(chainData.buffer, cOff * 4, CHAIN_ENTRY_FLOATS);\n\n        const px = chainData[cOff];\n        const py = chainData[cOff + 1];\n        const pz = chainData[cOff + 2];\n        const distance = chainData[cOff + 3];\n        const surfaceIndex = cU32[4];\n        const angle = chainData[cOff + 6];\n        const energy = chainData[cOff + 7];\n\n        const bandEnergy: BandEnergy = [];\n        for (let b = 0; b < numBands; b++) {\n          bandEnergy.push(chainData[cOff + 8 + b]);\n        }\n\n        // Map surface/receiver index back to UUID\n        let objectUuid: string;\n        if (surfaceIndex >= scene.surfaceCount) {\n          // Receiver\n          const recIdx = surfaceIndex - scene.surfaceCount;\n          objectUuid = scene.receiverUuidMap[recIdx] ?? '';\n        } else {\n          objectUuid = scene.surfaceUuidMap[surfaceIndex] ?? '';\n        }\n\n        chain.push({\n          point: [px, py, pz],\n          distance,\n          object: objectUuid,\n          faceNormal: [0, 0, 0],\n          faceIndex: -1,\n          faceMaterialIndex: -1,\n          angle,\n          energy,\n          bandEnergy,\n        });\n      }\n\n      // Read source data from ray input\n      const inOff = r * RAY_INPUT_FLOATS;\n      const initialPhi = rayInputs[inOff + 6];\n      const initialTheta = rayInputs[inOff + 7];\n\n      // Total energy (mean across bands)\n      const totalE = finalBandEnergy.reduce((a, b) => a + b, 0);\n      const meanE = numBands > 0 ? totalE / numBands : 0;\n\n      paths[r] = {\n        intersectedReceiver,\n        chain,\n        chainLength: chain.length,\n        energy: meanE,\n        bandEnergy: finalBandEnergy,\n        time: 0, // Computed by caller (stop())\n        source: '', // Filled in by caller\n        initialPhi,\n        initialTheta,\n        totalLength: 0, // Computed by caller\n        arrivalDirection: intersectedReceiver ? arrivalDir : undefined,\n      };\n    }\n\n    return paths;\n  }\n\n  dispose(): void {\n    const buffers = [\n      this.gpuBvhNodes, this.gpuTriVerts, this.gpuTriSurfIdx,\n      this.gpuTriNormals, this.gpuSurfAcoustic, this.gpuReceiverSpheres,\n      this.gpuRayInputs, this.gpuRayOutputs, this.gpuChainBuffer,\n      this.gpuParams, this.gpuReadbackOutput, this.gpuReadbackChain,\n    ];\n    for (const buf of buffers) {\n      if (buf) buf.destroy();\n    }\n    this.gpuBvhNodes = null;\n    this.gpuTriVerts = null;\n    this.gpuTriSurfIdx = null;\n    this.gpuTriNormals = null;\n    this.gpuSurfAcoustic = null;\n    this.gpuReceiverSpheres = null;\n    this.gpuRayInputs = null;\n    this.gpuRayOutputs = null;\n    this.gpuChainBuffer = null;\n    this.gpuParams = null;\n    this.gpuReadbackOutput = null;\n    this.gpuReadbackChain = null;\n    this.pipeline = null;\n    this.bindGroupLayout = null;\n    this.device = null;\n    this.sceneBuf = null;\n    this.config = null;\n  }\n\n  private createStorageBuffer(data: Float32Array | Uint32Array): GPUBuffer {\n    // Ensure minimum size of 16 bytes\n    const size = Math.max(data.byteLength, 16);\n    const buffer = this.device!.createBuffer({\n      size,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    this.device!.queue.writeBuffer(\n      buffer, 0,\n      data.buffer as ArrayBuffer, data.byteOffset, data.byteLength,\n    );\n    return buffer;\n  }\n}\n","import Solver from \"../solver\";\nimport * as THREE from \"three\";\nimport Room from \"../../objects/room\";\nimport { KVP } from \"../../common/key-value-pair\";\nimport Container from \"../../objects/container\";\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from \"three-mesh-bvh\";\nimport Source from \"../../objects/source\";\nimport Surface from \"../../objects/surface\";\nimport Receiver from \"../../objects/receiver\";\nimport { Stat } from \"../../components/parameter-config/Stats\";\nimport { emit, messenger, on } from \"../../messenger\";\n\nimport Plotly, { PlotData } from \"plotly.js\";\n\nimport PointShader from \"./shaders/points\";\nimport * as ac from \"../acoustics\";\nimport { BVH } from \"./bvh/BVH\";\nimport { renderer } from \"../../render/renderer\";\nimport { addSolver, callSolverMethod, removeSolver, setSolverProperty, useContainer, useSolver } from \"../../store\";\nimport { ResultKind, useResult } from \"../../store/result-store\";\nimport {cramangle2threejsangle} from \"../../common/dir-angle-conversions\";\nimport { audioEngine } from \"../../audio-engine/audio-engine\";\nimport observe, { Observable } from \"../../common/observable\";\nimport { encodeBufferFromDirection, getAmbisonicChannelCount } from \"ambisonics\";\n\nimport {ImageSourceSolver, ImageSourceSolverParams} from \"./image-source/index\";\n\nimport {\n  QuickEstimateStepResult, ResponseByIntensity, BandEnergy, Chain,\n  RayPath, ChartData, ReceiverData, RayTracerParams,\n  ConvergenceMetrics, defaults, DRAWSTYLE, normalize,\n  DEFAULT_INTENSITY_SAMPLE_RATE, DEFAULT_INITIAL_SPL,\n  RESPONSE_TIME_PADDING, QUICK_ESTIMATE_MAX_ORDER, MAX_DISPLAY_POINTS, RT60_DECAY_RATIO,\n  HISTOGRAM_BIN_WIDTH, HISTOGRAM_NUM_BINS, CONVERGENCE_CHECK_INTERVAL_MS,\n  DEFAULT_TAIL_CROSSFADE_DURATION, MIN_TAIL_DECAY_RATE, MAX_TAIL_END_TIME,\n} from \"./types\";\n\n// Extracted module imports\nimport { traceRay as traceRayFn, inFrontOf as inFrontOfFn } from \"./ray-core\";\nimport { arrivalPressure as arrivalPressureFn, calculateImpulseResponseForPair as calcIRForPairFn, calculateImpulseResponseForDisplay as calcIRForDisplayFn } from \"./impulse-response\";\nimport type { TailOptions } from \"./impulse-response\";\nimport { extractDecayParameters, synthesizeTail, assembleFinalIR } from \"./tail-synthesis\";\nimport { reflectionLossFunction as reflectionLossFunctionFn, calculateReflectionLoss as calculateReflectionLossFn, calculateResponseByIntensity as calcResponseByIntensityFn, resampleResponseByIntensity as resampleResponseByIntensityFn, calculateT20 as calculateT20Fn, calculateT30 as calculateT30Fn, calculateT60 as calculateT60Fn } from \"./response-by-intensity\";\nimport { pathsToLinearBuffer as pathsToLinearBufferFn, linearBufferToPaths as linearBufferToPathsFn } from \"./serialization\";\nimport { downloadImpulses as downloadImpulsesFn, playImpulseResponse as playImpulseResponseFn, downloadImpulseResponse as downloadImpulseResponseFn, downloadAmbisonicImpulseResponse as downloadAmbisonicIRFn, playBinauralImpulseResponse as playBinauralIRFn, downloadBinauralImpulseResponse as downloadBinauralIRFn } from \"./export-playback\";\nimport { calculateBinauralFromAmbisonic } from \"../binaural/calculate-binaural\";\nimport { resetConvergenceState, updateConvergenceMetrics, addToEnergyHistogram } from \"./convergence\";\nimport { buildEdgeGraph, findDiffractionPaths } from \"./diffraction\";\nimport type { EdgeGraph } from \"./diffraction\";\nimport { isWebGPUAvailable } from \"./gpu/gpu-context\";\nimport { GpuRayTracer } from \"./gpu/gpu-ray-tracer\";\nimport { quickEstimateStep as sharedQuickEstimateStep } from \"../shared/quick-estimate\";\n\n// Re-export all types for external consumers\nexport type {\n  QuickEstimateStepResult, RayPathResult, ResponseByIntensity, BandEnergy, Chain,\n  RayPath, EnergyTime, ChartData, RayTracerSaveObject, RayTracerParams,\n  ConvergenceMetrics, DrawStyle, DecayParameters,\n} from \"./types\";\nexport {\n  ReceiverData, defaults, DRAWSTYLE, normalize,\n  SELF_INTERSECTION_OFFSET, DEFAULT_INTENSITY_SAMPLE_RATE, DEFAULT_INITIAL_SPL,\n  RESPONSE_TIME_PADDING, QUICK_ESTIMATE_MAX_ORDER, MAX_DISPLAY_POINTS, RT60_DECAY_RATIO,\n  HISTOGRAM_BIN_WIDTH, HISTOGRAM_NUM_BINS, CONVERGENCE_CHECK_INTERVAL_MS,\n  DEFAULT_TAIL_CROSSFADE_DURATION, MIN_TAIL_DECAY_RATE, MAX_TAIL_END_TIME,\n} from \"./types\";\n\n// Webpack 5 native worker support\nconst FilterWorker = () => new Worker(new URL('../../audio-engine/filter.worker.ts', import.meta.url));\n\nconst {floor, random, abs, asin} = Math;\nconst coinFlip = () => random() > 0.5;\n\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\nTHREE.Mesh.prototype.raycast = acceleratedRaycast;\n\nclass RayTracer extends Solver {\n  roomID: string;\n  sourceIDs: string[];\n  surfaceIDs: string[];\n  receiverIDs: string[];\n  updateInterval: number;\n  reflectionOrder: number;\n  raycaster: THREE.Raycaster;\n  intersections: THREE.Intersection[];\n  _isRunning: boolean;\n  intervals: number[];\n  rayBufferGeometry: THREE.BufferGeometry;\n  rayBufferAttribute: THREE.Float32BufferAttribute;\n  colorBufferAttribute: THREE.Float32BufferAttribute;\n  rays: THREE.LineSegments;\n  rayPositionIndex: number;\n  maxrays: number;\n  intersectableObjects: Array<THREE.Mesh | THREE.Object3D | Container>;\n  paths: KVP<RayPath[]>;\n  stats: KVP<Stat>;\n  messageHandlerIDs: string[][];\n  statsUpdatePeriod: number;\n  lastTime: number;\n  _runningWithoutReceivers: boolean;\n  frequencies: number[];\n  allReceiverData!: ReceiverData[];\n  hits: THREE.Points;\n  _pointSize: number;\n  chartdata: ChartData[];\n  passes: number;\n  _raysVisible: boolean;\n  _pointsVisible: boolean;\n  _invertedDrawStyle: boolean;\n  __start_time!: number;\n  __calc_time!: number;\n  __num_checked_paths!: number;\n  responseOverlayElement: HTMLElement;\n  quickEstimateResults: KVP<QuickEstimateStepResult[]>;\n  responseByIntensity!: KVP<KVP<ResponseByIntensity>>;\n  plotData: Plotly.Data[];\n  intensitySampleRate: number;\n  validRayCount: number;\n  plotStyle: Partial<PlotData>;\n  bvh!: BVH;\n  observed_name: Observable<string>;\n\n  _cachedAirAtt: number[];\n\n  hybrid: boolean;\n  transitionOrder: number;\n\n  convergenceThreshold: number;\n  autoStop: boolean;\n  rrThreshold: number;\n  convergenceMetrics!: ConvergenceMetrics;\n  _energyHistogram!: KVP<Float32Array[]>;\n  _histogramBinWidth: number;\n  _histogramNumBins: number;\n  _lastConvergenceCheck!: number;\n  _convergenceCheckInterval: number;\n\n  _directivityRefPressures?: Map<string, number[]>;\n  maxStoredPaths: number;\n  edgeDiffractionEnabled: boolean;\n  lateReverbTailEnabled: boolean;\n  tailCrossfadeTime: number;\n  tailCrossfadeDuration: number;\n  _edgeGraph: EdgeGraph | null;\n  gpuEnabled: boolean;\n  gpuBatchSize: number;\n  private _gpuRayTracer: GpuRayTracer | null = null;\n  private _gpuRunning: boolean = false;\n  private _rafId: number = 0;\n\n  // Binaural output properties\n  hrtfSubjectId: string;\n  headYaw: number;\n  headPitch: number;\n  headRoll: number;\n  binauralImpulseResponse?: AudioBuffer;\n  binauralPlaying: boolean = false;\n\n  constructor(params?: RayTracerParams) {\n    super(params);\n    this.kind = \"ray-tracer\";\n    params = {    ...defaults, ...params    };\n    this.uuid = params.uuid || this.uuid;\n    this.name = params.name || defaults.name;\n    this.observed_name = observe(this.name);\n    this.responseOverlayElement = document.querySelector(\"#response-overlay\") || document.createElement(\"div\");\n    this.responseOverlayElement.style.backgroundColor = \"#FFFFFF\";\n    this.sourceIDs = params.sourceIDs || defaults.sourceIDs;\n    this.surfaceIDs = params.surfaceIDs || defaults.surfaceIDs;\n    this.roomID = params.roomID || defaults.roomID;\n    this.receiverIDs = params.receiverIDs || defaults.receiverIDs;\n    this.updateInterval = params.updateInterval || defaults.updateInterval;\n    this.reflectionOrder = params.reflectionOrder || defaults.reflectionOrder;\n    this._isRunning = params.isRunning || defaults.isRunning;\n    this._runningWithoutReceivers = params.runningWithoutReceivers || defaults.runningWithoutReceivers;\n    this.frequencies = params.frequencies || defaults.frequencies;\n    this._cachedAirAtt = ac.airAttenuation(this.frequencies, this.temperature);\n    this.intervals = [] as number[];\n    this.plotData = [] as Plotly.Data[];\n    this.plotStyle = params.plotStyle || defaults.plotStyle;\n    this.lastTime = Date.now();\n    this.statsUpdatePeriod = 100;\n    this._pointSize = params.pointSize || defaults.pointSize;\n    this.validRayCount = 0;\n    this.intensitySampleRate = DEFAULT_INTENSITY_SAMPLE_RATE;\n    this.quickEstimateResults = {} as KVP<QuickEstimateStepResult[]>;\n\n    const paramsHasRaysVisible = typeof params.raysVisible === \"boolean\";\n    this._raysVisible = paramsHasRaysVisible ? params.raysVisible! : defaults.raysVisible;\n\n    const paramsHasPointsVisible = typeof params.pointsVisible === \"boolean\";\n    this._pointsVisible = paramsHasPointsVisible ? params.pointsVisible! : defaults.pointsVisible;\n\n    const paramsHasInvertedDrawStyle = typeof params.invertedDrawStyle === \"boolean\";\n    this._invertedDrawStyle = paramsHasInvertedDrawStyle ? params.invertedDrawStyle! : defaults.invertedDrawStyle;\n\n    this.passes = params.passes || defaults.passes;\n    this.raycaster = new THREE.Raycaster();\n    this.rayBufferGeometry = new THREE.BufferGeometry();\n    this.rayBufferGeometry.name = \"raytracer-ray-buffer-geometry\";\n    this.maxrays = 1e6 - 1;\n    this.rayBufferAttribute = new THREE.Float32BufferAttribute(new Float32Array(this.maxrays), 3);\n    this.rayBufferAttribute.setUsage(THREE.DynamicDrawUsage);\n    this.rayBufferGeometry.setAttribute(\"position\", this.rayBufferAttribute);\n    this.rayBufferGeometry.setDrawRange(0, this.maxrays);\n    this.colorBufferAttribute = new THREE.Float32BufferAttribute(new Float32Array(this.maxrays), 2);\n    this.colorBufferAttribute.setUsage(THREE.DynamicDrawUsage);\n    this.rayBufferGeometry.setAttribute(\"color\", this.colorBufferAttribute);\n    this.chartdata = [] as ChartData[];\n\n    this.hybrid = false;\n    this.transitionOrder = 2;\n\n    this.convergenceThreshold = params.convergenceThreshold ?? defaults.convergenceThreshold;\n    this.autoStop = params.autoStop ?? defaults.autoStop;\n    this.rrThreshold = params.rrThreshold ?? defaults.rrThreshold;\n    this.maxStoredPaths = params.maxStoredPaths ?? defaults.maxStoredPaths;\n    this.edgeDiffractionEnabled = params.edgeDiffractionEnabled ?? defaults.edgeDiffractionEnabled;\n    this.lateReverbTailEnabled = params.lateReverbTailEnabled ?? defaults.lateReverbTailEnabled;\n    this.tailCrossfadeTime = params.tailCrossfadeTime ?? defaults.tailCrossfadeTime;\n    this.tailCrossfadeDuration = params.tailCrossfadeDuration ?? defaults.tailCrossfadeDuration;\n    this.gpuEnabled = params.gpuEnabled ?? defaults.gpuEnabled;\n    this.gpuBatchSize = params.gpuBatchSize ?? defaults.gpuBatchSize;\n    this.hrtfSubjectId = params.hrtfSubjectId ?? \"D1\";\n    this.headYaw = params.headYaw ?? 0;\n    this.headPitch = params.headPitch ?? 0;\n    this.headRoll = params.headRoll ?? 0;\n    this._edgeGraph = null;\n    this._histogramBinWidth = HISTOGRAM_BIN_WIDTH;\n    this._histogramNumBins = HISTOGRAM_NUM_BINS;\n    this._convergenceCheckInterval = CONVERGENCE_CHECK_INTERVAL_MS;\n    this._resetConvergenceState();\n\n    this.rays = new THREE.LineSegments(\n      this.rayBufferGeometry,\n      new THREE.LineBasicMaterial({\n        fog: false,\n        color: 0x282929,\n        transparent: true,\n        opacity: 0.2,\n        premultipliedAlpha: true,\n        blending: THREE.NormalBlending,\n        depthFunc: THREE.AlwaysDepth,\n        name: \"raytracer-rays-material\"\n        // depthTest: false\n      })\n    );\n    this.rays.renderOrder = -0.5;\n    this.rays.frustumCulled = false;\n    renderer.scene.add(this.rays);\n\n    var shaderMaterial = new THREE.ShaderMaterial({\n      fog: false,\n      vertexShader: PointShader.vs,\n      fragmentShader: PointShader.fs,\n      transparent: true,\n      premultipliedAlpha: true,\n      uniforms: {\n        drawStyle: { value: DRAWSTYLE.ENERGY },\n        inverted: { value: 0.0 },\n        pointScale: { value: this._pointSize }\n      },\n      blending: THREE.NormalBlending,\n      name: \"raytracer-points-material\"\n    });\n    // var pointsMaterial = new THREE.PointsMaterial({fog:false,\n    //   color: 0xff0000,\n    //   transparent: true,\n    //   opacity: 0.2,\n    //   premultipliedAlpha: true,\n    //   blending: THREE.NormalBlending\n    // });\n    this.hits = new THREE.Points(this.rayBufferGeometry, shaderMaterial);\n    this.hits.frustumCulled = false;\n    renderer.scene.add(this.hits);\n    this.rayPositionIndex = 0;\n    Object.defineProperty(this.raycaster, \"firstHitOnly\", {\n      value: true,\n      writable: true\n    });\n\n    // raycaster.intersectObjects([mesh]);\n    this.intersections = [] as THREE.Intersection[];\n    this.findIDs();\n    this.intersectableObjects = [] as Array<THREE.Mesh | THREE.Object3D | Container>;\n    this.paths = params.paths || defaults.paths;\n    this.stats = {\n      numRaysShot: {\n        name: \"# of rays shot\",\n        value: 0\n      },\n      numValidRayPaths: {\n        name: \"# of valid rays\",\n        value: 0\n      }\n    };\n    renderer.overlays.global.addCell(\"Valid Rays\", this.validRayCount, {\n      id: this.uuid + \"-valid-ray-count\",\n      hidden: true,\n      formatter: (value) => String(value)\n    });\n    this.messageHandlerIDs = [] as string[][];\n    messenger.postMessage(\"STATS_SETUP\", this.stats);\n    this.messageHandlerIDs.push(\n      messenger.addMessageHandler(\"RAYTRACER_SOURCE_CHANGE\", (acc, ...args) => {\n        console.log(args && args[0] && args[0] instanceof Array && args[1] && args[1] === this.uuid);\n        if (args && args[0] && args[0] instanceof Array && args[1] && args[1] === this.uuid) {\n          this.sourceIDs = args[0].map((x) => x.id);\n        }\n      })\n    );\n    this.messageHandlerIDs.push(\n      messenger.addMessageHandler(\"RAYTRACER_RECEIVER_CHANGE\", (acc, ...args) => {\n        if (args && args[0] && args[0] instanceof Array && args[1] && args[1] === this.uuid) {\n          this.receiverIDs = args[0].map((x) => x.id);\n        }\n      })\n    );\n    this.messageHandlerIDs.push(\n      messenger.addMessageHandler(\"SHOULD_REMOVE_CONTAINER\", (acc, ...args) => {\n        const id = args[0] as string;\n        if (id) {\n          console.log(id);\n          if (this.sourceIDs.includes(id)) {\n            this.sourceIDs = this.sourceIDs.filter((x) => x != id);\n          } else if (this.receiverIDs.includes(id)) {\n            this.receiverIDs = this.receiverIDs.filter((x) => x != id);\n          }\n        }\n      })\n    );\n    this.step = this.step.bind(this);\n    this.calculateImpulseResponse = this.calculateImpulseResponse.bind(this);\n  }\n  update = () => {};\n  get temperature(): number {\n    return this.room?.temperature ?? 20;\n  }\n  get c(): number {\n    return ac.soundSpeed(this.temperature);\n  }\n\n  save() {\n    const {\n      name,\n      kind,\n      uuid,\n      autoCalculate,\n      roomID,\n      sourceIDs,\n      surfaceIDs,\n      receiverIDs,\n      updateInterval,\n      passes,\n      pointSize,\n      reflectionOrder,\n      runningWithoutReceivers,\n      raysVisible,\n      pointsVisible,\n      invertedDrawStyle,\n      plotStyle,\n      paths,\n      frequencies,\n      convergenceThreshold,\n      autoStop,\n      rrThreshold,\n      maxStoredPaths,\n      edgeDiffractionEnabled,\n      lateReverbTailEnabled,\n      tailCrossfadeTime,\n      tailCrossfadeDuration,\n      gpuEnabled,\n      gpuBatchSize,\n      hrtfSubjectId,\n      headYaw,\n      headPitch,\n      headRoll,\n    } = this;\n    return {\n      name,\n      kind,\n      uuid,\n      autoCalculate,\n      roomID,\n      sourceIDs,\n      surfaceIDs,\n      receiverIDs,\n      updateInterval,\n      passes,\n      pointSize,\n      reflectionOrder,\n      runningWithoutReceivers,\n      raysVisible,\n      pointsVisible,\n      invertedDrawStyle,\n      plotStyle,\n      paths,\n      frequencies,\n      convergenceThreshold,\n      autoStop,\n      rrThreshold,\n      maxStoredPaths,\n      edgeDiffractionEnabled,\n      lateReverbTailEnabled,\n      tailCrossfadeTime,\n      tailCrossfadeDuration,\n      gpuEnabled,\n      gpuBatchSize,\n      hrtfSubjectId,\n      headYaw,\n      headPitch,\n      headRoll,\n    };\n  }\n\n\n\n  removeMessageHandlers() {\n    this.messageHandlerIDs.forEach((x) => {\n      messenger.removeMessageHandler(x[0], x[1]);\n    });\n  }\n  dispose() {\n    // Stop any running loops before tearing down resources\n    if (this._isRunning) {\n      this._isRunning = false;\n      this._gpuRunning = false;\n      cancelAnimationFrame(this._rafId);\n      this._rafId = 0;\n      this.intervals.forEach((interval) => window.clearInterval(interval));\n      this.intervals = [] as number[];\n    }\n    this._disposeGpu();\n    this.removeMessageHandlers();\n    Object.keys(window.vars).forEach(key=>{\n      if(window.vars[key]['uuid']===this.uuid){\n        delete window.vars[key];\n      }\n    })\n    renderer.scene.remove(this.rays);\n    renderer.scene.remove(this.hits);\n  }\n  addSource(source: Source) {\n    useContainer.getState().containers[source.uuid] = source;\n    this.findIDs();\n    this.mapIntersectableObjects();\n  }\n  addReceiver(rec: Receiver) {\n    useContainer.getState().containers[rec.uuid] = rec;\n    this.findIDs();\n    this.mapIntersectableObjects();\n  }\n\n  mapIntersectableObjects() {\n    const surfaces = [] as THREE.Mesh[];\n\n    this.room.surfaces.traverse((container)=>{\n      if(container['kind'] && container['kind'] === 'surface'){\n        surfaces.push((container as Surface).mesh);\n      }\n    });\n\n    if (this.runningWithoutReceivers) {\n      this.intersectableObjects = surfaces;\n    } else {\n      this.intersectableObjects = surfaces.concat(this.receivers);\n    }\n  }\n\n  findIDs() {\n    this.sourceIDs = [];\n    this.receiverIDs = [];\n    this.surfaceIDs = [];\n    for (const key in useContainer.getState().containers) {\n      if (useContainer.getState().containers[key].kind === \"room\") {\n        this.roomID = key;\n      } else if (useContainer.getState().containers[key].kind === \"source\") {\n        this.sourceIDs.push(key);\n      } else if (useContainer.getState().containers[key].kind === \"receiver\") {\n        this.receiverIDs.push(key);\n      } else if (useContainer.getState().containers[key].kind === \"surface\") {\n        this.surfaceIDs.push(key);\n      }\n    }\n    this.mapIntersectableObjects();\n  }\n\n  setDrawStyle(drawStyle: number) {\n    (this.hits.material as THREE.ShaderMaterial).uniforms[\"drawStyle\"].value = drawStyle;\n    (this.hits.material as THREE.ShaderMaterial).needsUpdate = true;\n    renderer.needsToRender = true;\n  }\n\n  setPointScale(scale: number) {\n    this._pointSize = scale;\n    (this.hits.material as THREE.ShaderMaterial).uniforms[\"pointScale\"].value = this._pointSize;\n    (this.hits.material as THREE.ShaderMaterial).needsUpdate = true;\n    renderer.needsToRender = true;\n  }\n\n  incrementRayPositionIndex() {\n    if (this.rayPositionIndex < this.maxrays) {\n      return this.rayPositionIndex++;\n    } else {\n      this.rayPositionIndex = 0;\n      this.rayPositionIndexDidOverflow = true;\n      return this.rayPositionIndex;\n    }\n  }\n  rayPositionIndexDidOverflow = false;\n  appendRay(p1: [number, number, number], p2: [number, number, number], energy: number = 1.0, angle: number = 1.0) {\n    // set p1\n    this.rayBufferAttribute.setXYZ(this.incrementRayPositionIndex(), p1[0], p1[1], p1[2]);\n\n    // set the color\n    this.colorBufferAttribute.setXY(this.rayPositionIndex, energy, angle);\n\n    // set p2\n    this.rayBufferAttribute.setXYZ(this.incrementRayPositionIndex(), p2[0], p2[1], p2[2]);\n\n    // set the color\n    this.colorBufferAttribute.setXY(this.rayPositionIndex, energy, angle);\n\n    //update the draw range\n    this.rayBufferGeometry.setDrawRange(0, this.rayPositionIndexDidOverflow ? this.maxrays : this.rayPositionIndex);\n  }\n\n  flushRayBuffer() {\n    this.rayBufferAttribute.needsUpdate = true;\n    this.rayBufferAttribute.version++;\n    this.colorBufferAttribute.needsUpdate = true;\n    this.colorBufferAttribute.version++;\n  }\n\n  inFrontOf(a: THREE.Triangle, b: THREE.Triangle) {\n    return inFrontOfFn(a, b);\n  }\n\n  traceRay(\n    ro: THREE.Vector3,\n    rd: THREE.Vector3,\n    order: number,\n    bandEnergy: BandEnergy,\n    source: string,\n    initialPhi: number,\n    initialTheta: number,\n    iter: number = 1,\n    chain: Partial<Chain>[] = [],\n  ) {\n    return traceRayFn(\n      this.raycaster, this.intersectableObjects, this.frequencies,\n      this._cachedAirAtt, this.rrThreshold,\n      ro, rd, order, bandEnergy, source, initialPhi, initialTheta, iter, chain,\n    );\n  }\n\n  startQuickEstimate(frequencies: number[] = this.frequencies, numRays: number = 1000) {\n    const tempRunningWithoutReceivers = this.runningWithoutReceivers;\n    this.runningWithoutReceivers = true;\n    let count = 0;\n    this.quickEstimateResults = {} as KVP<QuickEstimateStepResult[]>;\n    this.sourceIDs.forEach((id) => {\n      this.quickEstimateResults[id] = [] as QuickEstimateStepResult[];\n    });\n    let done = false;\n    this.intervals.push(\n      window.setInterval(() => {\n        for (let i = 0; i < this.passes; i++, count++) {\n          for (let j = 0; j < this.sourceIDs.length; j++) {\n            const id = this.sourceIDs[j];\n            const source = useContainer.getState().containers[id] as Source;\n            this.quickEstimateResults[id].push(this.quickEstimateStep(source, frequencies, numRays));\n          }\n        }\n        if (count >= numRays) {\n          done = true;\n          this.intervals.forEach((interval) => window.clearInterval(interval));\n          this.runningWithoutReceivers = tempRunningWithoutReceivers;\n          console.log(this.quickEstimateResults);\n        } else {\n          console.log(((count / numRays) * 100).toFixed(1) + \"%\");\n        }\n      }, this.updateInterval)\n    );\n  }\n  quickEstimateStep(source: Source, frequencies: number[], numRays: number) {\n    const result = sharedQuickEstimateStep(\n      this.raycaster, this.intersectableObjects,\n      source.position, source.initialIntensity,\n      frequencies, this.temperature\n    );\n    (this.stats.numRaysShot.value as number)++;\n    return result;\n  }\n\n  startAllMonteCarlo() {\n    this._lastConvergenceCheck = Date.now();\n    if (this._rafId) {\n      cancelAnimationFrame(this._rafId);\n      this._rafId = 0;\n    }\n    const tick = () => {\n      if (!this._isRunning) return;\n\n      // Time-budgeted batching: trace as many batches as fit in ~12ms\n      const budgetMs = 12;\n      const start = performance.now();\n      do {\n        this.stepStratified(this.passes);\n      } while (performance.now() - start < budgetMs);\n\n      this.flushRayBuffer();\n      renderer.needsToRender = true;\n\n      // Periodic convergence check\n      const now = Date.now();\n      if (this.autoStop && now - this._lastConvergenceCheck >= this._convergenceCheckInterval) {\n        this._lastConvergenceCheck = now;\n        this._updateConvergenceMetrics();\n        if (this.convergenceMetrics.convergenceRatio < this.convergenceThreshold\n            && this.convergenceMetrics.t30Count >= 3) {\n          this.isRunning = false;\n          return;\n        }\n      }\n      this._rafId = requestAnimationFrame(tick);\n    };\n    this._rafId = requestAnimationFrame(tick);\n  }\n\n  stepStratified(numRays: number) {\n    if (numRays <= 0) return;\n\n    // Choose stratification dimensions such that nPhi * nTheta === numRays.\n    // Start from sqrt(numRays) and search downward for a divisor.\n    let nPhi = Math.floor(Math.sqrt(numRays));\n    while (nPhi > 1 && numRays % nPhi !== 0) {\n      nPhi--;\n    }\n    const nTheta = numRays / nPhi;\n\n    for (let i = 0; i < this.sourceIDs.length; i++) {\n      const source = useContainer.getState().containers[this.sourceIDs[i]] as Source;\n      const sourcePhi = source.phi;\n      const sourceTheta = source.theta;\n      const position = source.position;\n      const rotation = source.rotation;\n      const sourceDH = source.directivityHandler;\n\n      // cache on-axis reference pressures per source\n      if (!this._directivityRefPressures) {\n        this._directivityRefPressures = new Map();\n      }\n      const sourceId = this.sourceIDs[i];\n      let refPressures = this._directivityRefPressures.get(sourceId);\n      if (!refPressures || refPressures.length !== this.frequencies.length) {\n        refPressures = new Array(this.frequencies.length);\n        for (let f = 0; f < this.frequencies.length; f++) {\n          refPressures[f] = sourceDH.getPressureAtPosition(0, this.frequencies[f], 0, 0) as number;\n        }\n        this._directivityRefPressures.set(sourceId, refPressures);\n      }\n\n      for (let si = 0; si < nPhi; si++) {\n        for (let sj = 0; sj < nTheta; sj++) {\n          this.__num_checked_paths += 1;\n\n          // stratified jittered angles within the source directivity limits\n          const phi = ((si + Math.random()) / nPhi) * sourcePhi;\n          const theta = ((sj + Math.random()) / nTheta) * sourceTheta;\n\n          let threeJSAngles: number[] = cramangle2threejsangle(phi, theta);\n          const direction = new THREE.Vector3().setFromSphericalCoords(1, threeJSAngles[0], threeJSAngles[1]);\n          direction.applyEuler(rotation);\n\n          const initialBandEnergy: BandEnergy = new Array(this.frequencies.length);\n          for (let f = 0; f < this.frequencies.length; f++) {\n            let energy = 1;\n            try {\n              const dirPressure = sourceDH.getPressureAtPosition(0, this.frequencies[f], phi, theta);\n              const refPressure = refPressures[f];\n              if (typeof dirPressure === \"number\" && typeof refPressure === \"number\" && refPressure > 0) {\n                energy = (dirPressure / refPressure) ** 2;\n              }\n            } catch (e) {\n              // Fallback to unity gain\n            }\n            initialBandEnergy[f] = energy;\n          }\n\n          const path = this.traceRay(position, direction, this.reflectionOrder, initialBandEnergy, sourceId, phi, theta);\n\n          if (path) {\n            this._handleTracedPath(path, position, sourceId);\n          }\n\n          (this.stats.numRaysShot.value as number)++;\n        }\n      }\n    }\n  }\n\n  /** Common path handling for both step() and stepStratified() */\n  _handleTracedPath(path: RayPath, position: THREE.Vector3, sourceId: string) {\n    if (this._runningWithoutReceivers) {\n      this.appendRay(\n        [position.x, position.y, position.z],\n        path.chain[0].point,\n        path.chain[0].energy || 1.0,\n        path.chain[0].angle\n      );\n      for (let j = 1; j < path.chain.length; j++) {\n        this.appendRay(path.chain[j - 1].point, path.chain[j].point, path.chain[j].energy || 1.0, path.chain[j].angle);\n      }\n      const index = path.chain[path.chain.length - 1].object;\n      this._pushPathWithEviction(index, path);\n      (useContainer.getState().containers[sourceId] as Source).numRays += 1;\n    } else if (path.intersectedReceiver) {\n      this.appendRay(\n        [position.x, position.y, position.z],\n        path.chain[0].point,\n        path.chain[0].energy || 1.0,\n        path.chain[0].angle\n      );\n      for (let j = 1; j < path.chain.length; j++) {\n        this.appendRay(path.chain[j - 1].point, path.chain[j].point, path.chain[j].energy || 1.0, path.chain[j].angle);\n      }\n      (this.stats.numValidRayPaths.value as number)++;\n      this.validRayCount += 1;\n      renderer.overlays.global.setCellValue(this.uuid + \"-valid-ray-count\", this.validRayCount);\n      const receiverId = path.chain[path.chain.length - 1].object;\n      this._pushPathWithEviction(receiverId, path);\n      (useContainer.getState().containers[sourceId] as Source).numRays += 1;\n\n      // Update energy histogram for convergence monitoring\n      this._addToEnergyHistogram(receiverId, path);\n    }\n  }\n\n  /** Push a path onto the paths array, evicting oldest if over maxStoredPaths */\n  _pushPathWithEviction(index: string, path: RayPath) {\n    const cap = Math.max(1, this.maxStoredPaths | 0);\n    if (!this.paths[index]) {\n      this.paths[index] = [path];\n      return;\n    }\n    const arr = this.paths[index];\n    if (arr.length >= cap) {\n      const overflow = arr.length - cap + 1;\n      if (overflow > 0) {\n        arr.splice(0, overflow);\n      }\n    }\n    arr.push(path);\n  }\n\n  /** Add a ray path's energy to the convergence histogram */\n  _addToEnergyHistogram(receiverId: string, path: RayPath) {\n    addToEnergyHistogram(this._energyHistogram, receiverId, path, this.frequencies, this.c, this._histogramBinWidth, this._histogramNumBins);\n  }\n\n  step() {\n    for (let i = 0; i < this.sourceIDs.length; i++) {\n      this.__num_checked_paths += 1;\n\n      // random theta within the sources theta limits (0 to 180)\n      const theta = (Math.random()) * (useContainer.getState().containers[this.sourceIDs[i]] as Source).theta;\n\n      // random phi within the sources phi limits (0 to 360)\n      const phi = (Math.random()) * (useContainer.getState().containers[this.sourceIDs[i]] as Source).phi;\n\n      // source position\n      const position = (useContainer.getState().containers[this.sourceIDs[i]] as Source).position;\n\n      // source rotation\n      const rotation = (useContainer.getState().containers[this.sourceIDs[i]] as Source).rotation;\n\n      // random direction\n      // const direction = new THREE.Vector3(0.75, Math.random() - 0.5, Math.random() - 0.5);\n      let threeJSAngles: number[] = cramangle2threejsangle(phi, theta); // [phi, theta]\n      const direction = new THREE.Vector3().setFromSphericalCoords(1, threeJSAngles[0], threeJSAngles[1]);\n      direction.applyEuler(rotation);\n\n      // assign source energy as a function of direction\n      const sourceDH = (useContainer.getState().containers[this.sourceIDs[i]] as Source).directivityHandler;\n\n      // cache on-axis reference pressures per source (constant for all rays from same source)\n      if (!this._directivityRefPressures) {\n        this._directivityRefPressures = new Map();\n      }\n      const sourceId = this.sourceIDs[i];\n      let refPressures = this._directivityRefPressures.get(sourceId);\n      if (!refPressures || refPressures.length !== this.frequencies.length) {\n        refPressures = new Array(this.frequencies.length);\n        for (let f = 0; f < this.frequencies.length; f++) {\n          refPressures[f] = sourceDH.getPressureAtPosition(0, this.frequencies[f], 0, 0) as number;\n        }\n        this._directivityRefPressures.set(sourceId, refPressures);\n      }\n\n      const initialBandEnergy: BandEnergy = new Array(this.frequencies.length);\n      for (let f = 0; f < this.frequencies.length; f++) {\n        let energy = 1;\n        try {\n          const dirPressure = sourceDH.getPressureAtPosition(0, this.frequencies[f], phi, theta);\n          const refPressure = refPressures[f];\n          if (typeof dirPressure === \"number\" && typeof refPressure === \"number\" && refPressure > 0) {\n            energy = (dirPressure / refPressure) ** 2;\n          }\n        } catch (e) {\n          // Fallback to unity gain if directivity data is missing or lookup fails\n        }\n        initialBandEnergy[f] = energy;\n      }\n\n      // get the path traced by the ray\n      const path = this.traceRay(position, direction, this.reflectionOrder, initialBandEnergy, this.sourceIDs[i], phi, theta);\n\n      // if path exists\n      if (path) {\n        //  ignoring receiver intersections\n        if (this._runningWithoutReceivers) {\n          // add the first ray onto the buffer\n          this.appendRay(\n            [position.x, position.y, position.z],\n            path.chain[0].point,\n            path.chain[0].energy || 1.0,\n            path.chain[0].angle\n          );\n\n          // add the rest of the rays onto the buffer\n          for (let j = 1; j < path.chain.length; j++) {\n            // starting at i=1 to avoid an if statement in here\n            this.appendRay(\n              // the previous point\n              path.chain[j - 1].point,\n\n              // the current point\n              path.chain[j].point,\n\n              // the energy content displayed as a color + alpha\n              path.chain[j].energy || 1.0,\n              path.chain[j].angle\n            );\n          }\n\n          // get the uuid of the intersected receiver that way we can filter by receiver\n          const index = path.chain[path.chain.length - 1].object;\n\n          // if the receiver uuid is already defined, push the path on, else define it\n          this._pushPathWithEviction(index, path);\n\n          // increment the sources ray counter\n          (useContainer.getState().containers[this.sourceIDs[i]] as Source).numRays += 1;\n        }\n\n        //  if we are checking receiver intersections\n        else if (path[\"intersectedReceiver\"]) {\n          // add the ray to the buffer\n          this.appendRay(\n            [position.x, position.y, position.z],\n            path.chain[0].point,\n            path.chain[0].energy || 1.0,\n            path.chain[0].angle\n          );\n\n          // add the rest of the rays\n          for (let i = 1; i < path.chain.length; i++) {\n            this.appendRay(\n              // the previous point\n              path.chain[i - 1].point,\n\n              // the current point\n              path.chain[i].point,\n\n              // the energy content displayed as a color + alpha\n              path.chain[i].energy || 1.0,\n              path.chain[i].angle\n            );\n          }\n          (this.stats.numValidRayPaths.value as number)++;\n          this.validRayCount += 1;\n          renderer.overlays.global.setCellValue(this.uuid + \"-valid-ray-count\", this.validRayCount);\n          const index = path.chain[path.chain.length - 1].object;\n          this._pushPathWithEviction(index, path);\n\n          // increment the sources ray counter\n          (useContainer.getState().containers[this.sourceIDs[i]] as Source).numRays += 1;\n        }\n      }\n\n      (this.stats.numRaysShot.value as number)++;\n    }\n  }\n\n  /** Reset convergence state for a new simulation run */\n  _resetConvergenceState() {\n    const state = resetConvergenceState(this.frequencies.length);\n    this.convergenceMetrics = state.convergenceMetrics;\n    this._energyHistogram = state.energyHistogram;\n    this._lastConvergenceCheck = state.lastConvergenceCheck;\n  }\n\n  /** Compute T30 from Schroeder backward integration of the energy histogram */\n  _updateConvergenceMetrics() {\n    updateConvergenceMetrics(\n      this.convergenceMetrics, this._energyHistogram, this.frequencies,\n      this.receiverIDs, this.__num_checked_paths, this.validRayCount,\n      this._histogramBinWidth, this._histogramNumBins, this.uuid\n    );\n  }\n\n  start() {\n    this._isRunning = true;\n    this._cachedAirAtt = ac.airAttenuation(this.frequencies, this.temperature);\n    this.mapIntersectableObjects();\n    if (this.edgeDiffractionEnabled && this.room) {\n      this._edgeGraph = buildEdgeGraph(this.room.allSurfaces);\n    } else {\n      this._edgeGraph = null;\n    }\n    this.__start_time = Date.now();\n    this.__num_checked_paths = 0;\n    this._resetConvergenceState();\n\n    if (this.gpuEnabled) {\n      this._startGpuMonteCarlo();\n    } else {\n      this.startAllMonteCarlo();\n    }\n  }\n\n  stop() {\n    this._isRunning = false;\n    this.__calc_time = Date.now() - this.__start_time;\n    this._gpuRunning = false;\n    // Defer GPU disposal to let any in-flight traceBatch/mapAsync settle,\n    // avoiding WebGPU validation errors from destroying mid-await buffers.\n    if (this._gpuRayTracer) {\n      setTimeout(() => this._disposeGpu(), 0);\n    }\n    cancelAnimationFrame(this._rafId);\n    this._rafId = 0;\n    this.intervals.forEach((interval) => {\n      window.clearInterval(interval);\n    });\n    this.intervals = [] as number[];\n    Object.keys(this.paths).forEach((key) => {\n      const calc_time = this.__calc_time / 1000;\n      const num_valid_rays = this.paths[key].length;\n      const valid_ray_rate = num_valid_rays / calc_time;\n      const num_checks = this.__num_checked_paths;\n      const check_rate = num_checks / calc_time;\n      console.log({\n        calc_time,\n        num_valid_rays,\n        valid_ray_rate,\n        num_checks,\n        check_rate\n      });\n      this.paths[key].forEach((p) => {\n        p.time = 0;\n        p.totalLength = 0;\n        for (let i = 0; i < p.chain.length; i++) {\n          p.totalLength += p.chain[i].distance;\n          p.time += p.chain[i].distance / this.c;\n        }\n      });\n    });\n    if (this.edgeDiffractionEnabled && this._edgeGraph && this._edgeGraph.edges.length > 0) {\n      this._computeDiffractionPaths();\n    }\n    this.mapIntersectableObjects();\n    this.reportImpulseResponse();\n  }\n\n  /** Compute deterministic diffraction paths and inject them into this.paths[] */\n  _computeDiffractionPaths() {\n    if (!this._edgeGraph) return;\n\n    const containers = useContainer.getState().containers;\n\n    // Gather source positions and directivity data\n    const sourcePositions = new Map<string, [number, number, number]>();\n    const sourceDirectivity = new Map<string, { handler: any; refPressures: number[] }>();\n    for (const id of this.sourceIDs) {\n      const src = containers[id] as Source;\n      if (src) {\n        sourcePositions.set(id, [src.position.x, src.position.y, src.position.z]);\n        // Cache reference pressures for directivity\n        const dh = src.directivityHandler;\n        const refPressures = new Array(this.frequencies.length);\n        for (let f = 0; f < this.frequencies.length; f++) {\n          refPressures[f] = dh.getPressureAtPosition(0, this.frequencies[f], 0, 0) as number;\n        }\n        sourceDirectivity.set(id, { handler: dh, refPressures });\n      }\n    }\n\n    // Gather receiver positions\n    const receiverPositions = new Map<string, [number, number, number]>();\n    for (const id of this.receiverIDs) {\n      const rec = containers[id];\n      if (rec) {\n        receiverPositions.set(id, [rec.position.x, rec.position.y, rec.position.z]);\n      }\n    }\n\n    // Get surface meshes for LOS checks (exclude receivers)\n    const surfaces: THREE.Mesh[] = [];\n    this.room.surfaces.traverse((container) => {\n      if (container['kind'] && container['kind'] === 'surface') {\n        surfaces.push((container as Surface).mesh);\n      }\n    });\n\n    const diffractionPaths = findDiffractionPaths(\n      this._edgeGraph,\n      sourcePositions,\n      receiverPositions,\n      this.frequencies,\n      this.c,\n      this.temperature,\n      this.raycaster,\n      surfaces,\n    );\n\n    // Convert DiffractionPath → RayPath and inject into this.paths[]\n    for (const dp of diffractionPaths) {\n      // Apply source directivity to band energies\n      const srcDir = sourceDirectivity.get(dp.sourceId);\n      if (srcDir) {\n        const srcPos = sourcePositions.get(dp.sourceId)!;\n        // Direction from source to diffraction point\n        const dx = dp.diffractionPoint[0] - srcPos[0];\n        const dy = dp.diffractionPoint[1] - srcPos[1];\n        const dz = dp.diffractionPoint[2] - srcPos[2];\n        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (dist > 1e-10) {\n          // Compute spherical angles in source frame (approximate)\n          const theta = Math.acos(Math.max(-1, Math.min(1, dy / dist))) * (180 / Math.PI);\n          const phi = Math.atan2(dz, dx) * (180 / Math.PI);\n          for (let f = 0; f < this.frequencies.length; f++) {\n            try {\n              const dirP = srcDir.handler.getPressureAtPosition(0, this.frequencies[f], Math.abs(phi), theta);\n              const refP = srcDir.refPressures[f];\n              if (typeof dirP === \"number\" && typeof refP === \"number\" && refP > 0) {\n                dp.bandEnergy[f] *= (dirP / refP) ** 2;\n              }\n            } catch (e) {\n              // Fallback to unity gain\n            }\n          }\n        }\n      }\n\n      // Compute mean energy across bands (consistent with ray-core.ts)\n      const meanEnergy = dp.bandEnergy.reduce((a, b) => a + b, 0) / dp.bandEnergy.length;\n\n      // Compute arrival direction: edge→receiver (normalized)\n      const recPos = receiverPositions.get(dp.receiverId)!;\n      const adx = recPos[0] - dp.diffractionPoint[0];\n      const ady = recPos[1] - dp.diffractionPoint[1];\n      const adz = recPos[2] - dp.diffractionPoint[2];\n      const adLen = Math.sqrt(adx * adx + ady * ady + adz * adz);\n      const arrivalDirection: [number, number, number] = adLen > 1e-10\n        ? [adx / adLen, ady / adLen, adz / adLen]\n        : [0, 0, 1];\n\n      // Compute individual leg distances for chain\n      const srcPos = sourcePositions.get(dp.sourceId)!;\n      const sDist = Math.sqrt(\n        (dp.diffractionPoint[0] - srcPos[0]) ** 2 +\n        (dp.diffractionPoint[1] - srcPos[1]) ** 2 +\n        (dp.diffractionPoint[2] - srcPos[2]) ** 2\n      );\n      const rDist = dp.totalDistance - sDist;\n\n      const rayPath: RayPath = {\n        intersectedReceiver: true,\n        chain: [\n          {\n            distance: sDist,\n            point: dp.diffractionPoint,\n            object: dp.edge.surface0Id,\n            faceNormal: dp.edge.normal0,\n            faceIndex: -1,\n            faceMaterialIndex: -1,\n            angle: 0,\n            energy: meanEnergy,\n            bandEnergy: dp.bandEnergy,\n          },\n          {\n            distance: rDist,\n            point: recPos,\n            object: dp.receiverId,\n            faceNormal: [0, 0, 0],\n            faceIndex: -1,\n            faceMaterialIndex: -1,\n            angle: 0,\n            energy: meanEnergy,\n            bandEnergy: dp.bandEnergy,\n          },\n        ],\n        chainLength: 2,\n        energy: meanEnergy,\n        bandEnergy: dp.bandEnergy,\n        time: dp.time,\n        source: dp.sourceId,\n        initialPhi: 0,\n        initialTheta: 0,\n        totalLength: dp.totalDistance,\n        arrivalDirection,\n      };\n\n      this._pushPathWithEviction(dp.receiverId, rayPath);\n    }\n  }\n\n  async reportImpulseResponse() {\n    if (this.receiverIDs.length === 0 || this.sourceIDs.length === 0) return;\n\n    const containers = useContainer.getState().containers;\n    const sampleRate = audioEngine.sampleRate;\n\n    // Count total pairs to calculate progress\n    const pairs: Array<{ sourceId: string; receiverId: string; paths: RayPath[] }> = [];\n    for (const sourceId of this.sourceIDs) {\n      for (const receiverId of this.receiverIDs) {\n        if (!this.paths[receiverId] || this.paths[receiverId].length === 0) continue;\n        const pathsForPair = this.paths[receiverId].filter(p => p.source === sourceId);\n        if (pathsForPair.length > 0) {\n          pairs.push({ sourceId, receiverId, paths: pathsForPair });\n        }\n      }\n    }\n\n    if (pairs.length === 0) return;\n\n    // Show progress indicator\n    emit(\"SHOW_PROGRESS\", {\n      message: \"Calculating impulse response...\",\n      progress: 0,\n      solverUuid: this.uuid\n    });\n\n    // Calculate IR for each source-receiver pair\n    for (let i = 0; i < pairs.length; i++) {\n      const { sourceId, receiverId, paths: pathsForPair } = pairs[i];\n      const sourceName = containers[sourceId]?.name || 'Source';\n      const receiverName = containers[receiverId]?.name || 'Receiver';\n\n      // Update progress\n      const progressPercent = Math.round((i / pairs.length) * 100);\n      emit(\"UPDATE_PROGRESS\", {\n        progress: progressPercent,\n        message: `Calculating IR: ${sourceName} → ${receiverName}`\n      });\n\n      try {\n        const { normalizedSignal } = await this.calculateImpulseResponseForPair(sourceId, receiverId, pathsForPair);\n\n        // Also calculate the full impulse response for playback (first pair only)\n        if (sourceId === this.sourceIDs[0] && receiverId === this.receiverIDs[0]) {\n          this.calculateImpulseResponse().then(ir => {\n            this.impulseResponse = ir;\n          }).catch(console.error);\n        }\n\n        // Downsample for display (max 2000 points for performance)\n        const maxDisplayPoints = MAX_DISPLAY_POINTS;\n        const step = Math.max(1, Math.floor(normalizedSignal.length / maxDisplayPoints));\n        const displayData: { time: number; amplitude: number }[] = [];\n\n        for (let j = 0; j < normalizedSignal.length; j += step) {\n          displayData.push({\n            time: j / sampleRate,\n            amplitude: normalizedSignal[j]\n          });\n        }\n\n        // Use a deterministic UUID based on source/receiver pair so we update the same tab\n        const resultUuid = `${this.uuid}-ir-${sourceId}-${receiverId}`;\n\n        const existingResult = useResult.getState().results[resultUuid];\n\n        const result = {\n          kind: ResultKind.ImpulseResponse,\n          name: `IR: ${sourceName} → ${receiverName}`,\n          uuid: resultUuid,\n          from: this.uuid,\n          info: {\n            sampleRate,\n            sourceName,\n            receiverName,\n            sourceId,\n            receiverId\n          },\n          data: displayData\n        };\n\n        if (existingResult) {\n          // Update existing result\n          emit(\"UPDATE_RESULT\", { uuid: resultUuid, result });\n        } else {\n          // Add new result\n          emit(\"ADD_RESULT\", result);\n        }\n      } catch (err) {\n        console.error(`Failed to calculate impulse response for ${sourceId} -> ${receiverId}:`, err);\n      }\n    }\n\n    // Hide progress indicator\n    emit(\"HIDE_PROGRESS\", undefined);\n  }\n\n  async calculateImpulseResponseForPair(sourceId: string, receiverId: string, paths: RayPath[], initialSPL = DEFAULT_INITIAL_SPL, frequencies = this.frequencies, sampleRate = audioEngine.sampleRate): Promise<{ signal: Float32Array; normalizedSignal: Float32Array }> {\n    let tailOptions: TailOptions | undefined;\n    if (this.lateReverbTailEnabled && this._energyHistogram[receiverId]) {\n      tailOptions = {\n        energyHistogram: this._energyHistogram[receiverId],\n        crossfadeTime: this.tailCrossfadeTime,\n        crossfadeDuration: this.tailCrossfadeDuration,\n        histogramBinWidth: this._histogramBinWidth,\n        frequencies,\n      };\n    }\n    return calcIRForPairFn(sourceId, receiverId, paths, initialSPL, frequencies, this.temperature, sampleRate, tailOptions);\n  }\n\n  async calculateImpulseResponseForDisplay(initialSPL = DEFAULT_INITIAL_SPL, frequencies = this.frequencies, sampleRate = audioEngine.sampleRate): Promise<{ signal: Float32Array; normalizedSignal: Float32Array }> {\n    let tailOptions: TailOptions | undefined;\n    if (this.lateReverbTailEnabled && this.receiverIDs.length > 0 && this._energyHistogram[this.receiverIDs[0]]) {\n      tailOptions = {\n        energyHistogram: this._energyHistogram[this.receiverIDs[0]],\n        crossfadeTime: this.tailCrossfadeTime,\n        crossfadeDuration: this.tailCrossfadeDuration,\n        histogramBinWidth: this._histogramBinWidth,\n        frequencies,\n      };\n    }\n    return calcIRForDisplayFn(this.receiverIDs, this.sourceIDs, this.paths, initialSPL, frequencies, this.temperature, sampleRate, tailOptions);\n  }\n  clearRays() {\n    if (this.room) {\n      for (let i = 0; i < this.room.allSurfaces.length; i++) {\n        (this.room.allSurfaces[i] as Surface).resetHits();\n      }\n    }\n    this.validRayCount = 0;\n    renderer.overlays.global.setCellValue(this.uuid + \"-valid-ray-count\", this.validRayCount);\n    this.rayBufferGeometry.setDrawRange(0, 1);\n    this.rayPositionIndex = 0;\n    this.rayPositionIndexDidOverflow = false;\n    this.stats.numRaysShot.value = 0;\n    this.stats.numValidRayPaths.value = 0;\n    messenger.postMessage(\"STATS_UPDATE\", this.stats);\n    this.sourceIDs.forEach((x) => {\n      (useContainer.getState().containers[x] as Source).numRays = 0;\n    });\n    this.paths = {} as KVP<RayPath[]>;\n    this.mapIntersectableObjects();\n    renderer.needsToRender = true;\n\n    // Clear the stored impulse response and update any existing IR results to show empty state\n    this.impulseResponse = undefined as unknown as AudioBuffer;\n    this.clearImpulseResponseResults();\n  }\n\n  clearImpulseResponseResults() {\n    const results = useResult.getState().results;\n    // Find any impulse response results from this raytracer and remove them\n    Object.keys(results).forEach((key) => {\n      const result = results[key];\n      if (result.from === this.uuid && result.kind === ResultKind.ImpulseResponse) {\n        emit(\"REMOVE_RESULT\", key);\n      }\n    });\n  }\n\n  reflectionLossFunction(room: Room, raypath: RayPath, frequency: number): number {\n    return reflectionLossFunctionFn(room, raypath, frequency);\n  }\n\n  calculateReflectionLoss(frequencies: number[] = this.frequencies) {\n    const [allReceiverData, chartdata] = calculateReflectionLossFn(this.paths, this.room, this.receiverIDs, frequencies);\n    this.allReceiverData = allReceiverData;\n    this.chartdata = chartdata;\n    return [this.allReceiverData, chartdata];\n  }\n  getReceiverIntersectionPoints(id: string) {\n    if (this.paths && this.paths[id] && this.paths[id].length > 0) {\n      return this.paths[id].map((x) =>\n        new THREE.Vector3().fromArray(x.chain[x.chain.length - 1].point)\n      ) as THREE.Vector3[];\n    } else return [] as THREE.Vector3[];\n  }\n  calculateResponseByIntensity(freqs: number[] = this.frequencies, temperature: number = this.temperature) {\n    const result = calcResponseByIntensityFn(this.indexedPaths, this.receiverIDs, this.sourceIDs, freqs, temperature, this.intensitySampleRate);\n    if (result) {\n      this.responseByIntensity = result;\n    }\n    return this.responseByIntensity;\n  }\n\n  resampleResponseByIntensity(sampleRate: number = this.intensitySampleRate) {\n    if (this.responseByIntensity) {\n      const result = resampleResponseByIntensityFn(this.responseByIntensity, sampleRate);\n      if (result) this.responseByIntensity = result;\n      return this.responseByIntensity;\n    } else {\n      console.warn(\"no data yet\");\n    }\n  }\n\n  calculateT30(receiverId?: string, sourceId?: string) {\n    if (this.responseByIntensity) {\n      const recIds = receiverId ? [receiverId] : this.receiverIDs;\n      const srcIds = sourceId ? [sourceId] : this.sourceIDs;\n      for (const rec of recIds) {\n        for (const src of srcIds) {\n          if (this.responseByIntensity[rec]?.[src]) {\n            calculateT30Fn(this.responseByIntensity, rec, src);\n          }\n        }\n      }\n    }\n    return this.responseByIntensity;\n  }\n  calculateT20(receiverId?: string, sourceId?: string) {\n    if (this.responseByIntensity) {\n      const recIds = receiverId ? [receiverId] : this.receiverIDs;\n      const srcIds = sourceId ? [sourceId] : this.sourceIDs;\n      for (const rec of recIds) {\n        for (const src of srcIds) {\n          if (this.responseByIntensity[rec]?.[src]) {\n            calculateT20Fn(this.responseByIntensity, rec, src);\n          }\n        }\n      }\n    }\n    return this.responseByIntensity;\n  }\n  calculateT60(receiverId?: string, sourceId?: string) {\n    if (this.responseByIntensity) {\n      const recIds = receiverId ? [receiverId] : this.receiverIDs;\n      const srcIds = sourceId ? [sourceId] : this.sourceIDs;\n      for (const rec of recIds) {\n        for (const src of srcIds) {\n          if (this.responseByIntensity[rec]?.[src]) {\n            calculateT60Fn(this.responseByIntensity, rec, src);\n          }\n        }\n      }\n    }\n    return this.responseByIntensity;\n  }\n\n  onParameterConfigFocus() {\n    console.log(\"focus\");\n    console.log(renderer.overlays.global.cells);\n    renderer.overlays.global.showCell(this.uuid + \"-valid-ray-count\");\n  }\n  onParameterConfigBlur() {\n    console.log(\"blur\");\n    renderer.overlays.global.hideCell(this.uuid + \"-valid-ray-count\");\n  }\n\n  pathsToLinearBuffer() {\n    return pathsToLinearBufferFn(this.paths);\n  }\n\n  linearBufferToPaths(linearBuffer: Float32Array) {\n    return linearBufferToPathsFn(linearBuffer);\n  }\n\n  arrivalPressure(initialSPL: number[], freqs: number[], path: RayPath, receiverGain: number = 1.0): number[] {\n    return arrivalPressureFn(initialSPL, freqs, path, receiverGain, this.temperature);\n  }\n  async calculateImpulseResponse(initialSPL = DEFAULT_INITIAL_SPL, frequencies = this.frequencies, sampleRate = audioEngine.sampleRate): Promise<AudioBuffer> {\n    if(this.receiverIDs.length === 0) throw Error(\"No receivers have been assigned to the raytracer\");\n    if(this.sourceIDs.length === 0) throw Error(\"No sources have been assigned to the raytracer\");\n    if(!this.paths[this.receiverIDs[0]] || this.paths[this.receiverIDs[0]].length === 0) throw Error(\"No rays have been traced yet\");\n\n    let sorted = this.paths[this.receiverIDs[0]].sort((a,b)=>a.time - b.time) as RayPath[];\n\n    const totalTime = sorted[sorted.length - 1].time + RESPONSE_TIME_PADDING;\n\n    const spls = Array(frequencies.length).fill(initialSPL);\n\n    // doubled the number of samples to mitigate the signal reversing\n    const numberOfSamples = floor(sampleRate * totalTime) * 2;\n\n    let samples: Array<Float32Array> = [];\n    for(let f = 0; f<frequencies.length; f++){\n      samples.push(new Float32Array(numberOfSamples));\n    }\n\n    if(this.hybrid){\n      console.log(\"Hybrid Calculation...\");\n\n      // remove raytracer paths under transition order\n      for(let i=0; i<sorted.length; i++){\n        if(sorted[i].chainLength-1 <= this.transitionOrder){\n          sorted.splice(i,1); \n        }\n      }\n\n      let isparams: ImageSourceSolverParams = {name: \"HybridHelperIS\",\n        roomID: this.roomID,\n        sourceIDs: this.sourceIDs,\n        surfaceIDs: this.surfaceIDs,\n        receiverIDs: this.receiverIDs,\n        maxReflectionOrder: this.transitionOrder,\n        imageSourcesVisible: false,\n        rayPathsVisible: false,\n        plotOrders: [0, 1, 2], // all paths\n        frequencies: this.frequencies,\n      };\n\n      let image_source_solver = new ImageSourceSolver(isparams, true);\n      let is_raypaths = image_source_solver.returnSortedPathsForHybrid(this.c,spls,frequencies);\n\n      // add in hybrid paths \n      for(let i = 0; i<is_raypaths.length; i++){\n        const randomPhase = coinFlip() ? 1 : -1;\n        const t = is_raypaths[i].time; \n        const roundedSample = floor(t * sampleRate);\n  \n        for(let f = 0; f<frequencies.length; f++){\n            samples[f][roundedSample] += is_raypaths[i].pressure[f]*randomPhase;\n        }\n      }\n    }\n  \n    // add in raytracer paths (apply receiver directivity)\n    const recForIR = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\n    for(let i = 0; i<sorted.length; i++){\n      const randomPhase = coinFlip() ? 1 : -1;\n      const t = sorted[i].time;\n      const dir = sorted[i].arrivalDirection || [0, 0, 1] as [number, number, number];\n      const recGain = recForIR.getGain(dir as [number, number, number]);\n      const p = this.arrivalPressure(spls, frequencies, sorted[i], recGain).map(x => x * randomPhase);\n      const roundedSample = floor(t * sampleRate);\n\n      for(let f = 0; f<frequencies.length; f++){\n          samples[f][roundedSample] += p[f];\n      }\n    }\n\n    // Apply late reverberation tail synthesis if enabled\n    if (this.lateReverbTailEnabled && this._energyHistogram[this.receiverIDs[0]]) {\n      const decayParams = extractDecayParameters(\n        this._energyHistogram[this.receiverIDs[0]], frequencies,\n        this.tailCrossfadeTime, this._histogramBinWidth\n      );\n      const { tailSamples, tailStartSample } = synthesizeTail(\n        decayParams, sampleRate\n      );\n      const crossfadeDurationSamples = floor(this.tailCrossfadeDuration * sampleRate);\n      samples = assembleFinalIR(samples, tailSamples, tailStartSample, crossfadeDurationSamples);\n\n      // Re-pad for FFT\n      const maxLen = samples.reduce((m, s) => Math.max(m, s.length), 0);\n      const paddedLength = maxLen * 2;\n      for (let f = 0; f < frequencies.length; f++) {\n        if (samples[f].length < paddedLength) {\n          const padded = new Float32Array(paddedLength);\n          padded.set(samples[f]);\n          samples[f] = padded;\n        }\n      }\n    }\n\n    const worker = FilterWorker();\n\n    return new Promise((resolve, reject)=>{\n\n      worker.postMessage({ samples });\n      worker.onmessage = (event) => {\n        const filteredSamples = event.data.samples as Float32Array[];\n\n        // make the new signal's length half as long, we dont need the reversed part\n        const signal = new Float32Array(filteredSamples[0].length >> 1);\n\n        let max = 0;\n        for(let i = 0; i<filteredSamples.length; i++){\n          for(let j = 0; j<signal.length; j++){\n            signal[j] += filteredSamples[i][j];\n            if(abs(signal[j])>max){\n              max = abs(signal[j]);\n            }\n          }\n        }\n\n        const normalizedSignal = normalize(signal);\n\n        const offlineContext = audioEngine.createOfflineContext(1, signal.length, sampleRate);\n\n        const source = audioEngine.createBufferSource(normalizedSignal, offlineContext);\n\n        source.connect(offlineContext.destination);\n        source.start();\n\n\n        audioEngine.renderContextAsync(offlineContext).then(impulseResponse=>resolve(impulseResponse)).catch(reject).finally(()=>worker.terminate());\n      };\n\n    })\n\n  }\n\n  /**\n   * Calculate an ambisonic impulse response from the traced ray paths.\n   * Each reflection is encoded based on its arrival direction at the receiver.\n   *\n   * @param order - Ambisonic order (1 = first order with 4 channels, 2 = 9 channels, etc.)\n   * @param initialSPL - Initial sound pressure level in dB\n   * @param frequencies - Octave band center frequencies for filtering\n   * @param sampleRate - Sample rate for the output\n   * @returns Promise resolving to an AudioBuffer with ambisonic channels\n   */\n  async calculateAmbisonicImpulseResponse(\n    order: number = 1,\n    initialSPL = DEFAULT_INITIAL_SPL,\n    frequencies = this.frequencies,\n    sampleRate = audioEngine.sampleRate\n  ): Promise<AudioBuffer> {\n    if (this.receiverIDs.length === 0) throw Error(\"No receivers have been assigned to the raytracer\");\n    if (this.sourceIDs.length === 0) throw Error(\"No sources have been assigned to the raytracer\");\n    if (!this.paths[this.receiverIDs[0]] || this.paths[this.receiverIDs[0]].length === 0) throw Error(\"No rays have been traced yet. Run the raytracer first.\");\n\n    const sorted = this.paths[this.receiverIDs[0]].sort((a, b) => a.time - b.time) as RayPath[];\n    if (sorted.length === 0) throw Error(\"No valid ray paths found\");\n\n    const totalTime = sorted[sorted.length - 1].time + RESPONSE_TIME_PADDING;\n    if (totalTime <= 0) throw Error(\"Invalid impulse response duration\");\n    const spls = Array(frequencies.length).fill(initialSPL);\n\n    // Doubled samples to mitigate signal reversing (same as mono version)\n    const numberOfSamples = floor(sampleRate * totalTime) * 2;\n    if (numberOfSamples < 2) throw Error(\"Impulse response too short to process\");\n    const nCh = getAmbisonicChannelCount(order);\n\n    // Create per-frequency, per-channel sample buffers\n    // Structure: samples[frequency][ambiChannel]\n    const samples: Float32Array[][] = [];\n    for (let f = 0; f < frequencies.length; f++) {\n      samples.push([]);\n      for (let ch = 0; ch < nCh; ch++) {\n        samples[f].push(new Float32Array(numberOfSamples));\n      }\n    }\n\n    // Process each ray path (apply receiver directivity)\n    const recForAmbi = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\n    for (let i = 0; i < sorted.length; i++) {\n      const path = sorted[i];\n      const randomPhase = coinFlip() ? 1 : -1;\n      const t = path.time;\n      const dir = path.arrivalDirection || [0, 0, 1] as [number, number, number];\n      const recGain = recForAmbi.getGain(dir as [number, number, number]);\n      const p = this.arrivalPressure(spls, frequencies, path, recGain).map(x => x * randomPhase);\n      const roundedSample = floor(t * sampleRate);\n\n      if (roundedSample >= numberOfSamples) continue;\n\n      // Create a single-sample impulse for this reflection\n      const impulse = new Float32Array(1);\n\n      // Encode each frequency band\n      for (let f = 0; f < frequencies.length; f++) {\n        impulse[0] = p[f];\n\n        // Encode the impulse at this direction (using Three.js coordinate system)\n        const encoded = encodeBufferFromDirection(impulse, dir[0], dir[1], dir[2], order, 'threejs');\n\n        // Add to the output buffers\n        for (let ch = 0; ch < nCh; ch++) {\n          samples[f][ch][roundedSample] += encoded[ch][0];\n        }\n      }\n    }\n\n    // Apply late reverberation tail synthesis to W channel (ch=0) only.\n    // Late reverb is diffuse and directionless — only the omnidirectional channel needs extension.\n    if (this.lateReverbTailEnabled && this._energyHistogram[this.receiverIDs[0]]) {\n      const decayParams = extractDecayParameters(\n        this._energyHistogram[this.receiverIDs[0]], frequencies,\n        this.tailCrossfadeTime, this._histogramBinWidth\n      );\n      const { tailSamples, tailStartSample } = synthesizeTail(\n        decayParams, sampleRate\n      );\n      const crossfadeDurationSamples = floor(this.tailCrossfadeDuration * sampleRate);\n\n      // Extend W channel (ch=0) for each frequency band\n      for (let f = 0; f < frequencies.length; f++) {\n        const wChannel = [samples[f][0]];\n        const tailForBand = [tailSamples[f]];\n        const extended = assembleFinalIR(wChannel, tailForBand, tailStartSample, crossfadeDurationSamples);\n        samples[f][0] = extended[0];\n      }\n\n      // Re-pad all [f][ch] buffers to 2 * maxLen for the FilterWorker double-length contract\n      let maxLen = 0;\n      for (let f = 0; f < frequencies.length; f++) {\n        for (let ch = 0; ch < nCh; ch++) {\n          if (samples[f][ch].length > maxLen) maxLen = samples[f][ch].length;\n        }\n      }\n      const targetLen = maxLen * 2;\n      for (let f = 0; f < frequencies.length; f++) {\n        for (let ch = 0; ch < nCh; ch++) {\n          if (samples[f][ch].length < targetLen) {\n            const padded = new Float32Array(targetLen);\n            padded.set(samples[f][ch]);\n            samples[f][ch] = padded;\n          }\n        }\n      }\n    }\n\n    // Use filter worker to apply octave-band filtering (same as mono version)\n    const worker = FilterWorker();\n\n    return new Promise((resolve, reject) => {\n      // Process each ambisonic channel through the filter bank\n      const processChannel = async (chIndex: number): Promise<Float32Array> => {\n        return new Promise((resolveChannel) => {\n          // Extract the per-frequency samples for this channel\n          const channelFreqSamples: Float32Array[] = [];\n          for (let f = 0; f < frequencies.length; f++) {\n            channelFreqSamples.push(samples[f][chIndex]);\n          }\n\n          const channelWorker = FilterWorker();\n          channelWorker.postMessage({ samples: channelFreqSamples });\n          channelWorker.onmessage = (event) => {\n            const filteredSamples = event.data.samples as Float32Array[];\n\n            // Sum filtered bands and take first half (remove reversed portion)\n            const signal = new Float32Array(filteredSamples[0].length >> 1);\n            for (let f = 0; f < filteredSamples.length; f++) {\n              for (let j = 0; j < signal.length; j++) {\n                signal[j] += filteredSamples[f][j];\n              }\n            }\n\n            channelWorker.terminate();\n            resolveChannel(signal);\n          };\n        });\n      };\n\n      // Process all channels\n      Promise.all(\n        Array.from({ length: nCh }, (_, ch) => processChannel(ch))\n      ).then((channelSignals) => {\n        // Find global max for normalization\n        let max = 0;\n        for (const signal of channelSignals) {\n          for (let j = 0; j < signal.length; j++) {\n            if (abs(signal[j]) > max) {\n              max = abs(signal[j]);\n            }\n          }\n        }\n\n        // Normalize all channels by the same factor\n        if (max > 0) {\n          for (const signal of channelSignals) {\n            for (let j = 0; j < signal.length; j++) {\n              signal[j] /= max;\n            }\n          }\n        }\n\n        // Create multi-channel AudioBuffer\n        const signalLength = channelSignals[0].length;\n        if (signalLength === 0) {\n          worker.terminate();\n          reject(new Error(\"Filtered signal has zero length\"));\n          return;\n        }\n        const offlineContext = audioEngine.createOfflineContext(nCh, signalLength, sampleRate);\n        const buffer = offlineContext.createBuffer(nCh, signalLength, sampleRate);\n\n        for (let ch = 0; ch < nCh; ch++) {\n          buffer.copyToChannel(new Float32Array(channelSignals[ch]), ch);\n        }\n\n        worker.terminate();\n        resolve(buffer);\n      }).catch(reject);\n    });\n  }\n\n  ambisonicImpulseResponse?: AudioBuffer;\n  ambisonicOrder: number = 1;\n\n  impulseResponse!: AudioBuffer;\n  impulseResponsePlaying = false;\n\n  async playImpulseResponse(){\n    const result = await playImpulseResponseFn(\n      this.impulseResponse, () => this.calculateImpulseResponse(), this.uuid\n    );\n    this.impulseResponse = result.impulseResponse;\n  }\n  downloadImpulses(filename: string, initialSPL = DEFAULT_INITIAL_SPL, frequencies = ac.Octave(125, 8000), sampleRate = 44100){\n    downloadImpulsesFn(\n      this.paths, this.receiverIDs, this.sourceIDs,\n      (spls, freqs, path, recGain) => this.arrivalPressure(spls, freqs, path, recGain),\n      filename, initialSPL, frequencies, sampleRate\n    );\n  }\n  async downloadImpulseResponse(filename: string, sampleRate = audioEngine.sampleRate){\n    const result = await downloadImpulseResponseFn(\n      this.impulseResponse, () => this.calculateImpulseResponse(), filename, sampleRate\n    );\n    this.impulseResponse = result.impulseResponse;\n  }\n\n  async downloadAmbisonicImpulseResponse(\n    filename: string,\n    order: number = 1\n  ) {\n    const result = await downloadAmbisonicIRFn(\n      this.ambisonicImpulseResponse,\n      (o: number) => this.calculateAmbisonicImpulseResponse(o),\n      this.ambisonicOrder, order, filename\n    );\n    this.ambisonicImpulseResponse = result.ambisonicImpulseResponse;\n    this.ambisonicOrder = result.ambisonicOrder;\n  }\n\n  /**\n   * Calculate binaural impulse response from the ambisonic IR using HRTF decoder filters.\n   * The ambisonic IR is computed (or cached) first, then optionally rotated by head orientation,\n   * and finally decoded to stereo via HRTF convolution.\n   */\n  async calculateBinauralImpulseResponse(order: number = 1): Promise<AudioBuffer> {\n    // Get or compute ambisonic IR\n    if (!this.ambisonicImpulseResponse || this.ambisonicOrder !== order) {\n      this.ambisonicImpulseResponse = await this.calculateAmbisonicImpulseResponse(order);\n      this.ambisonicOrder = order;\n    }\n\n    this.binauralImpulseResponse = await calculateBinauralFromAmbisonic({\n      ambisonicImpulseResponse: this.ambisonicImpulseResponse,\n      order,\n      hrtfSubjectId: this.hrtfSubjectId,\n      headYaw: this.headYaw,\n      headPitch: this.headPitch,\n      headRoll: this.headRoll,\n    });\n    return this.binauralImpulseResponse;\n  }\n\n  async playBinauralImpulseResponse(order: number = 1) {\n    const result = await playBinauralIRFn(\n      this.binauralImpulseResponse,\n      () => this.calculateBinauralImpulseResponse(order),\n      this.uuid\n    );\n    this.binauralImpulseResponse = result.binauralImpulseResponse;\n  }\n\n  async downloadBinauralImpulseResponse(filename: string, order: number = 1) {\n    const result = await downloadBinauralIRFn(\n      this.binauralImpulseResponse,\n      () => this.calculateBinauralImpulseResponse(order),\n      filename\n    );\n    this.binauralImpulseResponse = result.binauralImpulseResponse;\n  }\n\n  /** Initialize GPU ray tracer. Returns true on success. */\n  private async _initGpu(): Promise<boolean> {\n    if (!isWebGPUAvailable()) {\n      console.warn('[GPU RT] WebGPU not available in this browser');\n      return false;\n    }\n    let tracer: GpuRayTracer | null = null;\n    try {\n      tracer = new GpuRayTracer();\n      const ok = await tracer.initialize(\n        this.room,\n        this.receiverIDs,\n        {\n          reflectionOrder: this.reflectionOrder,\n          frequencies: this.frequencies,\n          cachedAirAtt: this._cachedAirAtt,\n          rrThreshold: this.rrThreshold,\n        },\n        this.gpuBatchSize,\n      );\n      // Guard against stop()/dispose() called during the await\n      if (!ok || !this._gpuRunning) {\n        tracer.dispose();\n        return false;\n      }\n      this._gpuRayTracer = tracer;\n      return true;\n    } catch (err) {\n      console.error('[GPU RT] Initialization failed:', err);\n      if (tracer) tracer.dispose();\n      return false;\n    }\n  }\n\n  /** Start the GPU-accelerated Monte Carlo loop. Falls back to CPU on failure. */\n  private _startGpuMonteCarlo() {\n    cancelAnimationFrame(this._rafId);\n    this._rafId = 0;\n    this._gpuRunning = true;\n    this._lastConvergenceCheck = Date.now();\n\n    const RAY_INPUT_FLOATS = 16;\n    const numBands = Math.min(this.frequencies.length, 7);\n\n    // Warn and fall back to CPU if more than 7 frequency bands\n    if (this.frequencies.length > 7) {\n      console.warn(`[GPU RT] ${this.frequencies.length} frequency bands exceeds GPU limit of 7; falling back to CPU`);\n      this._gpuRunning = false;\n      this.startAllMonteCarlo();\n      return;\n    }\n\n    // Fire-and-forget async init then tick loop\n    this._initGpu().then((ok) => {\n      if (!ok || !this._gpuRunning) {\n        if (this._gpuRunning) {\n          console.warn('[GPU RT] Falling back to CPU ray tracing');\n          this._gpuRunning = false;\n          this.startAllMonteCarlo();\n        }\n        return;\n      }\n\n      // Use the actual allocated capacity (may be clamped by device limits)\n      const initBatchSize = this._gpuRayTracer!.effectiveBatchSize;\n\n      // Pre-allocate ray input buffer to avoid GC pressure in the hot loop\n      const rayInputs = new Float32Array(initBatchSize * RAY_INPUT_FLOATS);\n\n      const tick = async () => {\n        if (!this._gpuRunning || !this._isRunning || !this._gpuRayTracer) return;\n\n        try {\n          // Validate and clamp batch size\n          if (!Number.isFinite(this.gpuBatchSize) || this.gpuBatchSize <= 0) {\n            console.warn('[GPU RT] Invalid gpuBatchSize, falling back to CPU');\n            this._gpuRunning = false;\n            this._disposeGpu();\n            this.startAllMonteCarlo();\n            return;\n          }\n          // Clamp to the capacity allocated during initialize() to avoid\n          // exceeding GPU buffer sizes if the user changes gpuBatchSize mid-run\n          const batchSize = Math.min(Math.floor(this.gpuBatchSize), initBatchSize);\n\n          let rayIdx = 0;\n          for (let i = 0; i < this.sourceIDs.length && rayIdx < batchSize; i++) {\n            const source = useContainer.getState().containers[this.sourceIDs[i]] as Source;\n            const position = source.position;\n            const rotation = source.rotation;\n            const sourcePhi = source.phi;\n            const sourceTheta = source.theta;\n            const sourceDH = source.directivityHandler;\n            const sourceId = this.sourceIDs[i];\n\n            // Cache ref pressures\n            if (!this._directivityRefPressures) this._directivityRefPressures = new Map();\n            let refPressures = this._directivityRefPressures.get(sourceId);\n            if (!refPressures || refPressures.length !== this.frequencies.length) {\n              refPressures = new Array(this.frequencies.length);\n              for (let f = 0; f < this.frequencies.length; f++) {\n                refPressures[f] = sourceDH.getPressureAtPosition(0, this.frequencies[f], 0, 0) as number;\n              }\n              this._directivityRefPressures.set(sourceId, refPressures);\n            }\n\n            const raysPerSource = Math.max(1, Math.floor(batchSize / this.sourceIDs.length));\n            const direction = new THREE.Vector3(); // reuse scratch vector\n            for (let r = 0; r < raysPerSource && rayIdx < batchSize; r++) {\n              const phi = Math.random() * sourcePhi;\n              const theta = Math.random() * sourceTheta;\n\n              const threeJSAngles = cramangle2threejsangle(phi, theta);\n              direction.setFromSphericalCoords(1, threeJSAngles[0], threeJSAngles[1]);\n              direction.applyEuler(rotation);\n\n              const off = rayIdx * RAY_INPUT_FLOATS;\n              rayInputs[off] = position.x;\n              rayInputs[off + 1] = position.y;\n              rayInputs[off + 2] = position.z;\n              rayInputs[off + 3] = direction.x;\n              rayInputs[off + 4] = direction.y;\n              rayInputs[off + 5] = direction.z;\n              rayInputs[off + 6] = phi;\n              rayInputs[off + 7] = theta;\n\n              // Band energy with directivity\n              for (let f = 0; f < numBands; f++) {\n                let energy = 1;\n                try {\n                  const dirP = sourceDH.getPressureAtPosition(0, this.frequencies[f], phi, theta);\n                  const refP = refPressures[f];\n                  if (typeof dirP === \"number\" && typeof refP === \"number\" && refP > 0) {\n                    energy = (dirP / refP) ** 2;\n                  }\n                } catch (e) { /* fallback to unity */ }\n                rayInputs[off + 8 + f] = energy;\n              }\n\n              rayIdx++;\n            }\n          }\n\n          const actualRayCount = rayIdx;\n          const batchSeed = Math.floor(Math.random() * 0xFFFFFFFF);\n          const results = await this._gpuRayTracer.traceBatch(rayInputs, actualRayCount, batchSeed);\n\n          // Count all rays (including those with no intersections) for accurate stats\n          this.__num_checked_paths += actualRayCount;\n          (this.stats.numRaysShot.value as number) += actualRayCount;\n\n          // Process returned paths — results array is 1:1 with input rays\n          const raysPerSource = Math.max(1, Math.floor(actualRayCount / Math.max(1, this.sourceIDs.length)));\n\n          for (let p = 0; p < results.length; p++) {\n            const path = results[p];\n            if (!path) continue; // Ray produced no intersections\n\n            // Determine which source this ray belongs to (index mapping is preserved)\n            const srcArrayIdx = Math.min(\n              Math.floor(p / Math.max(1, raysPerSource)),\n              this.sourceIDs.length - 1\n            );\n            const sourceId = this.sourceIDs[srcArrayIdx];\n            const position = (useContainer.getState().containers[sourceId] as Source).position;\n            path.source = sourceId;\n\n            this._handleTracedPath(path, position, sourceId);\n          }\n\n          this.flushRayBuffer();\n          renderer.needsToRender = true;\n\n          // Convergence check\n          const now = Date.now();\n          if (this.autoStop && now - this._lastConvergenceCheck >= this._convergenceCheckInterval) {\n            this._lastConvergenceCheck = now;\n            this._updateConvergenceMetrics();\n            if (this.convergenceMetrics.convergenceRatio < this.convergenceThreshold\n                && this.convergenceMetrics.t30Count >= 3) {\n              this.isRunning = false;\n              return;\n            }\n          }\n\n          // Next frame\n          if (this._gpuRunning && this._isRunning) {\n            this._rafId = requestAnimationFrame(() => { tick(); });\n          }\n        } catch (err) {\n          console.error('[GPU RT] Batch error, falling back to CPU:', err);\n          this._gpuRunning = false;\n          this._disposeGpu();\n          this.startAllMonteCarlo();\n        }\n      };\n\n      this._rafId = requestAnimationFrame(() => { tick(); });\n    });\n  }\n\n  /** Destroy GPU ray tracer if initialized. */\n  private _disposeGpu() {\n    if (this._gpuRayTracer) {\n      this._gpuRayTracer.dispose();\n      this._gpuRayTracer = null;\n    }\n  }\n\n  get sources() {\n    if (this.sourceIDs.length > 0) {\n      return this.sourceIDs.map((x) => useContainer.getState().containers[x]);\n    } else {\n      return [];\n    }\n  }\n  get receivers() {\n    if (this.receiverIDs.length > 0 && Object.keys(useContainer.getState().containers).length > 0) {\n      return this.receiverIDs.map((x) => (useContainer.getState().containers[x] as Receiver).mesh) as THREE.Mesh[];\n    } else return [];\n  }\n  get room(): Room {\n    return useContainer.getState().containers[this.roomID] as Room;\n  }\n  get precheck() {\n    return this.sourceIDs.length > 0 && typeof this.room !== \"undefined\";\n  }\n  get indexedPaths() {\n    const paths = {} as KVP<KVP<RayPath[]>>;\n    for (const receiverKey in this.paths) {\n      paths[receiverKey] = {} as KVP<RayPath[]>;\n      for (let i = 0; i < this.paths[receiverKey].length; i++) {\n        const sourceKey = this.paths[receiverKey][i].source;\n        if (!paths[receiverKey][sourceKey]) {\n          paths[receiverKey][sourceKey] = [this.paths[receiverKey][i]] as RayPath[];\n        } else {\n          paths[receiverKey][sourceKey].push(this.paths[receiverKey][i]);\n        }\n      }\n    }\n    return paths;\n  }\n  get isRunning() {\n    return this.running;\n  }\n  set isRunning(isRunning: boolean) {\n    this.running = this.precheck && isRunning;\n    if (this.running) {\n      this.start();\n    } else {\n      this.stop();\n    }\n  }\n  get raysVisible() {\n    return this._raysVisible;\n  }\n  set raysVisible(visible: boolean) {\n    if (visible != this._raysVisible) {\n      this._raysVisible = visible;\n      this.rays.visible = visible;\n    }\n    renderer.needsToRender = true;\n  }\n  get pointsVisible() {\n    return this._pointsVisible;\n  }\n  set pointsVisible(visible: boolean) {\n    if (visible != this._pointsVisible) {\n      this._pointsVisible = visible;\n      this.hits.visible = visible;\n    }\n    renderer.needsToRender = true;\n  }\n  get invertedDrawStyle() {\n    return this._invertedDrawStyle;\n  }\n  set invertedDrawStyle(inverted: boolean) {\n    if (this._invertedDrawStyle != inverted) {\n      this._invertedDrawStyle = inverted;\n      (this.hits.material as THREE.ShaderMaterial).uniforms[\"inverted\"].value = Number(inverted);\n      (this.hits.material as THREE.ShaderMaterial).needsUpdate = true;\n    }\n    renderer.needsToRender = true;\n  }\n  get pointSize() {\n    return this._pointSize;\n  }\n  set pointSize(size: number) {\n    if (Number.isFinite(size) && size > 0) {\n      this._pointSize = size;\n      (this.hits.material as THREE.ShaderMaterial).uniforms[\"pointScale\"].value = this._pointSize;\n      (this.hits.material as THREE.ShaderMaterial).needsUpdate = true;\n    }\n    renderer.needsToRender = true;\n  }\n  get runningWithoutReceivers() {\n    return this._runningWithoutReceivers;\n  }\n  set runningWithoutReceivers(runningWithoutReceivers: boolean) {\n    this.mapIntersectableObjects();\n    this._runningWithoutReceivers = runningWithoutReceivers;\n  }\n}\n\n\n\n\n\nexport default RayTracer;\n\n\n\n// this allows for nice type checking with 'on' and 'emit' from messenger\ndeclare global {\n  interface EventTypes {\n    ADD_RAYTRACER: RayTracer | undefined,\n    REMOVE_RAYTRACER: string;\n    RAYTRACER_CLEAR_RAYS: string;\n    RAYTRACER_SET_PROPERTY: SetPropertyPayload<RayTracer>\n    RAYTRACER_PLAY_IR: string;\n    RAYTRACER_DOWNLOAD_IR: string;\n    RAYTRACER_DOWNLOAD_IR_OCTAVE: string;\n    RAYTRACER_DOWNLOAD_AMBISONIC_IR: { uuid: string; order: number };\n    RAYTRACER_PLAY_BINAURAL_IR: { uuid: string; order: number };\n    RAYTRACER_DOWNLOAD_BINAURAL_IR: { uuid: string; order: number };\n    RAYTRACER_CALL_METHOD: CallSolverMethod<RayTracer>;\n  }\n}\n\non(\"RAYTRACER_CALL_METHOD\", callSolverMethod as any);\non(\"RAYTRACER_SET_PROPERTY\", setSolverProperty);\non(\"REMOVE_RAYTRACER\", removeSolver);\non(\"ADD_RAYTRACER\", addSolver(RayTracer))\non(\"RAYTRACER_CLEAR_RAYS\", (uuid: string) => void (useSolver.getState().solvers[uuid] as RayTracer).clearRays());\non(\"RAYTRACER_PLAY_IR\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as RayTracer;\n  solver.playImpulseResponse().catch((err: Error) => {\n    window.alert(err.message || \"Failed to play impulse response\");\n  });\n});\non(\"RAYTRACER_DOWNLOAD_IR\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as RayTracer;\n  const containers = useContainer.getState().containers;\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n  const filename = `ir-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\n  solver.downloadImpulseResponse(filename).catch((err: Error) => {\n    window.alert(err.message || \"Failed to download impulse response\");\n  });\n});\non(\"RAYTRACER_DOWNLOAD_IR_OCTAVE\", (uuid: string) => void (useSolver.getState().solvers[uuid] as RayTracer).downloadImpulses(uuid));\non(\"RAYTRACER_DOWNLOAD_AMBISONIC_IR\", ({ uuid, order }: { uuid: string; order: number }) => {\n  const solver = useSolver.getState().solvers[uuid] as RayTracer;\n  const containers = useContainer.getState().containers;\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n  const filename = `ir-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\n  solver.downloadAmbisonicImpulseResponse(filename, order).catch((err: Error) => {\n    window.alert(err.message || \"Failed to download ambisonic impulse response\");\n  });\n});\non(\"RAYTRACER_PLAY_BINAURAL_IR\", ({ uuid, order }: { uuid: string; order: number }) => {\n  const solver = useSolver.getState().solvers[uuid] as RayTracer;\n  solver.playBinauralImpulseResponse(order).catch((err: Error) => {\n    window.alert(err.message || \"Failed to play binaural impulse response\");\n  });\n});\non(\"RAYTRACER_DOWNLOAD_BINAURAL_IR\", ({ uuid, order }: { uuid: string; order: number }) => {\n  const solver = useSolver.getState().solvers[uuid] as RayTracer;\n  const containers = useContainer.getState().containers;\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n  const filename = `ir-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\n  solver.downloadBinauralImpulseResponse(filename, order).catch((err: Error) => {\n    window.alert(err.message || \"Failed to download binaural impulse response\");\n  });\n});\n\n\n"],"names":["vs","fs","PointShader","cramangle2threejsangle","phiCRAM","thetaCRAM","thetaThreeJS","Observable","v","value","old","watcher","callback","observe","watchers","SELF_INTERSECTION_OFFSET","DEFAULT_INITIAL_SPL","RESPONSE_TIME_PADDING","MAX_DISPLAY_POINTS","CONVERGENCE_CHECK_INTERVAL_MS","defaults","DRAWSTYLE","normalize","arr","maxValue","i","probability","prob","abs","_negRd","THREE","_normalCopy","_normalScaled","_reflectedDir","_scatterCandidate","_offsetOrigin","_arrivalDir","_plane","_pleq","_avec4","_bvec4","_cvec4","inFrontOf","a","b","traceRay","raycaster","intersectableObjects","frequencies","cachedAirAtt","rrThreshold","ro","rd","order","bandEnergy","source","initialPhi","initialTheta","iter","chain","intersections","totalEnergy","energy","angle","receiverSegmentDist","receiverBandEnergy","e","f","receiverTotalEnergy","receiverEnergy","arrivalDirection","Surface","normal","rr","surface","scatterCoeffs","broadbandScattering","segmentDistance","newBandEnergy","frequency","maxEnergy","survivalProbability","rrTotalEnergy","rrEnergy","floor","mathMax","coinFlip","FilterWorker","arrivalPressure","initialSPL","freqs","path","receiverGain","temperature","intensities","ac.P2I","ac.Lp2P","pressures","ac.P2Lp","ac.I2P","p","useContainer","I","R","arrivalLp","airAttenuationdB","ac.airAttenuation","_","calculateImpulseResponseForPair","sourceId","receiverId","paths","sampleRate","audioEngine","tailOptions","sorted","totalTime","spls","numberOfSamples","samples","recForPair","randomPhase","t","dir","recGain","x","roundedSample","decayParams","extractDecayParameters","tailSamples","tailStartSample","synthesizeTail","crossfadeDurationSamples","assembleFinalIR","paddedLength","m","s","padded","worker","resolve","reject","event","filteredSamples","signal","j","normalizedSignal","error","calculateImpulseResponseForDisplay","receiverIDs","sourceIDs","recForDisplay","reflectionLossFunction","room","raypath","magnitude","k","intersection","calculateReflectionLoss","allReceiverData","dataset","label","data","chartdata","pathkeys","refloss","freq","calculateResponseByIntensity","indexedPaths","intensitySampleRate","soundSpeed","ac.soundSpeed","responseByIntensity","receiverKey","recForIntensity","sourceKey","time","IrayArray","phi","theta","srcDirectivityHandler","findex","recGainIntensity","recGainSq","distance","id","coefficient","level","resampleResponseByIntensity","V2_MAGIC","linearBufferToPathsV1","linearBuffer","decodeUUID","buffer","decodeChainItem","chainItem","object","faceIndex","faceMaterialIndex","faceNormal","point","decodePathBuffer","o","chainLength","intersectedReceiver","offset","pathsObj","uuid","pathBufferLength","pathsToLinearBufferV2","uuidSet","key","uuidList","uuidToIndex","uuidTableSize","dataSize","c","pathBufLen","linearBufferToPathsV2","numUUIDs","chars","receiverIdx","receiverUuid","endOffset","chainEnergy","pathsToLinearBuffer","linearBufferToPaths","RAYTRACER_EVENT","downloadImpulses","arrivalPressureFn","filename","ac.Octave","max","recForDownload","blob","ac.wavAsBlob","ac.normalize","FileSaver","playImpulseResponse","impulseResponse","calculateImpulseResponse","sharedPlayIR","downloadImpulseResponse","sharedDownloadIR","downloadAmbisonicImpulseResponse","ambisonicImpulseResponse","calculateAmbisonicImpulseResponse","ambisonicOrder","sharedDownloadAmbisonicIR","playBinauralImpulseResponse","binauralImpulseResponse","calculateBinauralImpulseResponse","sharedPlayBinauralIR","downloadBinauralImpulseResponse","sharedDownloadBinauralIR","resetConvergenceState","numFrequencies","convergenceMetrics","energyHistogram","lastConvergenceCheck","updateConvergenceMetrics","numCheckedPaths","validRayCount","histogramBinWidth","histogramNumBins","receiverIdsWithData","hist","sortedIds","histograms","numBands","t30Estimates","histogram","lastBin","schroeder","maxVal","db5","db35","idx5","idx35","times","levelsDb","slope","linearRegression","n","maxRatio","validBandCount","val","oldMean","newMean","newM2","variance","ratio","emit","addToEnergyHistogram","bin","buildGpuSceneBuffers","surfaces","containers","surfaceUuidMap","allVerts","allNormals","allSurfIdx","si","mesh","geo","posAttr","indexAttr","mat","idx","vert","base","computeFaceNormal","triangleCount","triangleVertices","triangleNormals","triangleSurfaceIndex","centroids","indices","root","buildBvhNode","reorderedVerts","reorderedNormals","reorderedSurfIdx","src","nodeArray","nodeCount","flattenBvh","numFreqs","surfaceAcousticData","fi","receiverUuidMap","receiverData","rec","baseRadius","maxScale","MAX_LEAF_TRIS","MAX_DEPTH","verts","start","end","depth","minX","minY","minZ","maxX","maxY","maxZ","ti","y","z","count","dx","dy","dz","axis","centroidMin","centroidMax","split","mid","tmp","left","right","stack","node","nextIndex","write","myIndex","off","u32View","leftIdx","rightIdx","ax","ay","az","bx","by","bz","cx","cy","cz","e1x","e1y","e1z","e2x","e2y","e2z","nx","ny","nz","len","shaderSource","MAX_BOUNCES","MAX_BANDS","WORKGROUP_SIZE","RAY_INPUT_FLOATS","RAY_INPUT_BYTES","RAY_OUTPUT_FLOATS","RAY_OUTPUT_BYTES","CHAIN_ENTRY_FLOATS","CHAIN_ENTRY_BYTES","PARAMS_FLOATS","PARAMS_BYTES","GpuRayTracer","config","requestedBatchSize","ctx","requestGpuContext","maxStorageBinding","maxBufSize","perRayChainBytes","maxByLimits","normalizedRequested","batchSize","clampedFrequencies","recData","inputBytes","outputBytes","chainBytes","shaderModule","rayInputs","rayCount","batchSeed","paramsData","paramsU32","paramsF32","bindGroup","workgroups","encoder","pass","outputData","chainData","scene","r","outOff","outU32","arrivalDir","finalBandEnergy","chainBase","cOff","cU32","px","py","pz","surfaceIndex","objectUuid","recIdx","inOff","totalE","meanE","buffers","buf","size","random","computeBoundsTree","disposeBoundsTree","acceleratedRaycast","RayTracer","Solver","params","DEFAULT_INTENSITY_SAMPLE_RATE","paramsHasRaysVisible","paramsHasPointsVisible","paramsHasInvertedDrawStyle","HISTOGRAM_BIN_WIDTH","HISTOGRAM_NUM_BINS","renderer","shaderMaterial","messenger","acc","args","name","kind","autoCalculate","roomID","surfaceIDs","updateInterval","passes","pointSize","reflectionOrder","runningWithoutReceivers","raysVisible","pointsVisible","invertedDrawStyle","plotStyle","convergenceThreshold","autoStop","maxStoredPaths","edgeDiffractionEnabled","lateReverbTailEnabled","tailCrossfadeTime","tailCrossfadeDuration","gpuEnabled","gpuBatchSize","hrtfSubjectId","headYaw","headPitch","headRoll","interval","container","drawStyle","scale","p1","p2","inFrontOfFn","traceRayFn","numRays","tempRunningWithoutReceivers","result","sharedQuickEstimateStep","tick","budgetMs","now","nPhi","nTheta","sourcePhi","sourceTheta","position","rotation","sourceDH","refPressures","sj","threeJSAngles","direction","initialBandEnergy","dirPressure","refPressure","index","cap","overflow","state","buildEdgeGraph","calc_time","num_valid_rays","valid_ray_rate","num_checks","check_rate","sourcePositions","sourceDirectivity","dh","receiverPositions","diffractionPaths","findDiffractionPaths","dp","srcDir","srcPos","dist","dirP","refP","meanEnergy","recPos","adx","ady","adz","adLen","sDist","rDist","rayPath","pairs","pathsForPair","sourceName","receiverName","progressPercent","ir","maxDisplayPoints","step","displayData","resultUuid","existingResult","useResult","ResultKind","err","calcIRForPairFn","calcIRForDisplayFn","results","reflectionLossFunctionFn","calculateReflectionLossFn","calcResponseByIntensityFn","resampleResponseByIntensityFn","recIds","srcIds","calculateT30Fn","calculateT20Fn","calculateT60Fn","pathsToLinearBufferFn","linearBufferToPathsFn","isparams","is_raypaths","ImageSourceSolver","recForIR","offlineContext","nCh","getAmbisonicChannelCount","ch","recForAmbi","impulse","encoded","encodeBufferFromDirection","wChannel","tailForBand","extended","maxLen","targetLen","processChannel","chIndex","resolveChannel","channelFreqSamples","channelWorker","channelSignals","signalLength","playImpulseResponseFn","downloadImpulsesFn","downloadImpulseResponseFn","downloadAmbisonicIRFn","calculateBinauralFromAmbisonic","playBinauralIRFn","downloadBinauralIRFn","isWebGPUAvailable","tracer","ok","initBatchSize","rayIdx","raysPerSource","actualRayCount","srcArrayIdx","isRunning","visible","inverted","on","callSolverMethod","setSolverProperty","removeSolver","addSolver","useSolver","solver"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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"}