{"version":3,"file":"export-playback-DSkRh1Qi.mjs","sources":["../src/compute/shared/export-playback.ts"],"sourcesContent":["import FileSaver from \"file-saver\";\nimport * as ac from \"../acoustics\";\nimport { emit } from \"../../messenger\";\nimport { audioEngine } from \"../../audio-engine/audio-engine\";\n\n/**\n * Play the impulse response through the audio engine.\n *\n * @param impulseResponse - The AudioBuffer to play (or undefined to calculate first)\n * @param calculateImpulseResponse - Async function to calculate the IR if needed\n * @param uuid - The solver UUID for property events\n * @param eventName - The event name for property updates (e.g. \"RAYTRACER_SET_PROPERTY\")\n */\nexport async function playImpulseResponse(\n  impulseResponse: AudioBuffer | undefined,\n  calculateImpulseResponse: () => Promise<AudioBuffer>,\n  uuid: string,\n  eventName: string\n): Promise<{ impulseResponse: AudioBuffer }> {\n  if (!impulseResponse) {\n    impulseResponse = await calculateImpulseResponse();\n  }\n  if (audioEngine.context.state === 'suspended') {\n    audioEngine.context.resume();\n  }\n  console.log(impulseResponse);\n  const source = audioEngine.context.createBufferSource();\n  source.buffer = impulseResponse;\n  source.connect(audioEngine.context.destination);\n  source.start();\n  emit(eventName, { uuid, property: \"impulseResponsePlaying\", value: true });\n  source.onended = () => {\n    source.stop();\n    source.disconnect(audioEngine.context.destination);\n    emit(eventName, { uuid, property: \"impulseResponsePlaying\", value: false });\n  };\n  return { impulseResponse };\n}\n\n/**\n * Download the impulse response as a WAV file.\n *\n * @param impulseResponse - The AudioBuffer (or undefined to calculate first)\n * @param calculateImpulseResponse - Async function to calculate the IR if needed\n * @param filename - Output filename\n * @param sampleRate - Sample rate for the output\n */\nexport async function downloadImpulseResponse(\n  impulseResponse: AudioBuffer | undefined,\n  calculateImpulseResponse: () => Promise<AudioBuffer>,\n  filename: string,\n  sampleRate: number = audioEngine.sampleRate\n): Promise<{ impulseResponse: AudioBuffer }> {\n  if (!impulseResponse) {\n    impulseResponse = await calculateImpulseResponse();\n  }\n  const blob = ac.wavAsBlob([ac.normalize(impulseResponse.getChannelData(0))], { sampleRate, bitDepth: 32 });\n  const extension = !filename.endsWith(\".wav\") ? \".wav\" : \"\";\n  FileSaver.saveAs(blob, filename + extension);\n  return { impulseResponse };\n}\n\n/**\n * Download the ambisonic impulse response as a multi-channel WAV file.\n * Channels are in ACN order with N3D normalization.\n *\n * @param ambisonicImpulseResponse - The ambisonic AudioBuffer (or undefined to calculate first)\n * @param calculateAmbisonicImpulseResponse - Async function to calculate if needed\n * @param ambisonicOrder - Current cached ambisonic order\n * @param order - Desired ambisonic order (default: 1)\n * @param filename - Output filename (without extension)\n */\nexport async function downloadAmbisonicImpulseResponse(\n  ambisonicImpulseResponse: AudioBuffer | undefined,\n  calculateAmbisonicImpulseResponse: (order: number) => Promise<AudioBuffer>,\n  ambisonicOrder: number,\n  order: number = 1,\n  filename: string\n): Promise<{ ambisonicImpulseResponse: AudioBuffer; ambisonicOrder: number }> {\n  // Calculate if not already cached or if order changed\n  if (!ambisonicImpulseResponse || ambisonicOrder !== order) {\n    ambisonicOrder = order;\n    ambisonicImpulseResponse = await calculateAmbisonicImpulseResponse(order);\n  }\n\n  const nCh = ambisonicImpulseResponse.numberOfChannels;\n  const sampleRate = ambisonicImpulseResponse.sampleRate;\n  const channelData: Float32Array[] = [];\n\n  // Extract all channels\n  for (let ch = 0; ch < nCh; ch++) {\n    channelData.push(ambisonicImpulseResponse.getChannelData(ch));\n  }\n\n  const blob = ac.wavAsBlob(channelData, { sampleRate, bitDepth: 32 });\n  const extension = !filename.endsWith(\".wav\") ? \".wav\" : \"\";\n  const orderLabel = order === 1 ? \"FOA\" : `HOA${order}`;\n  FileSaver.saveAs(blob, `${filename}_${orderLabel}${extension}`);\n  return { ambisonicImpulseResponse, ambisonicOrder };\n}\n\n/**\n * Play the binaural impulse response through the audio engine.\n *\n * @param binauralImpulseResponse - The stereo AudioBuffer to play (or undefined to calculate first)\n * @param calculateBinauralImpulseResponse - Async function to calculate if needed\n * @param uuid - The solver UUID for property events\n * @param eventName - The event name for property updates (e.g. \"RAYTRACER_SET_PROPERTY\")\n */\nexport async function playBinauralImpulseResponse(\n  binauralImpulseResponse: AudioBuffer | undefined,\n  calculateBinauralImpulseResponse: () => Promise<AudioBuffer>,\n  uuid: string,\n  eventName: string\n): Promise<{ binauralImpulseResponse: AudioBuffer }> {\n  if (!binauralImpulseResponse) {\n    binauralImpulseResponse = await calculateBinauralImpulseResponse();\n  }\n  if (audioEngine.context.state === 'suspended') {\n    audioEngine.context.resume();\n  }\n  const source = audioEngine.context.createBufferSource();\n  source.buffer = binauralImpulseResponse;\n  source.connect(audioEngine.context.destination);\n  source.start();\n  emit(eventName, { uuid, property: \"binauralPlaying\", value: true });\n  source.onended = () => {\n    source.stop();\n    source.disconnect(audioEngine.context.destination);\n    emit(eventName, { uuid, property: \"binauralPlaying\", value: false });\n  };\n  return { binauralImpulseResponse };\n}\n\n/**\n * Download the binaural impulse response as a stereo WAV file.\n *\n * @param binauralImpulseResponse - The stereo AudioBuffer (or undefined to calculate first)\n * @param calculateBinauralImpulseResponse - Async function to calculate if needed\n * @param filename - Output filename\n */\nexport async function downloadBinauralImpulseResponse(\n  binauralImpulseResponse: AudioBuffer | undefined,\n  calculateBinauralImpulseResponse: () => Promise<AudioBuffer>,\n  filename: string\n): Promise<{ binauralImpulseResponse: AudioBuffer }> {\n  if (!binauralImpulseResponse) {\n    binauralImpulseResponse = await calculateBinauralImpulseResponse();\n  }\n\n  const sampleRate = binauralImpulseResponse.sampleRate;\n  const left = binauralImpulseResponse.getChannelData(0);\n  const right = binauralImpulseResponse.getChannelData(1);\n\n  // Normalize stereo signal\n  let max = 0;\n  for (let i = 0; i < left.length; i++) {\n    if (Math.abs(left[i]) > max) max = Math.abs(left[i]);\n    if (Math.abs(right[i]) > max) max = Math.abs(right[i]);\n  }\n  const normLeft = new Float32Array(left.length);\n  const normRight = new Float32Array(right.length);\n  if (max > 0) {\n    for (let i = 0; i < left.length; i++) {\n      normLeft[i] = left[i] / max;\n      normRight[i] = right[i] / max;\n    }\n  }\n\n  const blob = ac.wavAsBlob([normLeft, normRight], { sampleRate, bitDepth: 32 });\n  const extension = !filename.endsWith(\".wav\") ? \".wav\" : \"\";\n  FileSaver.saveAs(blob, `${filename}_binaural${extension}`);\n  return { binauralImpulseResponse };\n}\n"],"names":["playImpulseResponse","impulseResponse","calculateImpulseResponse","uuid","eventName","audioEngine","source","emit","downloadImpulseResponse","filename","sampleRate","blob","ac.wavAsBlob","ac.normalize","extension","FileSaver","downloadAmbisonicImpulseResponse","ambisonicImpulseResponse","calculateAmbisonicImpulseResponse","ambisonicOrder","order","nCh","channelData","ch","orderLabel","playBinauralImpulseResponse","binauralImpulseResponse","calculateBinauralImpulseResponse","downloadBinauralImpulseResponse","left","right","max","i","normLeft","normRight"],"mappings":"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"}