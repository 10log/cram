{"version":3,"file":"art-DrHpWUsQ.mjs","sources":["../src/compute/radiance/art.ts"],"sourcesContent":["import { TessellateModifier } from \"./TessellateModifier\";\r\n\r\nimport Solver, { SolverParams } from \"../solver\";\r\nimport { on } from \"../../messenger\";\r\nimport { Mesh } from \"three\";\r\nimport {\r\n  addSolver,\r\n  removeSolver,\r\n  setSolverProperty,\r\n  useContainer\r\n} from \"../../store\";\r\nimport { v4 as uuid } from 'uuid';\r\nimport { renderer } from \"../../render/renderer\";\r\n\r\nexport interface ARTProps extends SolverParams {\r\n  //uuid?: string;\r\n  // containers: KVP<Container>;\r\n}\r\n\r\nexport type ARTSaveObject = {\r\n  uuid: string;\r\n  name: string;\r\n  kind: string;\r\n  autoCalculate: boolean;\r\n};\r\n\r\nconst defaults = {\r\n  name: \"Acoustic Radiance Transfer\"\r\n};\r\n\r\nexport class ART extends Solver {\r\n  constructor(props: ARTProps = defaults) {\r\n    super(props);\r\n    this.kind = \"art\";\r\n    this.name = props.name || defaults.name;\r\n    this.uuid = uuid();\r\n  }\r\n\r\n  tessellate(){\r\n    // throwif(this.rooms.length === 0, \"there's no rooms to tessellate\");\r\n    const surfaces = Object.keys(this.rooms[0].surfaceMap).map(key=>this.rooms[0].surfaceMap[key]);\r\n    const tessellateModifier = new TessellateModifier();\r\n    // const geometries = surfaces.map(surface => tessellateModifier.modify( surface.geometry ));\r\n    const meshes = surfaces.map(surface => new Mesh(tessellateModifier.modify( surface.geometry ), surface.wire.material));\r\n    meshes.forEach(mesh=>{\r\n      renderer.workspace.add(mesh);\r\n    })\r\n  }\r\n\r\n  save() {\r\n    const { name, kind, uuid, autoCalculate } = this;\r\n    return {\r\n      name,\r\n      kind,\r\n      uuid,\r\n      autoCalculate\r\n    } as ARTSaveObject;\r\n  }\r\n\r\n  restore(state: ARTSaveObject) {\r\n    this.name = state.name;\r\n    this.uuid = state.uuid;\r\n    this.autoCalculate = state.autoCalculate ?? false;\r\n    return this;\r\n  }\r\n\r\n  get rooms() {\r\n    return useContainer.getState().getRooms();\r\n  }\r\n}\r\n\r\nexport default ART;\r\n\r\n// this allows for nice type checking with 'on' and 'emit' from messenger\r\ndeclare global {\r\n  interface EventTypes {\r\n    ADD_ART: ART | undefined;\r\n    REMOVE_ART: string;\r\n    ART_SET_PROPERTY: {\r\n      uuid: string;\r\n      property: keyof ART;\r\n      value: ART[EventTypes[\"ART_SET_PROPERTY\"][\"property\"]];\r\n    };\r\n  }\r\n}\r\n\r\n// add event listener\r\non(\"ADD_ART\", addSolver(ART));\r\non(\"REMOVE_ART\", removeSolver);\r\non(\"ART_SET_PROPERTY\", setSolverProperty);\r\n"],"names":["defaults","ART","Solver","props","uuid","surfaces","key","tessellateModifier","TessellateModifier","surface","Mesh","mesh","renderer","name","kind","autoCalculate","state","useContainer","on","addSolver","removeSolver","setSolverProperty"],"mappings":";;;AA0BA,MAAMA,IAAW;AAAA,EACf,MAAM;AACR;AAEO,MAAMC,UAAYC,EAAO;AAAA,EAC9B,YAAYC,IAAkBH,GAAU;AACtC,UAAMG,CAAK,GACX,KAAK,OAAO,OACZ,KAAK,OAAOA,EAAM,QAAQH,EAAS,MACnC,KAAK,OAAOI,EAAA;AAAA,EACd;AAAA,EAEA,aAAY;AAEV,UAAMC,IAAW,OAAO,KAAK,KAAK,MAAM,CAAC,EAAE,UAAU,EAAE,IAAI,OAAK,KAAK,MAAM,CAAC,EAAE,WAAWC,CAAG,CAAC,GACvFC,IAAqB,IAAIC,EAAA;AAG/B,IADeH,EAAS,IAAI,CAAAI,MAAW,IAAIC,EAAKH,EAAmB,OAAQE,EAAQ,QAAS,GAAGA,EAAQ,KAAK,QAAQ,CAAC,EAC9G,QAAQ,CAAAE,MAAM;AACnB,MAAAC,EAAS,UAAU,IAAID,CAAI;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EAEA,OAAO;AACL,UAAM,EAAE,MAAAE,GAAM,MAAAC,GAAM,MAAAV,GAAM,eAAAW,MAAkB;AAC5C,WAAO;AAAA,MACL,MAAAF;AAAA,MACA,MAAAC;AAAA,MACA,MAAAV;AAAAA,MACA,eAAAW;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,QAAQC,GAAsB;AAC5B,gBAAK,OAAOA,EAAM,MAClB,KAAK,OAAOA,EAAM,MAClB,KAAK,gBAAgBA,EAAM,iBAAiB,IACrC;AAAA,EACT;AAAA,EAEA,IAAI,QAAQ;AACV,WAAOC,EAAa,SAAA,EAAW,SAAA;AAAA,EACjC;AACF;AAkBAC,EAAG,WAAWC,EAAUlB,CAAG,CAAC;AAC5BiB,EAAG,cAAcE,CAAY;AAC7BF,EAAG,oBAAoBG,CAAiB;"}