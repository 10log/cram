{"version":3,"file":"index-Dj8rPmB9.mjs","sources":["../node_modules/beam-trace/dist/core/vector3.js","../node_modules/beam-trace/dist/core/plane3d.js","../node_modules/beam-trace/dist/geometry/polygon3d.js","../node_modules/beam-trace/dist/geometry/polygon-split.js","../node_modules/beam-trace/dist/geometry/clipping3d.js","../node_modules/beam-trace/dist/structures/bsp3d.js","../node_modules/beam-trace/dist/structures/beam3d.js","../node_modules/beam-trace/dist/structures/beamtree3d.js","../node_modules/beam-trace/dist/optimization/failplane3d.js","../node_modules/beam-trace/dist/optimization/skipsphere3d.js","../node_modules/beam-trace/dist/solver/solver3d.js","../node_modules/beam-trace/dist/beamtrace3d.js","../src/compute/beam-trace/index.ts"],"sourcesContent":["/**\n * 3D Vector operations for BeamTrace3D\n *\n * Vectors are represented as [x, y, z] tuples for performance.\n */\nexport const Vector3 = {\n    /**\n     * Create a new Vector3\n     */\n    create(x, y, z) {\n        return [x, y, z];\n    },\n    /**\n     * Create a zero vector\n     */\n    zero() {\n        return [0, 0, 0];\n    },\n    /**\n     * Clone a vector\n     */\n    clone(v) {\n        return [v[0], v[1], v[2]];\n    },\n    /**\n     * Add two vectors\n     */\n    add(a, b) {\n        return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\n    },\n    /**\n     * Subtract vector b from vector a\n     */\n    subtract(a, b) {\n        return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n    },\n    /**\n     * Scale a vector by a scalar\n     */\n    scale(v, s) {\n        return [v[0] * s, v[1] * s, v[2] * s];\n    },\n    /**\n     * Negate a vector\n     */\n    negate(v) {\n        return [-v[0], -v[1], -v[2]];\n    },\n    /**\n     * Dot product of two vectors\n     */\n    dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    },\n    /**\n     * Cross product of two vectors (a × b)\n     */\n    cross(a, b) {\n        return [\n            a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0]\n        ];\n    },\n    /**\n     * Squared length of a vector\n     */\n    lengthSquared(v) {\n        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n    },\n    /**\n     * Length (magnitude) of a vector\n     */\n    length(v) {\n        return Math.sqrt(Vector3.lengthSquared(v));\n    },\n    /**\n     * Normalize a vector to unit length\n     * Returns zero vector if input has zero length\n     */\n    normalize(v) {\n        const len = Vector3.length(v);\n        if (len < 1e-10)\n            return [0, 0, 0];\n        return [v[0] / len, v[1] / len, v[2] / len];\n    },\n    /**\n     * Linear interpolation between two vectors\n     */\n    lerp(a, b, t) {\n        return [\n            a[0] + t * (b[0] - a[0]),\n            a[1] + t * (b[1] - a[1]),\n            a[2] + t * (b[2] - a[2])\n        ];\n    },\n    /**\n     * Distance between two points\n     */\n    distance(a, b) {\n        return Vector3.length(Vector3.subtract(a, b));\n    },\n    /**\n     * Squared distance between two points (faster than distance)\n     */\n    distanceSquared(a, b) {\n        return Vector3.lengthSquared(Vector3.subtract(a, b));\n    },\n    /**\n     * Check if two vectors are approximately equal\n     */\n    equals(a, b, epsilon = 1e-10) {\n        return Math.abs(a[0] - b[0]) < epsilon &&\n            Math.abs(a[1] - b[1]) < epsilon &&\n            Math.abs(a[2] - b[2]) < epsilon;\n    },\n    /**\n     * Component-wise minimum\n     */\n    min(a, b) {\n        return [\n            Math.min(a[0], b[0]),\n            Math.min(a[1], b[1]),\n            Math.min(a[2], b[2])\n        ];\n    },\n    /**\n     * Component-wise maximum\n     */\n    max(a, b) {\n        return [\n            Math.max(a[0], b[0]),\n            Math.max(a[1], b[1]),\n            Math.max(a[2], b[2])\n        ];\n    },\n    /**\n     * Reflect vector v across a plane with given normal\n     * v' = v - 2(v·n)n\n     */\n    reflect(v, normal) {\n        const d = 2 * Vector3.dot(v, normal);\n        return Vector3.subtract(v, Vector3.scale(normal, d));\n    },\n    /**\n     * Project vector a onto vector b\n     */\n    project(a, b) {\n        const bLenSq = Vector3.lengthSquared(b);\n        if (bLenSq < 1e-10)\n            return [0, 0, 0];\n        const scale = Vector3.dot(a, b) / bLenSq;\n        return Vector3.scale(b, scale);\n    },\n    /**\n     * Get the component of a perpendicular to b\n     */\n    reject(a, b) {\n        return Vector3.subtract(a, Vector3.project(a, b));\n    },\n    /**\n     * Convert to string for debugging\n     */\n    toString(v, precision = 4) {\n        return `[${v[0].toFixed(precision)}, ${v[1].toFixed(precision)}, ${v[2].toFixed(precision)}]`;\n    }\n};\n//# sourceMappingURL=vector3.js.map","/**\n * 3D Plane representation and operations for BeamTrace3D\n *\n * Plane is represented in implicit form: ax + by + cz + d = 0\n * where [a, b, c] is the normalized normal vector and d is the distance term.\n *\n * Points in front of the plane (positive side) satisfy ax + by + cz + d > 0\n */\nimport { Vector3 } from './vector3';\nexport const Plane3D = {\n    /**\n     * Create a plane from a normal vector and a point on the plane\n     */\n    fromNormalAndPoint(normal, point) {\n        const n = Vector3.normalize(normal);\n        const d = -Vector3.dot(n, point);\n        return { a: n[0], b: n[1], c: n[2], d };\n    },\n    /**\n     * Create a plane from three non-collinear points\n     * Uses counter-clockwise winding order: normal points toward viewer when\n     * p1 → p2 → p3 appears counter-clockwise\n     */\n    fromPoints(p1, p2, p3) {\n        const v1 = Vector3.subtract(p2, p1);\n        const v2 = Vector3.subtract(p3, p1);\n        const normal = Vector3.normalize(Vector3.cross(v1, v2));\n        return Plane3D.fromNormalAndPoint(normal, p1);\n    },\n    /**\n     * Create a plane directly from coefficients\n     */\n    create(a, b, c, d) {\n        return { a, b, c, d };\n    },\n    /**\n     * Get the normal vector of the plane\n     */\n    normal(plane) {\n        return [plane.a, plane.b, plane.c];\n    },\n    /**\n     * Signed distance from a point to the plane\n     * Positive = point is in front (on normal side)\n     * Negative = point is behind\n     * Zero = point is on the plane\n     */\n    signedDistance(point, plane) {\n        return plane.a * point[0] + plane.b * point[1] + plane.c * point[2] + plane.d;\n    },\n    /**\n     * Absolute distance from a point to the plane\n     */\n    distance(point, plane) {\n        return Math.abs(Plane3D.signedDistance(point, plane));\n    },\n    /**\n     * Classify a point relative to the plane\n     */\n    classifyPoint(point, plane, epsilon = 1e-6) {\n        const dist = Plane3D.signedDistance(point, plane);\n        if (dist > epsilon)\n            return 'front';\n        if (dist < -epsilon)\n            return 'back';\n        return 'on';\n    },\n    /**\n     * Check if a point is in front of the plane\n     */\n    isPointInFront(point, plane, epsilon = 1e-6) {\n        return Plane3D.signedDistance(point, plane) > epsilon;\n    },\n    /**\n     * Check if a point is behind the plane\n     */\n    isPointBehind(point, plane, epsilon = 1e-6) {\n        return Plane3D.signedDistance(point, plane) < -epsilon;\n    },\n    /**\n     * Check if a point is on the plane\n     */\n    isPointOn(point, plane, epsilon = 1e-6) {\n        return Math.abs(Plane3D.signedDistance(point, plane)) <= epsilon;\n    },\n    /**\n     * Mirror a point across the plane\n     * p' = p - 2 * signedDistance(p) * normal\n     */\n    mirrorPoint(point, plane) {\n        const dist = Plane3D.signedDistance(point, plane);\n        const normal = Plane3D.normal(plane);\n        return Vector3.subtract(point, Vector3.scale(normal, 2 * dist));\n    },\n    /**\n     * Mirror a plane across another plane (for fail plane propagation)\n     * This mirrors two points on the source plane and reconstructs.\n     */\n    mirrorPlane(planeToMirror, mirrorPlane) {\n        const n = Plane3D.normal(planeToMirror);\n        // Find a point on planeToMirror\n        let p1;\n        if (Math.abs(n[2]) > 0.5) {\n            p1 = [0, 0, -planeToMirror.d / planeToMirror.c];\n        }\n        else if (Math.abs(n[1]) > 0.5) {\n            p1 = [0, -planeToMirror.d / planeToMirror.b, 0];\n        }\n        else {\n            p1 = [-planeToMirror.d / planeToMirror.a, 0, 0];\n        }\n        // Second point offset along a tangent\n        const offset = Math.abs(n[0]) < 0.9 ? [1, 0, 0] : [0, 1, 0];\n        const tangent = Vector3.normalize(Vector3.cross(n, offset));\n        const p2 = Vector3.add(p1, tangent);\n        // Third point along bitangent\n        const bitangent = Vector3.cross(n, tangent);\n        const p3 = Vector3.add(p1, bitangent);\n        // Mirror all three points\n        const p1m = Plane3D.mirrorPoint(p1, mirrorPlane);\n        const p2m = Plane3D.mirrorPoint(p2, mirrorPlane);\n        const p3m = Plane3D.mirrorPoint(p3, mirrorPlane);\n        return Plane3D.fromPoints(p1m, p2m, p3m);\n    },\n    /**\n     * Flip the plane orientation (negate normal and d)\n     */\n    flip(plane) {\n        return { a: -plane.a, b: -plane.b, c: -plane.c, d: -plane.d };\n    },\n    /**\n     * Ray-plane intersection\n     *\n     * Returns the t parameter along the ray where intersection occurs,\n     * or null if the ray is parallel to the plane.\n     *\n     * Point of intersection = rayOrigin + t * rayDirection\n     *\n     * @param rayOrigin - Starting point of the ray\n     * @param rayDirection - Direction of the ray (should be normalized for t to represent distance)\n     * @param plane - The plane to intersect with\n     */\n    rayIntersection(rayOrigin, rayDirection, plane) {\n        const normal = Plane3D.normal(plane);\n        const denom = Vector3.dot(normal, rayDirection);\n        if (Math.abs(denom) < 1e-10) {\n            return null; // Ray is parallel to plane\n        }\n        const t = -(Vector3.dot(normal, rayOrigin) + plane.d) / denom;\n        return t;\n    },\n    /**\n     * Get the point of intersection between a ray and plane\n     */\n    rayIntersectionPoint(rayOrigin, rayDirection, plane) {\n        const t = Plane3D.rayIntersection(rayOrigin, rayDirection, plane);\n        if (t === null)\n            return null;\n        return Vector3.add(rayOrigin, Vector3.scale(rayDirection, t));\n    },\n    /**\n     * Project a point onto the plane\n     */\n    projectPoint(point, plane) {\n        const dist = Plane3D.signedDistance(point, plane);\n        const normal = Plane3D.normal(plane);\n        return Vector3.subtract(point, Vector3.scale(normal, dist));\n    },\n    /**\n     * Check if two planes are approximately equal\n     */\n    equals(a, b, epsilon = 1e-6) {\n        // Planes are equal if normals are parallel and d values are equal (or negated)\n        const dotNormals = a.a * b.a + a.b * b.b + a.c * b.c;\n        if (Math.abs(dotNormals - 1) < epsilon) {\n            // Same orientation\n            return Math.abs(a.d - b.d) < epsilon;\n        }\n        if (Math.abs(dotNormals + 1) < epsilon) {\n            // Opposite orientation\n            return Math.abs(a.d + b.d) < epsilon;\n        }\n        return false;\n    },\n    /**\n     * Convert to string for debugging\n     */\n    toString(plane, precision = 4) {\n        return `Plane3D(${plane.a.toFixed(precision)}x + ${plane.b.toFixed(precision)}y + ${plane.c.toFixed(precision)}z + ${plane.d.toFixed(precision)} = 0)`;\n    }\n};\n//# sourceMappingURL=plane3d.js.map","/**\n * 3D Polygon representation and operations for BeamTrace3D\n *\n * Polygons are convex and stored with counter-clockwise vertex winding\n * when viewed from the front (normal) side.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nexport const Polygon3D = {\n    /**\n     * Create a polygon from vertices (computes plane automatically)\n     * Vertices must be in counter-clockwise order when viewed from front\n     */\n    create(vertices, materialId) {\n        if (vertices.length < 3) {\n            throw new Error('Polygon requires at least 3 vertices');\n        }\n        // Clone vertices to prevent external mutation\n        const verts = vertices.map(v => Vector3.clone(v));\n        const plane = Plane3D.fromPoints(verts[0], verts[1], verts[2]);\n        return { vertices: verts, plane, materialId };\n    },\n    /**\n     * Create a polygon with an explicit plane (for split polygons that may be degenerate)\n     */\n    createWithPlane(vertices, plane, materialId) {\n        if (vertices.length < 3) {\n            throw new Error('Polygon requires at least 3 vertices');\n        }\n        const verts = vertices.map(v => Vector3.clone(v));\n        return { vertices: verts, plane, materialId };\n    },\n    /**\n     * Get the number of vertices\n     */\n    vertexCount(poly) {\n        return poly.vertices.length;\n    },\n    /**\n     * Compute the centroid (geometric center) of the polygon\n     */\n    centroid(poly) {\n        const sum = [0, 0, 0];\n        for (const v of poly.vertices) {\n            sum[0] += v[0];\n            sum[1] += v[1];\n            sum[2] += v[2];\n        }\n        const n = poly.vertices.length;\n        return [sum[0] / n, sum[1] / n, sum[2] / n];\n    },\n    /**\n     * Compute the area of the polygon using cross product method\n     */\n    area(poly) {\n        if (poly.vertices.length < 3)\n            return 0;\n        let total = [0, 0, 0];\n        const v0 = poly.vertices[0];\n        for (let i = 1; i < poly.vertices.length - 1; i++) {\n            const v1 = poly.vertices[i];\n            const v2 = poly.vertices[i + 1];\n            const cross = Vector3.cross(Vector3.subtract(v1, v0), Vector3.subtract(v2, v0));\n            total = Vector3.add(total, cross);\n        }\n        return 0.5 * Vector3.length(total);\n    },\n    /**\n     * Get the normal vector of the polygon (from the plane)\n     */\n    normal(poly) {\n        return Plane3D.normal(poly.plane);\n    },\n    /**\n     * Get edges as pairs of vertices [start, end]\n     */\n    edges(poly) {\n        const result = [];\n        for (let i = 0; i < poly.vertices.length; i++) {\n            const next = (i + 1) % poly.vertices.length;\n            result.push([poly.vertices[i], poly.vertices[next]]);\n        }\n        return result;\n    },\n    /**\n     * Classify the polygon relative to a plane\n     */\n    classify(poly, plane, epsilon = 1e-6) {\n        let front = 0;\n        let back = 0;\n        for (const v of poly.vertices) {\n            const classification = Plane3D.classifyPoint(v, plane, epsilon);\n            if (classification === 'front')\n                front++;\n            else if (classification === 'back')\n                back++;\n        }\n        if (front > 0 && back > 0)\n            return 'spanning';\n        if (front > 0)\n            return 'front';\n        if (back > 0)\n            return 'back';\n        return 'coplanar';\n    },\n    /**\n     * Check if a point is inside the polygon\n     * Assumes the point is on (or very close to) the polygon's plane\n     */\n    containsPoint(poly, point, epsilon = 1e-6) {\n        const normal = Plane3D.normal(poly.plane);\n        const n = poly.vertices.length;\n        for (let i = 0; i < n; i++) {\n            const v1 = poly.vertices[i];\n            const v2 = poly.vertices[(i + 1) % n];\n            const edge = Vector3.subtract(v2, v1);\n            const toPoint = Vector3.subtract(point, v1);\n            const cross = Vector3.cross(edge, toPoint);\n            // If cross product points opposite to normal, point is outside this edge\n            if (Vector3.dot(cross, normal) < -epsilon) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\n     * Ray-polygon intersection\n     * Returns t parameter and intersection point, or null if no hit\n     */\n    rayIntersection(rayOrigin, rayDirection, poly, epsilon = 1e-4) {\n        const t = Plane3D.rayIntersection(rayOrigin, rayDirection, poly.plane);\n        if (t === null || t < 0) {\n            return null;\n        }\n        const point = Vector3.add(rayOrigin, Vector3.scale(rayDirection, t));\n        // Use larger epsilon for point-in-polygon test to handle edge/corner cases\n        if (!Polygon3D.containsPoint(poly, point, epsilon)) {\n            return null;\n        }\n        return { t, point };\n    },\n    /**\n     * Create a bounding box for the polygon\n     */\n    boundingBox(poly) {\n        const min = [Infinity, Infinity, Infinity];\n        const max = [-Infinity, -Infinity, -Infinity];\n        for (const v of poly.vertices) {\n            min[0] = Math.min(min[0], v[0]);\n            min[1] = Math.min(min[1], v[1]);\n            min[2] = Math.min(min[2], v[2]);\n            max[0] = Math.max(max[0], v[0]);\n            max[1] = Math.max(max[1], v[1]);\n            max[2] = Math.max(max[2], v[2]);\n        }\n        return { min, max };\n    },\n    /**\n     * Check if polygon is degenerate (zero or near-zero area)\n     */\n    isDegenerate(poly, areaThreshold = 1e-10) {\n        return poly.vertices.length < 3 || Polygon3D.area(poly) < areaThreshold;\n    },\n    /**\n     * Flip the polygon winding (reverse vertex order and flip plane)\n     */\n    flip(poly) {\n        const reversedVerts = [...poly.vertices].reverse();\n        const flippedPlane = Plane3D.flip(poly.plane);\n        return {\n            vertices: reversedVerts,\n            plane: flippedPlane,\n            materialId: poly.materialId\n        };\n    },\n    /**\n     * Clone a polygon\n     */\n    clone(poly) {\n        return {\n            vertices: poly.vertices.map(v => Vector3.clone(v)),\n            plane: { ...poly.plane },\n            materialId: poly.materialId\n        };\n    },\n    /**\n     * Convert to string for debugging\n     */\n    toString(poly) {\n        const verts = poly.vertices.map(v => Vector3.toString(v, 2)).join(', ');\n        return `Polygon3D(${poly.vertices.length} vertices: [${verts}])`;\n    }\n};\n/**\n * Helper to create common room shapes\n */\nexport function createQuad(p1, p2, p3, p4, materialId) {\n    return Polygon3D.create([p1, p2, p3, p4], materialId);\n}\n/**\n * Create a shoebox room (6 walls as polygons)\n * Origin is at one corner, room extends in positive x, y, z\n */\nexport function createShoeboxRoom(width, // x dimension\ndepth, // y dimension\nheight, // z dimension\nfloorMaterial, ceilingMaterial, wallMaterial) {\n    // Corners\n    const v000 = [0, 0, 0];\n    const v100 = [width, 0, 0];\n    const v010 = [0, depth, 0];\n    const v110 = [width, depth, 0];\n    const v001 = [0, 0, height];\n    const v101 = [width, 0, height];\n    const v011 = [0, depth, height];\n    const v111 = [width, depth, height];\n    return [\n        // Floor (normal pointing up, CCW when viewed from above)\n        Polygon3D.create([v000, v100, v110, v010], floorMaterial),\n        // Ceiling (normal pointing down, CCW when viewed from below)\n        Polygon3D.create([v001, v011, v111, v101], ceilingMaterial),\n        // Front wall (y = 0, normal pointing +y)\n        Polygon3D.create([v000, v001, v101, v100], wallMaterial),\n        // Back wall (y = depth, normal pointing -y)\n        Polygon3D.create([v010, v110, v111, v011], wallMaterial),\n        // Left wall (x = 0, normal pointing +x)\n        Polygon3D.create([v000, v010, v011, v001], wallMaterial),\n        // Right wall (x = width, normal pointing -x)\n        Polygon3D.create([v100, v101, v111, v110], wallMaterial)\n    ];\n}\n//# sourceMappingURL=polygon3d.js.map","/**\n * Polygon splitting for BSP tree construction\n *\n * Splits a polygon by a plane into front and back pieces.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from './polygon3d';\n/**\n * Split a polygon by a plane\n *\n * Returns front and back pieces. Either may be null if the polygon\n * is entirely on one side of the plane.\n *\n * @param poly - The polygon to split\n * @param plane - The splitting plane\n * @param epsilon - Tolerance for point-on-plane classification\n */\nexport function splitPolygon(poly, plane, epsilon = 1e-4) {\n    const classification = Polygon3D.classify(poly, plane, epsilon);\n    // Fast path: polygon entirely on one side\n    if (classification === 'front' || classification === 'coplanar') {\n        return { front: poly, back: null };\n    }\n    if (classification === 'back') {\n        return { front: null, back: poly };\n    }\n    // Polygon spans the plane - need to split\n    const frontVerts = [];\n    const backVerts = [];\n    const n = poly.vertices.length;\n    for (let i = 0; i < n; i++) {\n        const v1 = poly.vertices[i];\n        const v2 = poly.vertices[(i + 1) % n];\n        const d1 = Plane3D.signedDistance(v1, plane);\n        const d2 = Plane3D.signedDistance(v2, plane);\n        const c1 = d1 > epsilon ? 'front' : d1 < -epsilon ? 'back' : 'on';\n        const c2 = d2 > epsilon ? 'front' : d2 < -epsilon ? 'back' : 'on';\n        // Add v1 to appropriate list(s)\n        if (c1 === 'front') {\n            frontVerts.push(v1);\n        }\n        else if (c1 === 'back') {\n            backVerts.push(v1);\n        }\n        else {\n            // On the plane - add to both sides\n            frontVerts.push(v1);\n            backVerts.push(v1);\n        }\n        // Check if edge crosses the plane\n        if ((c1 === 'front' && c2 === 'back') || (c1 === 'back' && c2 === 'front')) {\n            // Compute intersection point\n            const t = d1 / (d1 - d2);\n            const intersection = Vector3.lerp(v1, v2, t);\n            // Add intersection to both sides\n            frontVerts.push(intersection);\n            backVerts.push(intersection);\n        }\n    }\n    // Create result polygons if they have at least 3 vertices\n    const front = frontVerts.length >= 3\n        ? Polygon3D.createWithPlane(frontVerts, poly.plane, poly.materialId)\n        : null;\n    const back = backVerts.length >= 3\n        ? Polygon3D.createWithPlane(backVerts, poly.plane, poly.materialId)\n        : null;\n    return { front, back };\n}\n/**\n * Split multiple polygons by a plane\n *\n * Useful for BSP tree construction where multiple polygons need to be\n * partitioned by the same splitting plane.\n */\nexport function splitPolygons(polygons, plane, epsilon = 1e-4) {\n    const front = [];\n    const back = [];\n    const coplanar = [];\n    for (const poly of polygons) {\n        const classification = Polygon3D.classify(poly, plane, epsilon);\n        switch (classification) {\n            case 'coplanar':\n                coplanar.push(poly);\n                break;\n            case 'front':\n                front.push(poly);\n                break;\n            case 'back':\n                back.push(poly);\n                break;\n            case 'spanning': {\n                const { front: f, back: b } = splitPolygon(poly, plane, epsilon);\n                if (f)\n                    front.push(f);\n                if (b)\n                    back.push(b);\n                break;\n            }\n        }\n    }\n    return { front, back, coplanar };\n}\n//# sourceMappingURL=polygon-split.js.map","/**\n * 3D Polygon clipping using Sutherland-Hodgman algorithm\n *\n * This is the critical algorithm for clipping polygons against beam boundaries.\n * Clips a polygon against one or more planes, keeping the portion on the\n * front (positive) side of each plane.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from './polygon3d';\n/**\n * Clip a polygon against a single plane using Sutherland-Hodgman algorithm\n *\n * Keeps the portion on the FRONT side of the plane (where signedDistance > 0)\n *\n * @param poly - The polygon to clip\n * @param plane - The clipping plane (normal points toward kept region)\n * @param epsilon - Tolerance for point-on-plane classification\n * @returns The clipped polygon, or null if entirely clipped away\n */\nexport function clipPolygonByPlane(poly, plane, epsilon = 1e-4) {\n    const input = poly.vertices;\n    const output = [];\n    if (input.length < 3)\n        return null;\n    for (let i = 0; i < input.length; i++) {\n        const current = input[i];\n        const next = input[(i + 1) % input.length];\n        const dCurrent = Plane3D.signedDistance(current, plane);\n        const dNext = Plane3D.signedDistance(next, plane);\n        // Inside = on front side of plane (dCurrent >= -epsilon)\n        const currentInside = dCurrent >= -epsilon;\n        const nextInside = dNext >= -epsilon;\n        if (currentInside) {\n            // Current vertex is inside - add it\n            output.push(current);\n        }\n        // Check for edge crossing\n        if ((currentInside && !nextInside) || (!currentInside && nextInside)) {\n            // Edge crosses the plane - compute intersection\n            const t = dCurrent / (dCurrent - dNext);\n            const intersection = Vector3.lerp(current, next, Math.max(0, Math.min(1, t)));\n            output.push(intersection);\n        }\n    }\n    if (output.length < 3)\n        return null;\n    return Polygon3D.createWithPlane(output, poly.plane, poly.materialId);\n}\n/**\n * Clip a polygon against multiple planes (e.g., beam boundaries)\n *\n * The polygon must be on the front side of ALL planes to survive.\n * This is iterative Sutherland-Hodgman clipping.\n *\n * @param poly - The polygon to clip\n * @param planes - Array of clipping planes\n * @param epsilon - Tolerance for classification\n * @returns The clipped polygon, or null if entirely clipped away\n */\nexport function clipPolygonByPlanes(poly, planes, epsilon = 1e-4) {\n    let current = poly;\n    for (const plane of planes) {\n        if (!current)\n            return null;\n        current = clipPolygonByPlane(current, plane, epsilon);\n    }\n    return current;\n}\n/**\n * Quick rejection test - check if polygon is entirely outside any clipping plane\n *\n * This is faster than full clipping when we only need to know if the result\n * would be non-empty.\n *\n * @param poly - The polygon to test\n * @param planes - Array of clipping planes\n * @param epsilon - Tolerance for classification\n * @returns true if polygon is entirely outside at least one plane\n */\nexport function quickRejectPolygon(poly, planes, epsilon = 1e-4) {\n    for (const plane of planes) {\n        let allBehind = true;\n        for (const v of poly.vertices) {\n            if (Plane3D.signedDistance(v, plane) >= -epsilon) {\n                allBehind = false;\n                break;\n            }\n        }\n        if (allBehind) {\n            return true; // Polygon is entirely behind this plane\n        }\n    }\n    return false;\n}\n/**\n * Check if a polygon potentially intersects a convex volume defined by planes\n *\n * Returns false if the polygon is definitely outside the volume.\n * Returns true if it might be inside (requires full clipping to confirm).\n *\n * @param poly - The polygon to test\n * @param planes - Array of planes defining the convex volume (normals point inward)\n * @param epsilon - Tolerance for classification\n */\nexport function polygonMayIntersectVolume(poly, planes, epsilon = 1e-4) {\n    // Polygon is definitely outside if all vertices are behind any single plane\n    return !quickRejectPolygon(poly, planes, epsilon);\n}\n/**\n * Clip a polygon against a frustum (beam volume)\n *\n * A frustum is defined by multiple boundary planes. For beam tracing,\n * this is typically N edge planes + 1 aperture plane.\n *\n * @param poly - The polygon to clip\n * @param frustumPlanes - Array of planes defining the frustum (normals point inward)\n * @param epsilon - Tolerance for classification\n * @returns The clipped polygon, or null if entirely outside the frustum\n */\nexport function clipPolygonByFrustum(poly, frustumPlanes, epsilon = 1e-4) {\n    // Quick rejection first\n    if (quickRejectPolygon(poly, frustumPlanes, epsilon)) {\n        return null;\n    }\n    // Full clip\n    return clipPolygonByPlanes(poly, frustumPlanes, epsilon);\n}\n/**\n * Clip a ray segment against a convex volume defined by planes\n *\n * Returns the clipped segment [tMin, tMax] or null if ray misses the volume.\n *\n * @param rayOrigin - Start of the ray\n * @param rayDirection - Direction of the ray (normalized)\n * @param planes - Planes defining the convex volume (normals point inward)\n * @param tStart - Starting t value (default 0)\n * @param tEnd - Ending t value (default Infinity)\n */\nexport function clipRayByPlanes(rayOrigin, rayDirection, planes, tStart = 0, tEnd = Infinity) {\n    let tMin = tStart;\n    let tMax = tEnd;\n    for (const plane of planes) {\n        const normal = Plane3D.normal(plane);\n        const denom = Vector3.dot(normal, rayDirection);\n        const dist = Plane3D.signedDistance(rayOrigin, plane);\n        if (Math.abs(denom) < 1e-10) {\n            // Ray parallel to plane\n            if (dist < 0) {\n                // Ray origin is behind the plane - ray is outside\n                return null;\n            }\n            // Ray origin is in front - continue\n            continue;\n        }\n        const t = -dist / denom;\n        if (denom > 0) {\n            // Ray is going in the direction of the normal\n            if (dist >= 0) {\n                // Starting in front, ray goes further in front - no exit through this plane\n                // (t would be negative, meaning the plane is behind us)\n                // No constraint needed\n            }\n            else {\n                // Starting behind, ray will enter at t\n                tMin = Math.max(tMin, t);\n            }\n        }\n        else {\n            // Ray is going against the normal (denom < 0)\n            if (dist >= 0) {\n                // Starting in front, ray goes toward the plane and will exit at t\n                tMax = Math.min(tMax, t);\n            }\n            else {\n                // Starting behind, going further behind - ray never enters\n                return null;\n            }\n        }\n        if (tMin > tMax) {\n            return null; // Ray misses the volume\n        }\n    }\n    // Make sure tMax is positive (ray goes forward)\n    if (tMax < 0) {\n        return null;\n    }\n    // Clamp tMin to 0 if it's negative\n    tMin = Math.max(0, tMin);\n    if (tMin > tMax) {\n        return null;\n    }\n    return { tMin, tMax };\n}\n//# sourceMappingURL=clipping3d.js.map","/**\n * 3D Binary Space Partitioning (BSP) Tree\n *\n * Used for accelerated ray-polygon intersection queries.\n * Provides O(log n) ray tracing instead of O(n) brute force.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { splitPolygon } from '../geometry/polygon-split';\n/**\n * Build a BSP tree from an array of polygons\n *\n * @param polygons - Array of polygons to partition\n * @returns Root node of the BSP tree, or null if empty\n */\nexport function buildBSP(polygons) {\n    if (polygons.length === 0)\n        return null;\n    // Create indexed polygons to track original IDs through splits\n    const indexed = polygons.map((polygon, i) => ({\n        polygon,\n        originalId: i\n    }));\n    return buildBSPRecursive(indexed);\n}\n/**\n * Recursive BSP construction\n */\nfunction buildBSPRecursive(polygons) {\n    if (polygons.length === 0)\n        return null;\n    // Choose splitting polygon using heuristic\n    const splitterIndex = chooseSplitter(polygons);\n    const splitter = polygons[splitterIndex];\n    const plane = splitter.polygon.plane;\n    const frontPolys = [];\n    const backPolys = [];\n    // Partition remaining polygons\n    for (let i = 0; i < polygons.length; i++) {\n        if (i === splitterIndex)\n            continue;\n        const indexed = polygons[i];\n        const { front, back } = splitPolygon(indexed.polygon, plane);\n        // Preserve original ID through splits\n        if (front) {\n            frontPolys.push({ polygon: front, originalId: indexed.originalId });\n        }\n        if (back) {\n            backPolys.push({ polygon: back, originalId: indexed.originalId });\n        }\n    }\n    return {\n        plane,\n        polygon: splitter.polygon,\n        polygonId: splitter.originalId,\n        front: buildBSPRecursive(frontPolys),\n        back: buildBSPRecursive(backPolys)\n    };\n}\n/**\n * Choose the best splitting polygon using balance + split minimization heuristic\n *\n * The goal is to minimize:\n * 1. Number of polygon splits (expensive)\n * 2. Tree imbalance (affects query performance)\n */\nfunction chooseSplitter(polygons) {\n    if (polygons.length <= 3)\n        return 0;\n    let bestIndex = 0;\n    let bestScore = Infinity;\n    // Sample a subset for large polygon counts\n    const sampleSize = Math.min(polygons.length, 10);\n    const step = Math.max(1, Math.floor(polygons.length / sampleSize));\n    for (let i = 0; i < polygons.length; i += step) {\n        const plane = polygons[i].polygon.plane;\n        let front = 0;\n        let back = 0;\n        let splits = 0;\n        for (let j = 0; j < polygons.length; j++) {\n            if (i === j)\n                continue;\n            const classification = Polygon3D.classify(polygons[j].polygon, plane);\n            if (classification === 'front') {\n                front++;\n            }\n            else if (classification === 'back') {\n                back++;\n            }\n            else if (classification === 'spanning') {\n                front++;\n                back++;\n                splits++;\n            }\n            // coplanar polygons don't affect the score\n        }\n        // Score: heavily penalize splits, then minimize imbalance\n        const score = splits * 8 + Math.abs(front - back);\n        if (score < bestScore) {\n            bestScore = score;\n            bestIndex = i;\n        }\n    }\n    return bestIndex;\n}\n/**\n * Trace a ray through the BSP tree and find the first intersection\n *\n * @param origin - Ray origin point\n * @param direction - Ray direction (should be normalized for t to be distance)\n * @param node - BSP tree root node\n * @param tMin - Minimum t value to consider\n * @param tMax - Maximum t value to consider\n * @param ignoreId - Polygon ID to ignore (for avoiding self-intersection)\n * @returns First hit along the ray, or null if no hit\n */\nexport function rayTraceBSP(origin, direction, node, tMin = 0, tMax = Infinity, ignoreId = -1) {\n    if (!node)\n        return null;\n    // Classify ray origin relative to splitting plane\n    const dOrigin = Plane3D.signedDistance(origin, node.plane);\n    const normal = Plane3D.normal(node.plane);\n    const dDir = Vector3.dot(normal, direction);\n    // Determine near and far subtrees based on ray origin position\n    let near;\n    let far;\n    if (dOrigin >= 0) {\n        near = node.front;\n        far = node.back;\n    }\n    else {\n        near = node.back;\n        far = node.front;\n    }\n    // Calculate intersection with splitting plane\n    let tSplit = null;\n    if (Math.abs(dDir) > 1e-10) {\n        tSplit = -dOrigin / dDir;\n    }\n    let hit = null;\n    // IMPORTANT: BSP pruning optimization assumes polygons are coplanar with splitting planes.\n    // Since our polygons are finite and may not align with their node's splitting plane,\n    // we must check BOTH subtrees in all cases to ensure correctness.\n    if (tSplit === null || tSplit < tMin) {\n        // Check near side first\n        hit = rayTraceBSP(origin, direction, near, tMin, tMax, ignoreId);\n        // Check this node's polygon\n        if (!hit && node.polygonId !== ignoreId) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        // Also check far side\n        if (!hit) {\n            hit = rayTraceBSP(origin, direction, far, tMin, tMax, ignoreId);\n        }\n    }\n    else if (tSplit > tMax) {\n        // Check near side first\n        hit = rayTraceBSP(origin, direction, near, tMin, tMax, ignoreId);\n        // Check this node's polygon\n        if (!hit && node.polygonId !== ignoreId) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        // Also check far side\n        if (!hit) {\n            hit = rayTraceBSP(origin, direction, far, tMin, tMax, ignoreId);\n        }\n    }\n    else {\n        // Ray crosses the plane - check near side first\n        hit = rayTraceBSP(origin, direction, near, tMin, tSplit, ignoreId);\n        // If no hit in near subtree, check this node's polygon\n        if (!hit && node.polygonId !== ignoreId) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        // If still no hit, check far subtree\n        if (!hit) {\n            hit = rayTraceBSP(origin, direction, far, tSplit, tMax, ignoreId);\n        }\n    }\n    return hit;\n}\n// Debug flag - set to true to trace BSP traversal\nlet bspDebug = false;\nlet bspDebugDepth = 0;\nexport function setBSPDebug(enabled) {\n    bspDebug = enabled;\n    bspDebugDepth = 0;\n}\n/**\n * Trace a ray through the BSP tree, ignoring multiple polygon IDs\n *\n * @param origin - Ray origin point\n * @param direction - Ray direction (should be normalized for t to be distance)\n * @param node - BSP tree root node\n * @param tMin - Minimum t value to consider\n * @param tMax - Maximum t value to consider\n * @param ignoreIds - Set of polygon IDs to ignore\n * @returns First hit along the ray, or null if no hit\n */\nexport function rayTraceBSPMultiIgnore(origin, direction, node, tMin, tMax, ignoreIds) {\n    if (!node)\n        return null;\n    const indent = '  '.repeat(bspDebugDepth);\n    const dOrigin = Plane3D.signedDistance(origin, node.plane);\n    const normal = Plane3D.normal(node.plane);\n    const dDir = Vector3.dot(normal, direction);\n    let near;\n    let far;\n    if (dOrigin >= 0) {\n        near = node.front;\n        far = node.back;\n    }\n    else {\n        near = node.back;\n        far = node.front;\n    }\n    let tSplit = null;\n    if (Math.abs(dDir) > 1e-10) {\n        tSplit = -dOrigin / dDir;\n    }\n    if (bspDebug) {\n        console.log(`${indent}[BSP] Node ${node.polygonId}: dOrigin=${dOrigin.toFixed(3)}, dDir=${dDir.toFixed(3)}, tSplit=${tSplit?.toFixed(3) ?? 'null'}, tMin=${tMin.toFixed(3)}, tMax=${tMax.toFixed(3)}`);\n    }\n    let hit = null;\n    // IMPORTANT: BSP pruning optimization assumes polygons are coplanar with splitting planes.\n    // Since our polygons are finite and may not align with their node's splitting plane,\n    // we must check BOTH subtrees in all cases to ensure correctness.\n    // The tSplit value still helps us order the traversal (near first for early termination).\n    if (tSplit === null || tSplit < tMin) {\n        if (bspDebug) {\n            console.log(`${indent}  Case: tSplit null or < tMin, checking near then far`);\n        }\n        // Check near side first\n        bspDebugDepth++;\n        hit = rayTraceBSPMultiIgnore(origin, direction, near, tMin, tMax, ignoreIds);\n        bspDebugDepth--;\n        // Check this node's polygon\n        if (!hit && !ignoreIds.has(node.polygonId)) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (bspDebug) {\n                console.log(`${indent}  Checking node polygon ${node.polygonId}: ${polyHit ? `HIT t=${polyHit.t.toFixed(3)}` : 'NO HIT'}`);\n                if (polyHit) {\n                    console.log(`${indent}    In range [${tMin.toFixed(3)}, ${tMax.toFixed(3)}]? ${polyHit.t >= tMin && polyHit.t <= tMax}`);\n                }\n            }\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        else if (bspDebug && ignoreIds.has(node.polygonId)) {\n            console.log(`${indent}  Skipping node polygon ${node.polygonId} (in ignoreIds)`);\n        }\n        // Also check far side - polygons there might still intersect the ray\n        if (!hit) {\n            bspDebugDepth++;\n            hit = rayTraceBSPMultiIgnore(origin, direction, far, tMin, tMax, ignoreIds);\n            bspDebugDepth--;\n        }\n    }\n    else if (tSplit > tMax) {\n        if (bspDebug) {\n            console.log(`${indent}  Case: tSplit > tMax, checking near then far`);\n        }\n        // Check near side first\n        bspDebugDepth++;\n        hit = rayTraceBSPMultiIgnore(origin, direction, near, tMin, tMax, ignoreIds);\n        bspDebugDepth--;\n        // Check this node's polygon\n        if (!hit && !ignoreIds.has(node.polygonId)) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (bspDebug) {\n                console.log(`${indent}  Checking node polygon ${node.polygonId}: ${polyHit ? `HIT t=${polyHit.t.toFixed(3)}` : 'NO HIT'}`);\n                if (polyHit) {\n                    console.log(`${indent}    In range [${tMin.toFixed(3)}, ${tMax.toFixed(3)}]? ${polyHit.t >= tMin && polyHit.t <= tMax}`);\n                }\n            }\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        else if (bspDebug && ignoreIds.has(node.polygonId)) {\n            console.log(`${indent}  Skipping node polygon ${node.polygonId} (in ignoreIds)`);\n        }\n        // Also check far side - polygons there might still intersect the ray\n        if (!hit) {\n            bspDebugDepth++;\n            hit = rayTraceBSPMultiIgnore(origin, direction, far, tMin, tMax, ignoreIds);\n            bspDebugDepth--;\n        }\n    }\n    else {\n        if (bspDebug) {\n            console.log(`${indent}  Case: ray crosses plane at tSplit=${tSplit.toFixed(3)}`);\n        }\n        // Ray crosses the plane - check near side first, then node, then far side\n        bspDebugDepth++;\n        hit = rayTraceBSPMultiIgnore(origin, direction, near, tMin, tSplit, ignoreIds);\n        bspDebugDepth--;\n        if (!hit && !ignoreIds.has(node.polygonId)) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (bspDebug) {\n                console.log(`${indent}  Checking node polygon ${node.polygonId}: ${polyHit ? `HIT t=${polyHit.t.toFixed(3)}` : 'NO HIT'}`);\n                if (polyHit) {\n                    console.log(`${indent}    In range [${tMin.toFixed(3)}, ${tMax.toFixed(3)}]? ${polyHit.t >= tMin && polyHit.t <= tMax}`);\n                }\n            }\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        else if (bspDebug && ignoreIds.has(node.polygonId)) {\n            console.log(`${indent}  Skipping node polygon ${node.polygonId} (in ignoreIds)`);\n        }\n        if (!hit) {\n            bspDebugDepth++;\n            hit = rayTraceBSPMultiIgnore(origin, direction, far, tSplit, tMax, ignoreIds);\n            bspDebugDepth--;\n        }\n    }\n    if (bspDebug && hit) {\n        console.log(`${indent}  RETURNING HIT: polygon ${hit.polygonId} at t=${hit.t.toFixed(3)}`);\n    }\n    return hit;\n}\n/**\n * Check if a ray hits any polygon (occlusion test)\n *\n * Faster than rayTraceBSP when you only need to know if there's a hit,\n * not which polygon was hit.\n *\n * @param origin - Ray origin\n * @param direction - Ray direction\n * @param node - BSP tree root\n * @param tMin - Minimum t value\n * @param tMax - Maximum t value\n * @param ignoreId - Polygon ID to ignore\n * @returns true if ray hits something\n */\nexport function rayOccluded(origin, direction, node, tMin = 0, tMax = Infinity, ignoreId = -1) {\n    return rayTraceBSP(origin, direction, node, tMin, tMax, ignoreId) !== null;\n}\n/**\n * Find all polygons intersected by a ray (not just the first)\n *\n * Useful for debugging or special effects.\n */\nexport function rayTraceAll(origin, direction, node, tMin = 0, tMax = Infinity, ignoreId = -1) {\n    const hits = [];\n    rayTraceAllRecursive(origin, direction, node, tMin, tMax, ignoreId, hits);\n    // Sort by distance\n    hits.sort((a, b) => a.t - b.t);\n    return hits;\n}\nfunction rayTraceAllRecursive(origin, direction, node, tMin, tMax, ignoreId, hits) {\n    if (!node)\n        return;\n    const dOrigin = Plane3D.signedDistance(origin, node.plane);\n    const normal = Plane3D.normal(node.plane);\n    const dDir = Vector3.dot(normal, direction);\n    let near;\n    let far;\n    if (dOrigin >= 0) {\n        near = node.front;\n        far = node.back;\n    }\n    else {\n        near = node.back;\n        far = node.front;\n    }\n    let tSplit = null;\n    if (Math.abs(dDir) > 1e-10) {\n        tSplit = -dOrigin / dDir;\n    }\n    // Check this node's polygon\n    if (node.polygonId !== ignoreId) {\n        const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n        if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n            hits.push({\n                t: polyHit.t,\n                point: polyHit.point,\n                polygonId: node.polygonId,\n                polygon: node.polygon\n            });\n        }\n    }\n    // Recurse into both subtrees\n    if (tSplit === null || tSplit < tMin) {\n        rayTraceAllRecursive(origin, direction, near, tMin, tMax, ignoreId, hits);\n    }\n    else if (tSplit > tMax) {\n        rayTraceAllRecursive(origin, direction, near, tMin, tMax, ignoreId, hits);\n    }\n    else {\n        rayTraceAllRecursive(origin, direction, near, tMin, tSplit, ignoreId, hits);\n        rayTraceAllRecursive(origin, direction, far, tSplit, tMax, ignoreId, hits);\n    }\n}\n/**\n * Count the total number of nodes in the BSP tree\n */\nexport function countNodes(node) {\n    if (!node)\n        return 0;\n    return 1 + countNodes(node.front) + countNodes(node.back);\n}\n/**\n * Calculate the maximum depth of the BSP tree\n */\nexport function treeDepth(node) {\n    if (!node)\n        return 0;\n    return 1 + Math.max(treeDepth(node.front), treeDepth(node.back));\n}\n//# sourceMappingURL=bsp3d.js.map","/**\n * 3D Beam representation for BeamTrace3D\n *\n * A 3D beam is a polyhedral cone from a virtual source through an aperture polygon.\n * It is bounded by N+1 planes:\n * - N planes (one per aperture edge), with normals pointing INTO the beam\n * - 1 aperture plane, with normal pointing toward the source (INTO the beam)\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from '../geometry/polygon3d';\n/**\n * Construct boundary planes for a 3D beam\n *\n * All normals are oriented to point INTO the beam volume.\n * This means a point is inside the beam if it's on the front side\n * (positive signed distance) of all boundary planes.\n *\n * @param virtualSource - The virtual source position\n * @param aperture - The aperture polygon\n * @returns Array of boundary planes (N edge planes + 1 aperture plane)\n */\nexport function constructBeamBoundaryPlanes(virtualSource, aperture) {\n    const planes = [];\n    const edges = Polygon3D.edges(aperture);\n    const apertureCentroid = Polygon3D.centroid(aperture);\n    // Create a plane for each edge of the aperture\n    // Each plane passes through the virtual source and the edge vertices\n    for (const [v1, v2] of edges) {\n        // Create plane through virtualSource, v1, v2\n        // The winding order determines the normal direction\n        let edgePlane = Plane3D.fromPoints(virtualSource, v1, v2);\n        // Ensure normal points INTO the beam (toward aperture centroid)\n        if (Plane3D.signedDistance(apertureCentroid, edgePlane) < 0) {\n            edgePlane = Plane3D.flip(edgePlane);\n        }\n        planes.push(edgePlane);\n    }\n    // Aperture plane - normal should point AWAY from source (toward the \"open\" side of beam)\n    // This allows polygons beyond the aperture to be considered inside the beam\n    let aperturePlane = aperture.plane;\n    if (Plane3D.signedDistance(virtualSource, aperturePlane) > 0) {\n        aperturePlane = Plane3D.flip(aperturePlane);\n    }\n    planes.push(aperturePlane);\n    return planes;\n}\n/**\n * Create a Beam3D from virtual source and aperture\n */\nexport function createBeam3D(virtualSource, aperture, reflectingPolygonId) {\n    return {\n        virtualSource,\n        aperture,\n        boundaryPlanes: constructBeamBoundaryPlanes(virtualSource, aperture),\n        reflectingPolygonId\n    };\n}\n/**\n * Check if a point is inside the beam volume\n *\n * A point is inside if it's on the front (positive) side of all boundary planes.\n *\n * @param point - The point to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance for boundary tests\n */\nexport function isPointInBeam(point, beam, epsilon = 1e-4) {\n    for (const plane of beam.boundaryPlanes) {\n        if (Plane3D.signedDistance(point, plane) < -epsilon) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Find which boundary plane a point violates (if any)\n *\n * Returns null if the point is inside the beam.\n * Useful for fail plane detection - we want to know which boundary\n * caused the rejection.\n *\n * @param point - The point to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance for boundary tests\n */\nexport function findBeamViolation(point, beam, epsilon = 1e-4) {\n    const edgeCount = beam.boundaryPlanes.length - 1;\n    for (let i = 0; i < beam.boundaryPlanes.length; i++) {\n        const plane = beam.boundaryPlanes[i];\n        if (Plane3D.signedDistance(point, plane) < -epsilon) {\n            const type = i < edgeCount ? 'edge' : 'aperture';\n            return { plane, type, index: i };\n        }\n    }\n    return null;\n}\n/**\n * Get the minimum signed distance from a point to any beam boundary\n *\n * Positive means the point is inside by at least that distance.\n * Negative means the point is outside by that distance.\n */\nexport function distanceToBeamBoundary(point, beam) {\n    let minDist = Infinity;\n    for (const plane of beam.boundaryPlanes) {\n        const dist = Plane3D.signedDistance(point, plane);\n        minDist = Math.min(minDist, dist);\n    }\n    return minDist;\n}\n/**\n * Mirror a point across the reflecting polygon's plane\n * (Used to compute virtual sources)\n */\nexport function mirrorPointAcrossPolygon(point, polygon) {\n    return Plane3D.mirrorPoint(point, polygon.plane);\n}\n/**\n * Check if a polygon is potentially visible to the beam\n *\n * Quick rejection test: polygon must not be entirely behind any boundary plane.\n *\n * @param polygon - The polygon to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance\n */\nexport function polygonMayBeInBeam(polygon, beam, epsilon = 1e-4) {\n    for (const plane of beam.boundaryPlanes) {\n        let allBehind = true;\n        for (const v of polygon.vertices) {\n            if (Plane3D.signedDistance(v, plane) >= -epsilon) {\n                allBehind = false;\n                break;\n            }\n        }\n        if (allBehind) {\n            return false; // Polygon is entirely outside this boundary\n        }\n    }\n    return true;\n}\n/**\n * Check if the beam's virtual source can \"see\" a polygon\n * (Backface culling from virtual source's perspective)\n */\nexport function isPolygonFacingSource(polygon, virtualSource) {\n    const centroid = Polygon3D.centroid(polygon);\n    const toSource = Vector3.subtract(virtualSource, centroid);\n    const normal = Plane3D.normal(polygon.plane);\n    return Vector3.dot(normal, toSource) > 0;\n}\n/**\n * Compute the solid angle subtended by the aperture from the virtual source\n * (Useful for importance sampling and energy calculations)\n */\nexport function beamSolidAngle(beam) {\n    // Approximate solid angle using sum of triangular solid angles\n    const source = beam.virtualSource;\n    const verts = beam.aperture.vertices;\n    const n = verts.length;\n    let solidAngle = 0;\n    // Use first vertex as pivot for fan triangulation\n    for (let i = 1; i < n - 1; i++) {\n        const a = Vector3.normalize(Vector3.subtract(verts[0], source));\n        const b = Vector3.normalize(Vector3.subtract(verts[i], source));\n        const c = Vector3.normalize(Vector3.subtract(verts[i + 1], source));\n        // Compute solid angle of triangle using Oosterom-Strackee formula\n        const numerator = Math.abs(Vector3.dot(a, Vector3.cross(b, c)));\n        const denominator = 1 +\n            Vector3.dot(a, b) +\n            Vector3.dot(b, c) +\n            Vector3.dot(c, a);\n        solidAngle += 2 * Math.atan2(numerator, denominator);\n    }\n    return solidAngle;\n}\n//# sourceMappingURL=beam3d.js.map","/**\n * 3D Beam Tree for BeamTrace3D\n *\n * Hierarchical structure of beams representing all possible reflection paths\n * up to a maximum reflection order. Each node in the tree represents a\n * virtual source and aperture for a particular reflection sequence.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { clipPolygonByPlanes, quickRejectPolygon } from '../geometry/clipping3d';\nimport { constructBeamBoundaryPlanes, isPolygonFacingSource, mirrorPointAcrossPolygon } from './beam3d';\n/**\n * Minimum aperture area to consider (skip tiny apertures)\n */\nconst MIN_APERTURE_AREA = 1e-6;\n/**\n * Build a complete beam tree from source and room geometry\n *\n * @param sourcePosition - Position of the sound source\n * @param polygons - Room polygons (walls, floor, ceiling)\n * @param maxReflectionOrder - Maximum number of reflections to track\n * @returns Complete beam tree structure\n */\nexport function buildBeamTree3D(sourcePosition, polygons, maxReflectionOrder) {\n    // Create root node (source position, no reflection)\n    const root = {\n        id: -1,\n        parent: null,\n        virtualSource: Vector3.clone(sourcePosition),\n        children: []\n    };\n    // First order: source reflects off each visible polygon\n    // Only create first-order nodes if maxReflectionOrder >= 1\n    if (maxReflectionOrder >= 1) {\n        for (let i = 0; i < polygons.length; i++) {\n            const poly = polygons[i];\n            // Check if source can see this polygon (not backfacing)\n            if (!isPolygonFacingSource(poly, sourcePosition)) {\n                continue;\n            }\n            // Create virtual source by mirroring across polygon\n            const childVS = mirrorPointAcrossPolygon(sourcePosition, poly);\n            // First-order beam uses the full polygon as aperture\n            const childBoundaries = constructBeamBoundaryPlanes(childVS, poly);\n            const childNode = {\n                id: i,\n                parent: root,\n                virtualSource: childVS,\n                aperture: Polygon3D.clone(poly),\n                boundaryPlanes: childBoundaries,\n                children: []\n            };\n            root.children.push(childNode);\n            // Build higher-order reflections recursively\n            if (maxReflectionOrder > 1) {\n                buildBeamChildren(childNode, polygons, 2, maxReflectionOrder);\n            }\n        }\n    }\n    // Collect all leaf nodes for bucket optimization\n    const leafNodes = [];\n    collectLeafNodes(root, leafNodes);\n    return {\n        root,\n        leafNodes,\n        polygons,\n        maxReflectionOrder\n    };\n}\n/**\n * Recursively build child beams for higher-order reflections\n */\nfunction buildBeamChildren(node, polygons, currentOrder, maxOrder) {\n    if (currentOrder > maxOrder)\n        return;\n    if (!node.boundaryPlanes || !node.aperture)\n        return;\n    for (let i = 0; i < polygons.length; i++) {\n        // Skip the polygon we just reflected off (can't reflect off same surface twice in a row)\n        if (i === node.id)\n            continue;\n        const poly = polygons[i];\n        // Quick rejection: is polygon entirely outside beam?\n        if (quickRejectPolygon(poly, node.boundaryPlanes)) {\n            continue;\n        }\n        // Check if polygon is facing the virtual source (backface culling)\n        if (!isPolygonFacingSource(poly, node.virtualSource)) {\n            continue;\n        }\n        // Clip polygon to beam volume\n        const clipped = clipPolygonByPlanes(poly, node.boundaryPlanes);\n        if (!clipped)\n            continue;\n        // Skip tiny apertures\n        const area = Polygon3D.area(clipped);\n        if (area < MIN_APERTURE_AREA)\n            continue;\n        // Create child beam\n        const childVS = mirrorPointAcrossPolygon(node.virtualSource, poly);\n        const childBoundaries = constructBeamBoundaryPlanes(childVS, clipped);\n        const childNode = {\n            id: i,\n            parent: node,\n            virtualSource: childVS,\n            aperture: clipped,\n            boundaryPlanes: childBoundaries,\n            children: []\n        };\n        node.children.push(childNode);\n        // Continue recursion\n        if (currentOrder < maxOrder) {\n            buildBeamChildren(childNode, polygons, currentOrder + 1, maxOrder);\n        }\n    }\n}\n/**\n * Collect all leaf nodes (nodes with no children that have a valid aperture)\n */\nfunction collectLeafNodes(node, result) {\n    if (node.children.length === 0 && node.id !== -1) {\n        result.push(node);\n    }\n    for (const child of node.children) {\n        collectLeafNodes(child, result);\n    }\n}\n/**\n * Collect all nodes at a specific reflection order\n */\nexport function collectNodesAtOrder(tree, order) {\n    const result = [];\n    collectAtOrderRecursive(tree.root, 0, order, result);\n    return result;\n}\nfunction collectAtOrderRecursive(node, currentOrder, targetOrder, result) {\n    if (currentOrder === targetOrder && node.id !== -1) {\n        result.push(node);\n        return;\n    }\n    if (currentOrder >= targetOrder)\n        return;\n    for (const child of node.children) {\n        collectAtOrderRecursive(child, currentOrder + 1, targetOrder, result);\n    }\n}\n/**\n * Get the reflection order (depth) of a node\n */\nexport function getNodeOrder(node) {\n    let order = 0;\n    let current = node;\n    while (current && current.id !== -1) {\n        order++;\n        current = current.parent;\n    }\n    return order;\n}\n/**\n * Get the reflection path (polygon IDs) from root to a node\n */\nexport function getReflectionPath(node) {\n    const path = [];\n    let current = node;\n    while (current && current.id !== -1) {\n        path.unshift(current.id);\n        current = current.parent;\n    }\n    return path;\n}\n/**\n * Count total nodes in the beam tree\n */\nexport function countBeamNodes(tree) {\n    return countNodesRecursive(tree.root);\n}\nfunction countNodesRecursive(node) {\n    let count = 1;\n    for (const child of node.children) {\n        count += countNodesRecursive(child);\n    }\n    return count;\n}\nexport function getBeamTreeStats(tree) {\n    const nodesPerOrder = [];\n    let maxDepth = 0;\n    function traverse(node, depth) {\n        if (node.id !== -1) {\n            while (nodesPerOrder.length <= depth) {\n                nodesPerOrder.push(0);\n            }\n            nodesPerOrder[depth]++;\n            maxDepth = Math.max(maxDepth, depth);\n        }\n        for (const child of node.children) {\n            traverse(child, depth + 1);\n        }\n    }\n    traverse(tree.root, 0);\n    return {\n        totalNodes: countBeamNodes(tree),\n        leafNodes: tree.leafNodes.length,\n        maxDepth,\n        nodesPerOrder\n    };\n}\n/**\n * Clear all fail planes in the tree (reset optimization cache)\n */\nexport function clearFailPlanes(tree) {\n    clearFailPlanesRecursive(tree.root);\n}\nfunction clearFailPlanesRecursive(node) {\n    node.failPlane = undefined;\n    node.failPlaneType = undefined;\n    for (const child of node.children) {\n        clearFailPlanesRecursive(child);\n    }\n}\n/**\n * Iterate over all nodes in the tree (for batch operations)\n */\nexport function* iterateNodes(tree) {\n    yield* iterateNodesRecursive(tree.root);\n}\nfunction* iterateNodesRecursive(node) {\n    yield node;\n    for (const child of node.children) {\n        yield* iterateNodesRecursive(child);\n    }\n}\n//# sourceMappingURL=beamtree3d.js.map","/**\n * Fail Plane Optimization for BeamTrace3D\n *\n * The fail plane optimization caches the geometric reason why a path validation\n * failed, allowing O(1) rejection on subsequent frames when the listener moves.\n *\n * From the Laine et al. (2009) paper:\n * - Type 1 (polygon): Listener is behind the reflecting wall's plane\n * - Type 2 (beam): Listener is outside the beam volume (behind an edge plane)\n *\n * The fail plane is propagated (mirrored) through each reflection from the\n * detection node back to the leaf node for use in subsequent frames.\n */\nimport { Plane3D } from '../core/plane3d';\n/**\n * Detect fail plane for a listener position at a beam node\n *\n * This function determines which geometric constraint the listener violates,\n * and returns the corresponding fail plane.\n *\n * @param listenerPos - Current listener position\n * @param node - The beam node to check\n * @param polygons - Room polygons (for accessing the reflecting polygon)\n * @returns FailPlaneInfo if listener is outside, null if listener is valid\n */\nexport function detectFailPlane(listenerPos, node, polygons) {\n    if (!node.aperture || !node.boundaryPlanes) {\n        return null;\n    }\n    // Type 1: Check if listener is behind the reflecting polygon's plane\n    // The listener must be on the same side of the polygon as the virtual source\n    const reflectingPoly = polygons[node.id];\n    let polyPlane = reflectingPoly.plane;\n    // Orient plane so virtual source is in front\n    if (Plane3D.signedDistance(node.virtualSource, polyPlane) < 0) {\n        polyPlane = Plane3D.flip(polyPlane);\n    }\n    // If listener is behind the polygon plane, it can't receive reflections from this surface\n    if (Plane3D.signedDistance(listenerPos, polyPlane) < 0) {\n        return {\n            plane: polyPlane,\n            type: 'polygon',\n            nodeDepth: getNodeDepth(node)\n        };\n    }\n    // Type 2: Check beam boundaries\n    // Listener must be inside the beam volume (on front side of all boundary planes)\n    const edgeCount = node.boundaryPlanes.length - 1; // Last plane is aperture\n    for (let i = 0; i < node.boundaryPlanes.length; i++) {\n        const plane = node.boundaryPlanes[i];\n        if (Plane3D.signedDistance(listenerPos, plane) < 0) {\n            const type = i < edgeCount ? 'edge' : 'aperture';\n            return {\n                plane,\n                type,\n                nodeDepth: getNodeDepth(node)\n            };\n        }\n    }\n    return null;\n}\n/**\n * Get the depth of a node in the beam tree\n */\nfunction getNodeDepth(node) {\n    let depth = 0;\n    let current = node;\n    while (current && current.id !== -1) {\n        depth++;\n        current = current.parent;\n    }\n    return depth;\n}\n/**\n * Propagate a fail plane through the reflection chain\n *\n * When a fail plane is detected at some node, it needs to be mirrored\n * through each reflection surface to be valid for the leaf node.\n * This transforms the fail plane from the coordinate system at detection\n * to the coordinate system at the leaf.\n *\n * @param failPlane - The detected fail plane\n * @param fromNode - Node where failure was detected\n * @param toNode - Target node (usually leaf)\n * @param polygons - Room polygons for mirroring\n * @returns The propagated fail plane\n */\nexport function propagateFailPlane(failPlane, fromNode, toNode, polygons) {\n    let currentPlane = failPlane;\n    let current = fromNode;\n    // Walk from detection node toward root, mirroring at each reflection\n    while (current && current !== toNode && current.parent) {\n        if (current.id >= 0 && current.id < polygons.length) {\n            const reflectingPoly = polygons[current.id];\n            currentPlane = Plane3D.mirrorPlane(currentPlane, reflectingPoly.plane);\n        }\n        current = current.parent;\n    }\n    return currentPlane;\n}\n/**\n * Check if listener is still in the fail region (behind fail plane)\n *\n * This is the O(1) cache check that provides the speedup.\n * If the listener is behind the cached fail plane, we can skip\n * the expensive path validation.\n *\n * @param listenerPos - Current listener position\n * @param failPlane - Cached fail plane\n * @returns true if listener is behind the fail plane (path still invalid)\n */\nexport function isListenerBehindFailPlane(listenerPos, failPlane) {\n    return Plane3D.signedDistance(listenerPos, failPlane) < 0;\n}\n/**\n * Get the distance from listener to the fail plane\n *\n * Positive distance means listener is in front (valid side)\n * Negative distance means listener is behind (invalid side)\n *\n * This can be used to determine how far the listener needs to move\n * to potentially validate the path.\n */\nexport function distanceToFailPlane(listenerPos, failPlane) {\n    return Plane3D.signedDistance(listenerPos, failPlane);\n}\n/**\n * Find the minimum distance to any fail plane in a set of nodes\n *\n * Used by skip sphere optimization to determine sphere radius.\n */\nexport function minDistanceToFailPlanes(listenerPos, nodes) {\n    let minDist = Infinity;\n    for (const node of nodes) {\n        if (node.failPlane) {\n            const dist = Math.abs(Plane3D.signedDistance(listenerPos, node.failPlane));\n            minDist = Math.min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n/**\n * Update fail plane for a node after path validation fails\n *\n * Detects the fail plane and caches it on the node for future checks.\n *\n * @param node - The node that failed validation\n * @param listenerPos - Current listener position\n * @param polygons - Room polygons\n * @returns true if a fail plane was detected and cached\n */\nexport function updateNodeFailPlane(node, listenerPos, polygons) {\n    const failInfo = detectFailPlane(listenerPos, node, polygons);\n    if (failInfo) {\n        node.failPlane = failInfo.plane;\n        node.failPlaneType = failInfo.type;\n        return true;\n    }\n    return false;\n}\n/**\n * Clear fail plane cache from a node\n */\nexport function clearNodeFailPlane(node) {\n    node.failPlane = undefined;\n    node.failPlaneType = undefined;\n}\n/**\n * Check if a node has a cached fail plane\n */\nexport function hasFailPlane(node) {\n    return node.failPlane !== undefined;\n}\n//# sourceMappingURL=failplane3d.js.map","/**\n * Skip Sphere Optimization for BeamTrace3D\n *\n * The skip sphere optimization groups beam leaf nodes into buckets and\n * creates spatial rejection regions that allow skipping entire buckets\n * when the listener is inside the sphere.\n *\n * This is the 3D equivalent of the skip circle optimization from the\n * Laine et al. (2009) paper. When all paths in a bucket fail, a skip\n * sphere is created centered at the listener position with radius\n * equal to the minimum distance to any fail plane in the bucket.\n *\n * The paper found bucket size of 16 to be optimal for performance.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\n/**\n * Default bucket size (from paper: 16 nodes per bucket is optimal)\n */\nexport const DEFAULT_BUCKET_SIZE_3D = 16;\n/**\n * Create buckets from leaf nodes\n *\n * Nodes are grouped sequentially into buckets of the specified size.\n *\n * @param leafNodes - Array of leaf beam nodes\n * @param bucketSize - Number of nodes per bucket\n * @returns Array of buckets\n */\nexport function createBuckets3D(leafNodes, bucketSize = DEFAULT_BUCKET_SIZE_3D) {\n    const buckets = [];\n    for (let i = 0; i < leafNodes.length; i += bucketSize) {\n        buckets.push({\n            id: buckets.length,\n            nodes: leafNodes.slice(i, Math.min(i + bucketSize, leafNodes.length)),\n            skipSphere: null\n        });\n    }\n    return buckets;\n}\n/**\n * Check if a point is inside a skip sphere\n */\nexport function isInsideSkipSphere(point, skipSphere) {\n    const dist = Vector3.distance(point, skipSphere.center);\n    return dist < skipSphere.radius;\n}\n/**\n * Check skip sphere status for a bucket\n *\n * @param listenerPos - Current listener position\n * @param bucket - The bucket to check\n * @returns 'inside' if listener is inside skip sphere (can skip bucket),\n *          'outside' if listener escaped (must invalidate sphere),\n *          'none' if no skip sphere exists\n */\nexport function checkSkipSphere(listenerPos, bucket) {\n    if (!bucket.skipSphere) {\n        return 'none';\n    }\n    return isInsideSkipSphere(listenerPos, bucket.skipSphere) ? 'inside' : 'outside';\n}\n/**\n * Create a skip sphere for a bucket where all paths failed\n *\n * The radius is the minimum distance to any fail plane in the bucket.\n * This ensures that as long as the listener stays inside the sphere,\n * it will still be behind all fail planes and all paths will still fail.\n *\n * @param listenerPos - Current listener position (center of sphere)\n * @param nodes - Nodes in the bucket (all should have fail planes)\n * @returns Skip sphere, or null if any node lacks a fail plane\n */\nexport function createSkipSphere(listenerPos, nodes) {\n    let minDist = Infinity;\n    for (const node of nodes) {\n        if (!node.failPlane) {\n            // Can't create skip sphere if any node doesn't have a fail plane\n            return null;\n        }\n        // Distance to the fail plane (absolute value since we want sphere radius)\n        const dist = Math.abs(Plane3D.signedDistance(listenerPos, node.failPlane));\n        minDist = Math.min(minDist, dist);\n    }\n    // Don't create degenerate spheres\n    if (minDist === Infinity || minDist <= 1e-10) {\n        return null;\n    }\n    return {\n        center: Vector3.clone(listenerPos),\n        radius: minDist\n    };\n}\n/**\n * Invalidate a bucket's skip sphere\n *\n * Called when listener escapes the skip sphere.\n */\nexport function invalidateSkipSphere(bucket) {\n    bucket.skipSphere = null;\n}\n/**\n * Clear all fail planes in a bucket\n *\n * Called when skip sphere is invalidated to force re-evaluation.\n */\nexport function clearBucketFailPlanes(bucket) {\n    for (const node of bucket.nodes) {\n        node.failPlane = undefined;\n        node.failPlaneType = undefined;\n    }\n}\n/**\n * Update skip sphere for a bucket after processing\n *\n * If all paths in the bucket failed and all have fail planes,\n * create a skip sphere for future optimization.\n *\n * @param bucket - The bucket to update\n * @param listenerPos - Current listener position\n * @param allFailed - Whether all paths in bucket failed\n * @returns true if skip sphere was created\n */\nexport function updateBucketSkipSphere(bucket, listenerPos, allFailed) {\n    if (!allFailed) {\n        // At least one path succeeded, no skip sphere needed\n        return false;\n    }\n    // Check if all nodes have fail planes\n    for (const node of bucket.nodes) {\n        if (!node.failPlane) {\n            return false;\n        }\n    }\n    // Create skip sphere\n    bucket.skipSphere = createSkipSphere(listenerPos, bucket.nodes);\n    return bucket.skipSphere !== null;\n}\nexport function processBucketSkipSphere(bucket, listenerPos) {\n    const status = checkSkipSphere(listenerPos, bucket);\n    switch (status) {\n        case 'inside':\n            // Listener inside skip sphere - skip entire bucket\n            return { skip: true, needsRevalidation: false };\n        case 'outside':\n            // Listener escaped - need to invalidate and reprocess\n            invalidateSkipSphere(bucket);\n            clearBucketFailPlanes(bucket);\n            return { skip: false, needsRevalidation: true };\n        case 'none':\n        default:\n            // No skip sphere - normal processing\n            return { skip: false, needsRevalidation: false };\n    }\n}\nexport function getSkipSphereStats(buckets) {\n    let bucketsWithSphere = 0;\n    let totalRadius = 0;\n    let minRadius = Infinity;\n    let maxRadius = 0;\n    for (const bucket of buckets) {\n        if (bucket.skipSphere) {\n            bucketsWithSphere++;\n            totalRadius += bucket.skipSphere.radius;\n            minRadius = Math.min(minRadius, bucket.skipSphere.radius);\n            maxRadius = Math.max(maxRadius, bucket.skipSphere.radius);\n        }\n    }\n    return {\n        totalBuckets: buckets.length,\n        bucketsWithSphere,\n        averageRadius: bucketsWithSphere > 0 ? totalRadius / bucketsWithSphere : 0,\n        minRadius: minRadius === Infinity ? 0 : minRadius,\n        maxRadius\n    };\n}\n//# sourceMappingURL=skipsphere3d.js.map","/**\n * Optimized 3D Beam Tracing Solver\n *\n * Main solver that combines BSP tree, beam tree, fail plane, and skip sphere\n * optimizations for efficient acoustic path finding in 3D environments.\n *\n * Based on: Laine, S., Siltanen, S., Lokki, T., & Savioja, L. (2009).\n * \"Accelerated beam tracing algorithm.\" Applied Acoustics, 70(1), 172-181.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { Plane3D } from '../core/plane3d';\nimport { buildBSP, rayTraceBSP, rayTraceBSPMultiIgnore } from '../structures/bsp3d';\nimport { buildBeamTree3D, clearFailPlanes } from '../structures/beamtree3d';\nimport { detectFailPlane, isListenerBehindFailPlane } from '../optimization/failplane3d';\nimport { createBuckets3D, checkSkipSphere, createSkipSphere, invalidateSkipSphere, clearBucketFailPlanes, DEFAULT_BUCKET_SIZE_3D } from '../optimization/skipsphere3d';\n/**\n * Optimized 3D Beam Tracing Solver\n *\n * Provides efficient acoustic path finding using:\n * - BSP tree for O(log n) ray-polygon intersection\n * - Beam tree for reflection path enumeration\n * - Fail plane caching for O(1) early rejection\n * - Skip sphere bucketing for spatial acceleration\n */\nexport class OptimizedSolver3D {\n    /**\n     * Create a new 3D beam tracing solver\n     *\n     * @param polygons - Room geometry as an array of polygons\n     * @param sourcePosition - Position of the sound source\n     * @param config - Optional configuration\n     */\n    constructor(polygons, sourcePosition, config = {}) {\n        const maxOrder = config.maxReflectionOrder ?? 5;\n        const bucketSize = config.bucketSize ?? DEFAULT_BUCKET_SIZE_3D;\n        this.polygons = polygons;\n        this.sourcePosition = Vector3.clone(sourcePosition);\n        this.epsilon = config.epsilon ?? 1e-4;\n        // Build BSP tree for ray tracing\n        this.bspRoot = buildBSP(polygons);\n        // Build beam tree for reflection enumeration\n        this.beamTree = buildBeamTree3D(sourcePosition, polygons, maxOrder);\n        // Create buckets for skip sphere optimization\n        this.buckets = createBuckets3D(this.beamTree.leafNodes, bucketSize);\n        // Initialize metrics\n        this.metrics = this.createEmptyMetrics();\n        this.metrics.totalLeafNodes = this.beamTree.leafNodes.length;\n        this.metrics.bucketsTotal = this.buckets.length;\n    }\n    /**\n     * Get all valid reflection paths from source to listener\n     *\n     * @param listenerPos - Position of the listener\n     * @returns Array of valid reflection paths\n     */\n    getPaths(listenerPos) {\n        this.resetMetrics();\n        const validPaths = [];\n        // 1. Check direct path (order 0)\n        const directPath = this.validateDirectPath(listenerPos);\n        if (directPath) {\n            validPaths.push(directPath);\n        }\n        // 2. Check intermediate reflection orders (non-leaf nodes)\n        const intermediatePaths = this.findIntermediatePaths(listenerPos, this.beamTree.root);\n        validPaths.push(...intermediatePaths);\n        // 3. Process leaf nodes with bucket optimization\n        for (const bucket of this.buckets) {\n            const skipStatus = checkSkipSphere(listenerPos, bucket);\n            if (skipStatus === 'inside') {\n                // Listener inside skip sphere - skip entire bucket\n                this.metrics.bucketsSkipped++;\n                continue;\n            }\n            if (skipStatus === 'outside') {\n                // Listener escaped - invalidate sphere and clear fail planes\n                invalidateSkipSphere(bucket);\n                clearBucketFailPlanes(bucket);\n            }\n            this.metrics.bucketsChecked++;\n            let allFailed = true;\n            let allHaveFailPlanes = true;\n            for (const node of bucket.nodes) {\n                // Check fail plane cache first (O(1))\n                if (node.failPlane && isListenerBehindFailPlane(listenerPos, node.failPlane)) {\n                    this.metrics.failPlaneCacheHits++;\n                    continue;\n                }\n                // Fail plane was invalidated or listener escaped\n                if (node.failPlane) {\n                    node.failPlane = undefined;\n                    node.failPlaneType = undefined;\n                    this.metrics.failPlaneCacheMisses++;\n                }\n                // Full path validation\n                const result = this.validatePath(listenerPos, node);\n                if (result.valid && result.path) {\n                    validPaths.push(result.path);\n                    allFailed = false;\n                    allHaveFailPlanes = false;\n                }\n                else if (!node.failPlane) {\n                    allHaveFailPlanes = false;\n                }\n            }\n            // Create skip sphere if all paths failed with fail planes\n            if (allFailed && allHaveFailPlanes && bucket.nodes.length > 0) {\n                bucket.skipSphere = createSkipSphere(listenerPos, bucket.nodes);\n                if (bucket.skipSphere) {\n                    this.metrics.skipSphereCount++;\n                }\n            }\n        }\n        this.metrics.validPathCount = validPaths.length;\n        return validPaths;\n    }\n    /**\n     * Get all valid reflection paths with detailed information about each reflection.\n     *\n     * This method returns the same paths as getPaths() but with additional details:\n     * - Angle of incidence and reflection at each surface\n     * - Surface normal vectors\n     * - Segment lengths and cumulative distances\n     * - Grazing incidence detection\n     *\n     * @param listenerPos - Position of the listener\n     * @returns Array of detailed reflection paths\n     */\n    getDetailedPaths(listenerPos) {\n        const simplePaths = this.getPaths(listenerPos);\n        return simplePaths.map(path => convertToDetailedPath3D(path, this.polygons));\n    }\n    /**\n     * Validate the direct path from listener to source\n     */\n    validateDirectPath(listenerPos) {\n        const direction = Vector3.subtract(this.sourcePosition, listenerPos);\n        const dist = Vector3.length(direction);\n        const dir = Vector3.normalize(direction);\n        this.metrics.raycastCount++;\n        const hit = rayTraceBSP(listenerPos, dir, this.bspRoot, 0, dist, -1);\n        // If something blocks the path before reaching source, no direct path\n        if (hit && hit.t < dist - this.epsilon) {\n            return null;\n        }\n        return [\n            { position: Vector3.clone(listenerPos), polygonId: null },\n            { position: Vector3.clone(this.sourcePosition), polygonId: null }\n        ];\n    }\n    /**\n     * Find paths through intermediate (non-leaf) nodes\n     *\n     * These are lower-order reflections that didn't spawn further children.\n     */\n    findIntermediatePaths(listenerPos, node) {\n        const paths = [];\n        // Process children recursively\n        for (const child of node.children) {\n            if (child.children.length > 0) {\n                // Has children - recurse\n                paths.push(...this.findIntermediatePaths(listenerPos, child));\n            }\n        }\n        // Try this node if it has an aperture (is a reflection, not root)\n        if (node.id !== -1 && node.aperture) {\n            const path = this.traverseBeam(listenerPos, node);\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    /**\n     * Traverse a beam from listener to source, building the reflection path\n     */\n    traverseBeam(listenerPos, node, debug = false) {\n        const pathPoints = [\n            { position: Vector3.clone(listenerPos), polygonId: null }\n        ];\n        // Build polygon path for logging\n        const polygonPath = [];\n        let tempNode = node;\n        while (tempNode && tempNode.id !== -1) {\n            polygonPath.unshift(tempNode.id);\n            tempNode = tempNode.parent;\n        }\n        if (debug) {\n            console.log(`[traverseBeam] Exploring beam with polygonPath: [${polygonPath.join(', ')}]`);\n            console.log(`  Listener: [${listenerPos[0].toFixed(3)}, ${listenerPos[1].toFixed(3)}, ${listenerPos[2].toFixed(3)}]`);\n            console.log(`  Virtual source: [${node.virtualSource[0].toFixed(3)}, ${node.virtualSource[1].toFixed(3)}, ${node.virtualSource[2].toFixed(3)}]`);\n        }\n        let currentPoint = listenerPos;\n        let currentNode = node;\n        // Track all polygon IDs that should be ignored in occlusion checks\n        // (the polygon we're coming from and the polygon we're going to)\n        const ignoreIds = new Set();\n        let segmentIndex = 0;\n        // Walk from leaf to root, finding reflection points\n        while (currentNode && currentNode.id !== -1) {\n            const poly = this.polygons[currentNode.id];\n            const imageSource = currentNode.virtualSource;\n            // Direction from current point toward virtual source\n            const dir = Vector3.normalize(Vector3.subtract(imageSource, currentPoint));\n            // Find intersection with reflecting polygon\n            const hit = Polygon3D.rayIntersection(currentPoint, dir, poly);\n            if (!hit) {\n                if (debug) {\n                    console.log(`  [Segment ${segmentIndex}] FAIL: No intersection with polygon ${currentNode.id}`);\n                }\n                return null;\n            }\n            if (debug) {\n                console.log(`  [Segment ${segmentIndex}] Ray from [${currentPoint[0].toFixed(3)}, ${currentPoint[1].toFixed(3)}, ${currentPoint[2].toFixed(3)}]`);\n                console.log(`    Direction: [${dir[0].toFixed(3)}, ${dir[1].toFixed(3)}, ${dir[2].toFixed(3)}]`);\n                console.log(`    Hit polygon ${currentNode.id} at t=${hit.t.toFixed(3)}, point=[${hit.point[0].toFixed(3)}, ${hit.point[1].toFixed(3)}, ${hit.point[2].toFixed(3)}]`);\n            }\n            // Check for occlusion between current point and reflection point\n            // We need to ignore:\n            // - The polygon we just came from (already in ignoreIds from previous iteration)\n            // - The polygon we're reflecting to (currentNode.id) since it's at the endpoint\n            ignoreIds.add(currentNode.id);\n            this.metrics.raycastCount++;\n            const occluder = rayTraceBSPMultiIgnore(currentPoint, dir, this.bspRoot, this.epsilon, hit.t - this.epsilon, ignoreIds);\n            if (occluder) {\n                if (debug) {\n                    console.log(`    OCCLUDED by polygon ${occluder.polygonId} at t=${occluder.t.toFixed(3)}, point=[${occluder.point[0].toFixed(3)}, ${occluder.point[1].toFixed(3)}, ${occluder.point[2].toFixed(3)}]`);\n                    console.log(`    ignoreIds: [${Array.from(ignoreIds).join(', ')}]`);\n                }\n                return null;\n            }\n            if (debug) {\n                console.log(`    OK - no occlusion (ignoreIds: [${Array.from(ignoreIds).join(', ')}])`);\n            }\n            // Add reflection point to path\n            pathPoints.push({\n                position: Vector3.clone(hit.point),\n                polygonId: currentNode.id\n            });\n            currentPoint = hit.point;\n            // Keep the current polygon in ignoreIds for the next segment\n            // (we're leaving from this polygon)\n            currentNode = currentNode.parent;\n            segmentIndex++;\n        }\n        // Final segment to actual source\n        if (currentNode) {\n            const dir = Vector3.normalize(Vector3.subtract(currentNode.virtualSource, currentPoint));\n            const dist = Vector3.distance(currentNode.virtualSource, currentPoint);\n            if (debug) {\n                console.log(`  [Final segment] Ray from [${currentPoint[0].toFixed(3)}, ${currentPoint[1].toFixed(3)}, ${currentPoint[2].toFixed(3)}]`);\n                console.log(`    To source: [${currentNode.virtualSource[0].toFixed(3)}, ${currentNode.virtualSource[1].toFixed(3)}, ${currentNode.virtualSource[2].toFixed(3)}]`);\n                console.log(`    Direction: [${dir[0].toFixed(3)}, ${dir[1].toFixed(3)}, ${dir[2].toFixed(3)}]`);\n                console.log(`    Distance: ${dist.toFixed(3)}`);\n                console.log(`    tMin: ${this.epsilon}, tMax: ${(dist - this.epsilon).toFixed(6)}`);\n                console.log(`    ignoreIds: [${Array.from(ignoreIds).join(', ')}]`);\n                // Check intersection with back1 (inner wall at y=5.575)\n                // If segment crosses y=5.575, calculate where\n                const p1 = currentPoint;\n                const p2 = currentNode.virtualSource;\n                if ((p1[1] < 5.575 && p2[1] > 5.575) || (p1[1] > 5.575 && p2[1] < 5.575)) {\n                    const t = (5.575 - p1[1]) / (p2[1] - p1[1]);\n                    const xAtCross = p1[0] + t * (p2[0] - p1[0]);\n                    const zAtCross = p1[2] + t * (p2[2] - p1[2]);\n                    console.log(`    CROSSING y=5.575 at t=${t.toFixed(3)}, x=${xAtCross.toFixed(3)}, z=${zAtCross.toFixed(3)}`);\n                    console.log(`    back1 spans: x=[6.215, 12.43], z=[0, 4.877]`);\n                    if (xAtCross >= 6.215 && xAtCross <= 12.43 && zAtCross >= 0 && zAtCross <= 4.877) {\n                        console.log(`    *** SHOULD HIT back1 (polygons 3, 4) ***`);\n                        // Direct ray test against polygons 3 and 4\n                        console.log(`    Direct polygon intersection test:`);\n                        for (const polyId of [3, 4]) {\n                            const poly = this.polygons[polyId];\n                            const testHit = Polygon3D.rayIntersection(currentPoint, dir, poly);\n                            if (testHit) {\n                                console.log(`      Polygon ${polyId}: HIT at t=${testHit.t.toFixed(3)}, point=[${testHit.point[0].toFixed(3)}, ${testHit.point[1].toFixed(3)}, ${testHit.point[2].toFixed(3)}]`);\n                            }\n                            else {\n                                console.log(`      Polygon ${polyId}: NO HIT`);\n                                // Debug: show polygon vertices\n                                console.log(`        Vertices: ${poly.vertices.map(v => `[${v[0].toFixed(2)}, ${v[1].toFixed(2)}, ${v[2].toFixed(2)}]`).join(', ')}`);\n                            }\n                        }\n                    }\n                }\n            }\n            this.metrics.raycastCount++;\n            // Use the same ignoreIds set which contains all polygons in the reflection chain\n            const tMinVal = this.epsilon;\n            const tMaxVal = dist - this.epsilon;\n            const finalHit = rayTraceBSPMultiIgnore(currentPoint, dir, this.bspRoot, tMinVal, tMaxVal, ignoreIds);\n            if (finalHit) {\n                if (debug) {\n                    console.log(`    OCCLUDED by polygon ${finalHit.polygonId} at t=${finalHit.t.toFixed(3)}, point=[${finalHit.point[0].toFixed(3)}, ${finalHit.point[1].toFixed(3)}, ${finalHit.point[2].toFixed(3)}]`);\n                }\n                return null;\n            }\n            if (debug) {\n                console.log(`    OK - path valid!`);\n            }\n            // Add source point\n            pathPoints.push({\n                position: Vector3.clone(currentNode.virtualSource),\n                polygonId: null\n            });\n        }\n        return pathPoints;\n    }\n    /**\n     * Validate a path through a beam node\n     */\n    validatePath(listenerPos, leafNode) {\n        const path = this.traverseBeam(listenerPos, leafNode);\n        if (path) {\n            return { valid: true, path };\n        }\n        // Path failed - try to detect and cache fail plane\n        const failInfo = detectFailPlane(listenerPos, leafNode, this.polygons);\n        if (failInfo) {\n            leafNode.failPlane = failInfo.plane;\n            leafNode.failPlaneType = failInfo.type;\n        }\n        return { valid: false, path: null };\n    }\n    /**\n     * Get performance metrics from the last getPaths() call\n     */\n    getMetrics() {\n        return { ...this.metrics };\n    }\n    /**\n     * Debug a specific beam path by polygon IDs\n     * Logs detailed information about the path validation process\n     */\n    debugBeamPath(listenerPos, polygonPath) {\n        console.log('=== DEBUG BEAM PATH ===');\n        console.log(`Listener: [${listenerPos[0].toFixed(3)}, ${listenerPos[1].toFixed(3)}, ${listenerPos[2].toFixed(3)}]`);\n        console.log(`Polygon path: [${polygonPath.join(', ')}]`);\n        console.log(`Source: [${this.sourcePosition[0].toFixed(3)}, ${this.sourcePosition[1].toFixed(3)}, ${this.sourcePosition[2].toFixed(3)}]`);\n        // Find the beam node matching this polygon path\n        const findNode = (node, path, depth) => {\n            if (depth === path.length) {\n                return node;\n            }\n            for (const child of node.children) {\n                if (child.id === path[depth]) {\n                    return findNode(child, path, depth + 1);\n                }\n            }\n            return null;\n        };\n        const targetNode = findNode(this.beamTree.root, polygonPath, 0);\n        if (!targetNode) {\n            console.log('ERROR: Could not find beam node for this polygon path');\n            return;\n        }\n        console.log(`Found beam node with virtual source: [${targetNode.virtualSource[0].toFixed(3)}, ${targetNode.virtualSource[1].toFixed(3)}, ${targetNode.virtualSource[2].toFixed(3)}]`);\n        // Run traverseBeam with debug enabled\n        const result = this.traverseBeam(listenerPos, targetNode, true);\n        if (result) {\n            console.log('PATH VALID - returned path:');\n            for (let i = 0; i < result.length; i++) {\n                const p = result[i];\n                console.log(`  [${i}] pos=[${p.position[0].toFixed(3)}, ${p.position[1].toFixed(3)}, ${p.position[2].toFixed(3)}], polygonId=${p.polygonId}`);\n            }\n        }\n        else {\n            console.log('PATH INVALID');\n        }\n        console.log('=== END DEBUG ===');\n    }\n    /**\n     * Clear all cached fail planes and skip spheres\n     *\n     * Call this if the room geometry changes.\n     */\n    clearCache() {\n        clearFailPlanes(this.beamTree);\n        for (const bucket of this.buckets) {\n            invalidateSkipSphere(bucket);\n        }\n    }\n    /**\n     * Get the number of leaf nodes in the beam tree\n     */\n    getLeafNodeCount() {\n        return this.beamTree.leafNodes.length;\n    }\n    /**\n     * Get the maximum reflection order\n     */\n    getMaxReflectionOrder() {\n        return this.beamTree.maxReflectionOrder;\n    }\n    /**\n     * Get the source position\n     */\n    getSourcePosition() {\n        return Vector3.clone(this.sourcePosition);\n    }\n    /**\n     * Get beam data for visualization\n     * Returns beams organized by reflection order\n     */\n    getBeamsForVisualization(maxOrder) {\n        const beams = [];\n        const effectiveMaxOrder = maxOrder ?? this.beamTree.maxReflectionOrder;\n        const traverse = (node, order, pathSoFar) => {\n            if (order > effectiveMaxOrder)\n                return;\n            // Build the current path including this node's polygon\n            const currentPath = node.id !== -1 ? [...pathSoFar, node.id] : pathSoFar;\n            if (node.id !== -1 && node.aperture) {\n                beams.push({\n                    virtualSource: Vector3.clone(node.virtualSource),\n                    apertureVertices: node.aperture.vertices.map(v => Vector3.clone(v)),\n                    reflectionOrder: order,\n                    polygonId: node.id,\n                    polygonPath: currentPath\n                });\n            }\n            for (const child of node.children) {\n                traverse(child, order + 1, currentPath);\n            }\n        };\n        traverse(this.beamTree.root, 0, []);\n        return beams;\n    }\n    /**\n     * Create empty metrics object\n     */\n    createEmptyMetrics() {\n        return {\n            totalLeafNodes: 0,\n            bucketsTotal: 0,\n            bucketsSkipped: 0,\n            bucketsChecked: 0,\n            failPlaneCacheHits: 0,\n            failPlaneCacheMisses: 0,\n            raycastCount: 0,\n            skipSphereCount: 0,\n            validPathCount: 0\n        };\n    }\n    /**\n     * Reset metrics for a new getPaths() call\n     */\n    resetMetrics() {\n        const total = this.metrics.totalLeafNodes;\n        const buckets = this.metrics.bucketsTotal;\n        this.metrics = this.createEmptyMetrics();\n        this.metrics.totalLeafNodes = total;\n        this.metrics.bucketsTotal = buckets;\n    }\n}\n/**\n * Compute the total path length of a reflection path\n */\nexport function computePathLength(path) {\n    let length = 0;\n    for (let i = 1; i < path.length; i++) {\n        length += Vector3.distance(path[i - 1].position, path[i].position);\n    }\n    return length;\n}\n/**\n * Compute arrival time for a path (assuming speed of sound)\n */\nexport function computeArrivalTime(path, speedOfSound = 343) {\n    return computePathLength(path) / speedOfSound;\n}\n/**\n * Get the reflection order of a path (number of reflections)\n */\nexport function getPathReflectionOrder(path) {\n    // Count points with non-null polygonId (reflection points)\n    return path.filter(p => p.polygonId !== null).length;\n}\n// ============================================================\n// Helper functions for detailed path information\n// ============================================================\n/** Threshold angle (radians from 90°) for marking reflections as grazing */\nconst GRAZING_THRESHOLD_3D = 0.05; // ~3 degrees from grazing\n/**\n * Calculate the incidence angle between an incoming direction and surface normal.\n * Returns angle in radians (0 = perpendicular to surface, π/2 = grazing).\n */\nfunction calculateIncidenceAngle3D(incomingDir, surfaceNormal) {\n    // The incoming direction points toward the surface, so we use -incomingDir\n    // Angle of incidence is measured from the normal\n    const cosAngle = Math.abs(Vector3.dot(Vector3.negate(incomingDir), surfaceNormal));\n    // Clamp to [-1, 1] to handle floating point errors\n    const clampedCos = Math.max(-1, Math.min(1, cosAngle));\n    return Math.acos(clampedCos);\n}\n/**\n * Get the surface normal oriented toward the incoming ray.\n * This ensures the normal always points toward the side the ray came from.\n */\nfunction getOrientedNormal3D(polygon, incomingDir) {\n    const normal = Plane3D.normal(polygon.plane);\n    // If ray is coming from the back side, flip the normal\n    const dot = Vector3.dot(incomingDir, normal);\n    if (dot > 0) {\n        return Vector3.negate(normal);\n    }\n    return Vector3.clone(normal);\n}\n/**\n * Convert a simple reflection path to a detailed path with full reflection information.\n *\n * @param path - The simple reflection path from getPaths()\n * @param polygons - The room polygons (to look up polygon info by ID)\n * @returns Detailed path information including angles, normals, and distances\n */\nexport function convertToDetailedPath3D(path, polygons) {\n    if (path.length < 2) {\n        throw new Error('Path must have at least 2 points (listener and source)');\n    }\n    const listenerPosition = Vector3.clone(path[0].position);\n    const sourcePosition = Vector3.clone(path[path.length - 1].position);\n    const reflections = [];\n    const segments = [];\n    let cumulativeDistance = 0;\n    // Process each segment and reflection\n    for (let i = 0; i < path.length - 1; i++) {\n        const startPoint = path[i].position;\n        const endPoint = path[i + 1].position;\n        // Calculate segment info\n        const segmentLength = Vector3.distance(startPoint, endPoint);\n        segments.push({\n            startPoint: Vector3.clone(startPoint),\n            endPoint: Vector3.clone(endPoint),\n            length: segmentLength,\n            segmentIndex: i\n        });\n        // If the end point is a reflection (not the source), calculate reflection details\n        const endPolygonId = path[i + 1].polygonId;\n        if (endPolygonId !== null) {\n            const polygon = polygons[endPolygonId];\n            const hitPoint = path[i + 1].position;\n            // Incoming direction (normalized)\n            const incomingDirection = Vector3.normalize(Vector3.subtract(hitPoint, startPoint));\n            // Get the next point to calculate outgoing direction\n            const nextPoint = path[i + 2]?.position;\n            let outgoingDirection;\n            if (nextPoint) {\n                outgoingDirection = Vector3.normalize(Vector3.subtract(nextPoint, hitPoint));\n            }\n            else {\n                // Shouldn't happen in valid paths, but handle gracefully\n                outgoingDirection = Vector3.reflect(incomingDirection, Plane3D.normal(polygon.plane));\n            }\n            // Surface normal oriented toward incoming ray\n            const surfaceNormal = getOrientedNormal3D(polygon, incomingDirection);\n            // Calculate angles\n            const incidenceAngle = calculateIncidenceAngle3D(incomingDirection, surfaceNormal);\n            const reflectionAngle = incidenceAngle; // Specular reflection\n            // Update cumulative distance (includes this segment)\n            cumulativeDistance += segmentLength;\n            // Check if grazing (angle close to 90°)\n            const isGrazing = Math.abs(incidenceAngle - Math.PI / 2) < GRAZING_THRESHOLD_3D;\n            reflections.push({\n                polygon,\n                polygonId: endPolygonId,\n                hitPoint: Vector3.clone(hitPoint),\n                incidenceAngle,\n                reflectionAngle,\n                incomingDirection,\n                outgoingDirection,\n                surfaceNormal,\n                reflectionOrder: reflections.length + 1,\n                cumulativeDistance,\n                incomingSegmentLength: segmentLength,\n                isGrazing\n            });\n        }\n        else {\n            // Final segment to source - just add to cumulative distance\n            cumulativeDistance += segmentLength;\n        }\n    }\n    return {\n        listenerPosition,\n        sourcePosition,\n        totalPathLength: cumulativeDistance,\n        reflectionCount: reflections.length,\n        reflections,\n        segments,\n        simplePath: path\n    };\n}\n//# sourceMappingURL=solver3d.js.map","/**\n * BeamTrace3D - 3D Beam Tracing for Acoustic Simulations\n *\n * Main entry point for the 3D beam tracing library.\n * Extends the 2D BeamTrace implementation to full 3D with:\n * - 3D polygonal room geometry\n * - BSP tree acceleration\n * - Fail plane caching\n * - Skip sphere bucketing\n *\n * Based on: Laine, S., Siltanen, S., Lokki, T., & Savioja, L. (2009).\n * \"Accelerated beam tracing algorithm.\" Applied Acoustics, 70(1), 172-181.\n *\n * @example\n * ```typescript\n * import { Polygon3D, Source3D, Listener3D, Solver3D, createShoeboxRoom } from './beamtrace3d';\n *\n * // Create a simple room\n * const room = createShoeboxRoom(10, 8, 3);\n *\n * // Create source and solver\n * const source = new Source3D([5, 4, 1.5]);\n * const solver = new Solver3D(room, source, { maxReflectionOrder: 4 });\n *\n * // Find paths to listener\n * const listener = new Listener3D([2, 2, 1.2]);\n * const paths = solver.getPaths(listener.position);\n * ```\n */\n// Core types\nexport { Vector3 } from './core/vector3';\nexport { Plane3D } from './core/plane3d';\n// Geometry\nexport { Polygon3D, createShoeboxRoom, createQuad } from './geometry/polygon3d';\nexport { splitPolygon, splitPolygons } from './geometry/polygon-split';\nexport { clipPolygonByPlane, clipPolygonByPlanes, clipPolygonByFrustum, quickRejectPolygon, polygonMayIntersectVolume, clipRayByPlanes } from './geometry/clipping3d';\n// Structures\nexport { buildBSP, rayTraceBSP, rayTraceBSPMultiIgnore, rayOccluded, rayTraceAll, countNodes, treeDepth, setBSPDebug } from './structures/bsp3d';\nexport { createBeam3D, constructBeamBoundaryPlanes, isPointInBeam, findBeamViolation, distanceToBeamBoundary, mirrorPointAcrossPolygon, polygonMayBeInBeam, isPolygonFacingSource, beamSolidAngle } from './structures/beam3d';\nexport { buildBeamTree3D, collectNodesAtOrder, getNodeOrder, getReflectionPath, countBeamNodes, getBeamTreeStats, clearFailPlanes, iterateNodes } from './structures/beamtree3d';\n// Optimization\nexport { detectFailPlane, propagateFailPlane, isListenerBehindFailPlane, distanceToFailPlane, minDistanceToFailPlanes, updateNodeFailPlane, clearNodeFailPlane, hasFailPlane } from './optimization/failplane3d';\nexport { createBuckets3D, isInsideSkipSphere, checkSkipSphere, createSkipSphere, invalidateSkipSphere, clearBucketFailPlanes, updateBucketSkipSphere, processBucketSkipSphere, getSkipSphereStats, DEFAULT_BUCKET_SIZE_3D } from './optimization/skipsphere3d';\n// Solver\nexport { OptimizedSolver3D, computePathLength, computeArrivalTime, getPathReflectionOrder, convertToDetailedPath3D } from './solver/solver3d';\n// Convenience aliases\nimport { Vector3 } from './core/vector3';\nimport { createShoeboxRoom } from './geometry/polygon3d';\nimport { OptimizedSolver3D } from './solver/solver3d';\n/**\n * 3D Sound source\n */\nexport class Source3D {\n    constructor(position) {\n        this.position = Vector3.clone(position);\n    }\n}\n/**\n * 3D Listener\n */\nexport class Listener3D {\n    constructor(position) {\n        this.position = Vector3.clone(position);\n    }\n    /**\n     * Update listener position\n     */\n    moveTo(position) {\n        this.position = Vector3.clone(position);\n    }\n}\n/**\n * Main 3D Solver class (alias for OptimizedSolver3D with simpler interface)\n */\nexport class Solver3D {\n    constructor(polygons, source, config) {\n        this.source = source;\n        this.solver = new OptimizedSolver3D(polygons, source.position, config);\n    }\n    /**\n     * Get all valid reflection paths to a listener\n     */\n    getPaths(listener) {\n        const pos = Array.isArray(listener) ? listener : listener.position;\n        return this.solver.getPaths(pos);\n    }\n    /**\n     * Get all valid reflection paths with detailed information about each reflection.\n     *\n     * This method returns the same paths as getPaths() but with additional details:\n     * - Angle of incidence and reflection at each surface\n     * - Surface normal vectors\n     * - Segment lengths and cumulative distances\n     * - Grazing incidence detection\n     *\n     * @param listener - Listener position or Listener3D object\n     * @returns Array of detailed reflection paths\n     */\n    getDetailedPaths(listener) {\n        const pos = Array.isArray(listener) ? listener : listener.position;\n        return this.solver.getDetailedPaths(pos);\n    }\n    /**\n     * Get performance metrics from last getPaths() call\n     */\n    getMetrics() {\n        return this.solver.getMetrics();\n    }\n    /**\n     * Clear optimization caches\n     */\n    clearCache() {\n        this.solver.clearCache();\n    }\n    /**\n     * Get number of leaf nodes in beam tree\n     */\n    getLeafNodeCount() {\n        return this.solver.getLeafNodeCount();\n    }\n    /**\n     * Get maximum reflection order\n     */\n    getMaxReflectionOrder() {\n        return this.solver.getMaxReflectionOrder();\n    }\n    /**\n     * Get beam data for visualization\n     */\n    getBeamsForVisualization(maxOrder) {\n        return this.solver.getBeamsForVisualization(maxOrder);\n    }\n    /**\n     * Debug a specific beam path by polygon IDs\n     * Logs detailed information about the path validation process\n     */\n    debugBeamPath(listener, polygonPath) {\n        const pos = Array.isArray(listener) ? listener : listener.position;\n        this.solver.debugBeamPath(pos, polygonPath);\n    }\n}\n/**\n * Create a simple shoebox room for testing\n */\nexport function createRoom(width, depth, height) {\n    return createShoeboxRoom(width, depth, height);\n}\n//# sourceMappingURL=beamtrace3d.js.map","import Solver from \"../solver\";\nimport * as THREE from \"three\";\nimport { MeshLine, MeshLineMaterial } from 'three.meshline';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  Polygon3D,\n  Source3D,\n  Solver3D,\n  computePathLength,\n  computeArrivalTime,\n  getPathReflectionOrder,\n} from 'beam-trace';\nimport type {\n  ReflectionPath3D,\n  DetailedReflectionPath3D,\n  BeamVisualizationData,\n  Vector3 as BT_Vector3\n} from 'beam-trace';\n\nimport Room, { getRooms } from \"../../objects/room\";\nimport Source from \"../../objects/source\";\nimport Receiver from \"../../objects/receiver\";\nimport Surface from \"../../objects/surface\";\nimport { emit, on } from \"../../messenger\";\nimport { renderer } from \"../../render/renderer\";\nimport { addSolver, removeSolver, setSolverProperty, useSolver, useContainer, useResult, ResultKind, Result } from \"../../store\";\nimport { pickProps } from \"../../common/helpers\";\nimport * as ac from \"../acoustics\";\nimport { normalize } from \"../acoustics\";\nimport { audioEngine } from \"../../audio-engine/audio-engine\";\nimport {\n  playImpulseResponse as sharedPlayIR,\n  downloadImpulseResponse as sharedDownloadIR,\n  downloadAmbisonicImpulseResponse as sharedDownloadAmbisonicIR,\n  playBinauralImpulseResponse as sharedPlayBinauralIR,\n  downloadBinauralImpulseResponse as sharedDownloadBinauralIR,\n} from \"../shared/export-playback\";\nimport { calculateBinauralFromAmbisonic } from \"../binaural/calculate-binaural\";\nimport chroma from 'chroma-js';\nimport { encodeBufferFromDirection, getAmbisonicChannelCount } from \"ambisonics\";\nimport { buildEdgeGraph, findDiffractionPaths } from \"../shared/diffraction\";\nimport type { EdgeGraph, DiffractionPath } from \"../shared/diffraction\";\nimport { HISTOGRAM_BIN_WIDTH, HISTOGRAM_NUM_BINS } from \"../shared/tail-synthesis-types\";\nimport { extractDecayParameters, synthesizeTail, assembleFinalIR } from \"../shared/tail-synthesis\";\nimport type { ResponseByIntensity, RayPathResult } from \"../shared/response-by-intensity-types\";\nimport { DEFAULT_INTENSITY_SAMPLE_RATE } from \"../shared/response-by-intensity-types\";\nimport { resampleResponseByIntensity } from \"../shared/response-by-intensity\";\nimport { quickEstimateStep as sharedQuickEstimateStep } from \"../shared/quick-estimate\";\nimport type { QuickEstimateStepResult } from \"../shared/quick-estimate-types\";\nimport { KVP } from \"../../common/key-value-pair\";\nimport FileSaver from \"file-saver\";\n\n// Helper to create a highlighted path line (same as ImageSourceSolver)\nfunction createHighlightLine(): THREE.Mesh {\n  const line = new MeshLine();\n  line.setPoints([]);\n  const material = new MeshLineMaterial({\n    lineWidth: 0.1,\n    color: 0xff0000,\n    sizeAttenuation: 1,\n  });\n  return new THREE.Mesh(line, material);\n}\n\n// Path visualization colors by reflection order\n// Uses the same color scale as LTPChart for consistency: orange (#ff8a0b) to navy (#000080)\nconst colorScale = chroma.scale(['#ff8a0b', '#000080']).mode('lch');\n\n// Get color for a given reflection order (0 = direct, 1 = 1st order, etc.)\n// maxOrder determines the number of colors in the scale\nfunction getOrderColor(order: number, maxOrder: number): number {\n  const numColors = maxOrder + 1;\n  const colors = colorScale.colors(numColors);\n  const colorIndex = Math.min(order, numColors - 1);\n  const color = chroma(colors[colorIndex]);\n  return parseInt(color.hex().slice(1), 16);\n}\n\nexport interface BeamTracePath {\n  points: THREE.Vector3[];\n  order: number;\n  length: number;\n  arrivalTime: number;\n  polygonIds: (number | null)[];\n  /** Direction from which the path arrives at the receiver (normalized) */\n  arrivalDirection: THREE.Vector3;\n  // Detailed reflection info (optional, populated when using getDetailedPaths)\n  reflections?: {\n    polygonId: number;\n    hitPoint: THREE.Vector3;\n    incidenceAngle: number;\n    surfaceNormal: THREE.Vector3;\n    isGrazing: boolean;\n  }[];\n  /** Pre-computed per-band energy for diffraction paths (bypasses specular reflection calc) */\n  bandEnergy?: number[];\n}\n\nexport type VisualizationMode = \"rays\" | \"beams\" | \"both\";\n\nexport interface BeamTraceSaveObject {\n  name: string;\n  kind: \"beam-trace\";\n  uuid: string;\n  autoCalculate: boolean;\n  roomID: string;\n  sourceIDs: string[];\n  receiverIDs: string[];\n  maxReflectionOrder: number;\n  visualizationMode: VisualizationMode;\n  showAllBeams: boolean;\n  visibleOrders: number[];\n  frequencies: number[];\n  levelTimeProgression: string;\n  impulseResponseResult: string;\n  hrtfSubjectId?: string;\n  headYaw?: number;\n  headPitch?: number;\n  headRoll?: number;\n  edgeDiffractionEnabled?: boolean;\n  lateReverbTailEnabled?: boolean;\n  tailCrossfadeTime?: number;\n  tailCrossfadeDuration?: number;\n}\n\nexport interface BeamTraceSolverParams {\n  name?: string;\n  uuid?: string;\n  roomID?: string;\n  sourceIDs?: string[];\n  receiverIDs?: string[];\n  maxReflectionOrder?: number;\n  visualizationMode?: VisualizationMode;\n  showAllBeams?: boolean;\n  visibleOrders?: number[];\n  frequencies?: number[];\n  levelTimeProgression?: string;\n  impulseResponseResult?: string;\n  hrtfSubjectId?: string;\n  headYaw?: number;\n  headPitch?: number;\n  headRoll?: number;\n  edgeDiffractionEnabled?: boolean;\n  lateReverbTailEnabled?: boolean;\n  tailCrossfadeTime?: number;\n  tailCrossfadeDuration?: number;\n}\n\nconst defaults: Required<BeamTraceSolverParams> = {\n  name: \"Beam Tracer\",\n  uuid: \"\",\n  roomID: \"\",\n  sourceIDs: [],\n  receiverIDs: [],\n  maxReflectionOrder: 3,\n  visualizationMode: \"rays\",\n  showAllBeams: false,\n  visibleOrders: [0, 1, 2, 3],\n  frequencies: [125, 250, 500, 1000, 2000, 4000, 8000],\n  levelTimeProgression: \"\",\n  impulseResponseResult: \"\",\n  hrtfSubjectId: \"D1\",\n  headYaw: 0,\n  headPitch: 0,\n  headRoll: 0,\n  edgeDiffractionEnabled: false,\n  lateReverbTailEnabled: false,\n  tailCrossfadeTime: 0,\n  tailCrossfadeDuration: 0.05,\n};\n\nexport class BeamTraceSolver extends Solver {\n  roomID: string;\n  sourceIDs: string[];\n  receiverIDs: string[];\n  maxReflectionOrder: number;\n  frequencies: number[];\n  levelTimeProgression: string;\n  impulseResponseResult: string;\n\n  private _visualizationMode: VisualizationMode;\n  private _showAllBeams: boolean;\n  private _visibleOrders: number[];\n  private _plotFrequency: number;\n  private _plotOrders: number[];\n\n  // Internal beam-trace solver instance\n  private btSolver: Solver3D | null = null;\n  private polygons: Polygon3D[] = [];\n  private surfaceToPolygonIndex: Map<string, number[]> = new Map();\n  private polygonToSurface: Map<number, Surface> = new Map();\n\n  // Edge diffraction\n  edgeDiffractionEnabled: boolean;\n  private _edgeGraph: EdgeGraph | null = null;\n  private _raycaster: THREE.Raycaster = new THREE.Raycaster();\n\n  // Late reverberation tail\n  lateReverbTailEnabled: boolean;\n  tailCrossfadeTime: number;\n  tailCrossfadeDuration: number;\n  private _energyHistogram: Float32Array[] | null = null;\n\n  // Binaural\n  hrtfSubjectId: string;\n  headYaw: number;\n  headPitch: number;\n  headRoll: number;\n  binauralImpulseResponse?: AudioBuffer;\n  binauralPlaying: boolean = false;\n\n  // Results\n  validPaths: BeamTracePath[] = [];\n  impulseResponse!: AudioBuffer;\n  impulseResponsePlaying: boolean = false;\n\n  // Response by intensity (per-frequency decay analysis)\n  responseByIntensity: KVP<KVP<ResponseByIntensity>> | undefined;\n\n  // Quick estimate\n  quickEstimateResults: QuickEstimateStepResult[] = [];\n  estimatedT30: number[] | null = null;\n  private _quickEstimateInterval: number | null = null;\n\n  // Metrics\n  lastMetrics: {\n    validPathCount: number;\n    raycastCount: number;\n    failPlaneCacheHits: number;\n    bucketsSkipped: number;\n    bufferUsage?: {\n      linesUsed: number;\n      linesCapacity: number;\n      linesPercent: number;\n      pointsUsed: number;\n      pointsCapacity: number;\n      pointsPercent: number;\n      overflowWarning: boolean;\n    };\n  } | null = null;\n\n  // Group for virtual source meshes (replaces Points for reliable raycasting)\n  private virtualSourcesGroup: THREE.Group;\n  // Map from virtual source mesh to beam data for click detection\n  private virtualSourceMap: Map<THREE.Mesh, BeamVisualizationData & { polygonPath: number[] }> = new Map();\n  // Currently selected virtual source mesh\n  private selectedVirtualSource: THREE.Mesh | null = null;\n\n  // Click handler cleanup\n  private clickHandler: ((event: MouseEvent) => void) | null = null;\n  private hoverHandler: ((event: MouseEvent) => void) | null = null;\n\n  // Selected path highlight (for LTP chart click interaction)\n  private selectedPath: THREE.Mesh;\n  private selectedBeamsGroup: THREE.Group;\n\n  // Incremental update tracking: skip full beam tree rebuild when only the listener moved\n  private _lastSourcePos: THREE.Vector3 | null = null;\n  private _lastRoomID: string = \"\";\n  private _lastMaxOrder: number = -1;\n\n  constructor(params: BeamTraceSolverParams = {}) {\n    super(params);\n    const p = { ...defaults, ...params };\n\n    this.kind = \"beam-trace\";\n    this.uuid = p.uuid || uuidv4();\n    this.name = p.name;\n    this.roomID = p.roomID;\n    this.sourceIDs = p.sourceIDs;\n    this.receiverIDs = p.receiverIDs;\n    this.maxReflectionOrder = p.maxReflectionOrder;\n    this.frequencies = p.frequencies;\n    this.hrtfSubjectId = p.hrtfSubjectId;\n    this.headYaw = p.headYaw;\n    this.headPitch = p.headPitch;\n    this.headRoll = p.headRoll;\n    this.edgeDiffractionEnabled = p.edgeDiffractionEnabled;\n    this.lateReverbTailEnabled = p.lateReverbTailEnabled;\n    this.tailCrossfadeTime = p.tailCrossfadeTime;\n    this.tailCrossfadeDuration = p.tailCrossfadeDuration;\n    this._visualizationMode = p.visualizationMode;\n    this._showAllBeams = p.showAllBeams;\n    this._visibleOrders = p.visibleOrders.length > 0 ? p.visibleOrders : Array.from({ length: p.maxReflectionOrder + 1 }, (_, i) => i);\n    this._plotFrequency = 1000;\n    this._plotOrders = Array.from({ length: p.maxReflectionOrder + 1 }, (_, i) => i); // [0, 1, 2, ... maxReflectionOrder]\n    this.levelTimeProgression = p.levelTimeProgression || uuidv4();\n    this.impulseResponseResult = p.impulseResponseResult || uuidv4();\n\n    // Auto-find room if not specified\n    if (!this.roomID) {\n      const rooms = getRooms();\n      if (rooms.length > 0) {\n        this.roomID = rooms[0].uuid;\n      }\n    }\n\n    // Create LTP result for this solver\n    emit(\"ADD_RESULT\", {\n      kind: ResultKind.LevelTimeProgression,\n      data: [],\n      info: {\n        initialSPL: [100],\n        frequency: [this._plotFrequency],\n        maxOrder: this.maxReflectionOrder,\n      },\n      name: `LTP - ${this.name}`,\n      uuid: this.levelTimeProgression,\n      from: this.uuid\n    } as Result<ResultKind.LevelTimeProgression>);\n\n    // Create IR result for this solver\n    emit(\"ADD_RESULT\", {\n      kind: ResultKind.ImpulseResponse,\n      data: [],\n      info: {\n        sampleRate: 44100,\n        sourceName: \"\",\n        receiverName: \"\",\n        sourceId: this.sourceIDs[0] || \"\",\n        receiverId: this.receiverIDs[0] || \"\"\n      },\n      name: `IR - ${this.name}`,\n      uuid: this.impulseResponseResult,\n      from: this.uuid\n    } as Result<ResultKind.ImpulseResponse>);\n\n    // Create selected path highlight line\n    this.selectedPath = createHighlightLine();\n    renderer.markup.add(this.selectedPath);\n\n    // Create group for highlighted beam lines\n    this.selectedBeamsGroup = new THREE.Group();\n    this.selectedBeamsGroup.name = \"selected-beams-highlight\";\n    renderer.markup.add(this.selectedBeamsGroup);\n\n    // Create group for virtual source spheres\n    this.virtualSourcesGroup = new THREE.Group();\n    this.virtualSourcesGroup.name = \"virtual-sources\";\n    renderer.markup.add(this.virtualSourcesGroup);\n  }\n\n  get temperature(): number {\n    return this.room?.temperature ?? 20;\n  }\n\n  get c(): number {\n    return ac.soundSpeed(this.temperature);\n  }\n\n  save(): BeamTraceSaveObject {\n    return {\n      ...pickProps([\n        \"name\",\n        \"kind\",\n        \"uuid\",\n        \"autoCalculate\",\n        \"roomID\",\n        \"sourceIDs\",\n        \"receiverIDs\",\n        \"maxReflectionOrder\",\n        \"frequencies\",\n        \"levelTimeProgression\",\n        \"impulseResponseResult\",\n        \"hrtfSubjectId\",\n        \"headYaw\",\n        \"headPitch\",\n        \"headRoll\",\n        \"edgeDiffractionEnabled\",\n        \"lateReverbTailEnabled\",\n        \"tailCrossfadeTime\",\n        \"tailCrossfadeDuration\",\n      ], this),\n      visualizationMode: this._visualizationMode,\n      showAllBeams: this._showAllBeams,\n      visibleOrders: this._visibleOrders,\n    } as BeamTraceSaveObject;\n  }\n\n  restore(state: BeamTraceSaveObject): this {\n    this.name = state.name;\n    this.uuid = state.uuid;\n    this.autoCalculate = state.autoCalculate ?? false;\n    this.roomID = state.roomID;\n    this.sourceIDs = state.sourceIDs;\n    this.receiverIDs = state.receiverIDs;\n    this.maxReflectionOrder = state.maxReflectionOrder;\n    this._visualizationMode = state.visualizationMode || \"rays\";\n    this._showAllBeams = state.showAllBeams ?? false;\n    this._visibleOrders = state.visibleOrders ?? Array.from({ length: this.maxReflectionOrder + 1 }, (_, i) => i);\n    this.frequencies = state.frequencies;\n    this.levelTimeProgression = state.levelTimeProgression || uuidv4();\n    this.impulseResponseResult = state.impulseResponseResult || uuidv4();\n    this.hrtfSubjectId = state.hrtfSubjectId ?? \"D1\";\n    this.headYaw = state.headYaw ?? 0;\n    this.headPitch = state.headPitch ?? 0;\n    this.headRoll = state.headRoll ?? 0;\n    this.edgeDiffractionEnabled = state.edgeDiffractionEnabled ?? false;\n    this.lateReverbTailEnabled = state.lateReverbTailEnabled ?? false;\n    this.tailCrossfadeTime = state.tailCrossfadeTime ?? 0;\n    this.tailCrossfadeDuration = state.tailCrossfadeDuration ?? 0.05;\n    return this;\n  }\n\n  dispose() {\n    this.clearVisualization();\n    this.removeClickHandler();\n    renderer.markup.remove(this.selectedPath);\n    renderer.markup.remove(this.selectedBeamsGroup);\n    renderer.markup.remove(this.virtualSourcesGroup);\n    emit(\"REMOVE_RESULT\", this.levelTimeProgression);\n    emit(\"REMOVE_RESULT\", this.impulseResponseResult);\n  }\n\n  private setupClickHandler() {\n    // Remove existing handlers if any\n    this.removeClickHandler();\n\n    const canvas = renderer.renderer.domElement;\n\n    // Helper to get mouse position in normalized device coordinates\n    const getMouseNDC = (event: MouseEvent): THREE.Vector2 => {\n      const rect = canvas.getBoundingClientRect();\n      return new THREE.Vector2(\n        ((event.clientX - rect.left) / rect.width) * 2 - 1,\n        -((event.clientY - rect.top) / rect.height) * 2 + 1\n      );\n    };\n\n    // Hover handler - change cursor when over a clickable virtual source\n    this.hoverHandler = (event: MouseEvent) => {\n      if (this.virtualSourceMap.size === 0) {\n        canvas.style.cursor = 'default';\n        return;\n      }\n\n      const mouse = getMouseNDC(event);\n      const raycaster = new THREE.Raycaster();\n      raycaster.setFromCamera(mouse, renderer.camera);\n\n      const virtualSourceMeshes = Array.from(this.virtualSourceMap.keys());\n      const intersects = raycaster.intersectObjects(virtualSourceMeshes);\n\n      if (intersects.length > 0) {\n        canvas.style.cursor = 'pointer';\n      } else {\n        canvas.style.cursor = 'default';\n      }\n    };\n\n    // Click handler\n    this.clickHandler = (event: MouseEvent) => {\n      // Only handle left clicks\n      if (event.button !== 0) return;\n      if (this.virtualSourceMap.size === 0) return;\n\n      const mouse = getMouseNDC(event);\n      const raycaster = new THREE.Raycaster();\n      raycaster.setFromCamera(mouse, renderer.camera);\n\n      const virtualSourceMeshes = Array.from(this.virtualSourceMap.keys());\n      const intersects = raycaster.intersectObjects(virtualSourceMeshes);\n\n      if (intersects.length > 0) {\n        const clickedMesh = intersects[0].object as THREE.Mesh;\n        const beam = this.virtualSourceMap.get(clickedMesh);\n\n        if (beam) {\n          // Toggle selection - if already selected, deselect\n          if (this.selectedVirtualSource === clickedMesh) {\n            this.selectedVirtualSource = null;\n            this.clearSelectedBeams();\n          } else {\n            this.selectedVirtualSource = clickedMesh;\n            this.highlightVirtualSourcePath(beam);\n          }\n        }\n      }\n    };\n\n    canvas.addEventListener('click', this.clickHandler);\n    canvas.addEventListener('mousemove', this.hoverHandler);\n  }\n\n  // Highlight the ray path from a clicked virtual source to the receiver\n  // beam contains polygonPath which is the sequence of polygon IDs for reflections\n  private highlightVirtualSourcePath(beam: BeamVisualizationData & { polygonPath: number[] }) {\n    // Clear previous selections\n    (this.selectedPath.geometry as MeshLine).setPoints([]);\n    this.clearSelectedBeams();\n\n    const colorHex = getOrderColor(beam.reflectionOrder, this.maxReflectionOrder);\n    const vs = new THREE.Vector3(beam.virtualSource[0], beam.virtualSource[1], beam.virtualSource[2]);\n\n    // Get receiver position\n    if (this.receiverIDs.length === 0) return;\n    const receiver = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\n    if (!receiver) return;\n    const receiverPos = receiver.position.clone();\n\n    // Draw dashed line from virtual source to receiver (the \"unfolded\" path)\n    const dashedMaterial = new THREE.LineDashedMaterial({\n      color: colorHex,\n      transparent: true,\n      opacity: 0.4,\n      dashSize: 0.3,\n      gapSize: 0.15\n    });\n    const unfoldedLineGeom = new THREE.BufferGeometry().setFromPoints([vs, receiverPos]);\n    const unfoldedLine = new THREE.Line(unfoldedLineGeom, dashedMaterial);\n    unfoldedLine.computeLineDistances();\n    this.selectedBeamsGroup.add(unfoldedLine);\n\n    // Add a larger highlight sphere on the virtual source\n    const highlightGeom = new THREE.SphereGeometry(0.18, 16, 16);\n    const highlightMat = new THREE.MeshBasicMaterial({\n      color: colorHex,\n      transparent: true,\n      opacity: 0.4\n    });\n    const highlightMesh = new THREE.Mesh(highlightGeom, highlightMat);\n    highlightMesh.position.copy(vs);\n    this.selectedBeamsGroup.add(highlightMesh);\n\n    // Find the matching path inside the room by comparing polygon sequence\n    const polygonPath = beam.polygonPath;\n    if (!polygonPath || polygonPath.length === 0) return;\n\n    const targetOrder = beam.reflectionOrder;\n\n    for (const path of this.validPaths) {\n      // Path structure: path.polygonIds = [null (listener), polyN, poly_{N-1}, ..., poly_1, null (source)]\n      // A path with N reflections has length N+2 (including source and listener points)\n      const pathOrder = path.order;\n\n      if (pathOrder !== targetOrder) continue;\n\n      // Check if the polygon sequence matches\n      // polygonPath is [poly0, poly1, ..., polyN] (first to last reflection, root to leaf in beam tree)\n      // path.polygonIds is [null, polyN, poly_{N-1}, ..., poly_1, null] (leaf to root order)\n      // So we need to compare in reverse: polygonPath[i] should match path.polygonIds[pathOrder - i]\n      let matches = true;\n      for (let i = 0; i < polygonPath.length; i++) {\n        const pathIndex = pathOrder - i; // Index of reflection point in path (1-based from listener)\n        const pathPolygonId = path.polygonIds[pathIndex];\n        if (pathPolygonId !== polygonPath[i]) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (matches) {\n        // Draw the actual ray path inside the room as thick cylinders\n        const points = path.points;\n        const numReflections = path.order;\n\n        for (let i = 0; i < points.length - 1; i++) {\n          const start = points[i];\n          const end = points[i + 1];\n          const segLen = start.distanceTo(end);\n          const midPoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);\n\n          // Color based on segment order\n          const segmentOrder = numReflections - i;\n          const segColor = (segmentOrder === 0) ? 0xffffff : getOrderColor(segmentOrder, this.maxReflectionOrder);\n\n          const cylGeom = new THREE.CylinderGeometry(0.025, 0.025, segLen, 8);\n          const cylMat = new THREE.MeshBasicMaterial({ color: segColor });\n          const cyl = new THREE.Mesh(cylGeom, cylMat);\n\n          cyl.position.copy(midPoint);\n          const direction = new THREE.Vector3().subVectors(end, start).normalize();\n          const quaternion = new THREE.Quaternion();\n          quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);\n          cyl.setRotationFromQuaternion(quaternion);\n\n          this.selectedBeamsGroup.add(cyl);\n        }\n\n        // Add spheres at reflection points\n        for (let i = 1; i < path.points.length - 1; i++) {\n          const pointOrder = numReflections - i + 1;\n          const pointColor = getOrderColor(pointOrder, this.maxReflectionOrder);\n\n          const pointGeom = new THREE.SphereGeometry(0.08, 12, 12);\n          const pointMat = new THREE.MeshBasicMaterial({ color: pointColor });\n          const pointMesh = new THREE.Mesh(pointGeom, pointMat);\n          pointMesh.position.copy(path.points[i]);\n          this.selectedBeamsGroup.add(pointMesh);\n        }\n\n        renderer.needsToRender = true;\n        return;\n      }\n    }\n\n    renderer.needsToRender = true;\n  }\n\n  private removeClickHandler() {\n    const canvas = renderer.renderer.domElement;\n    if (this.clickHandler) {\n      canvas.removeEventListener('click', this.clickHandler);\n      this.clickHandler = null;\n    }\n    if (this.hoverHandler) {\n      canvas.removeEventListener('mousemove', this.hoverHandler);\n      this.hoverHandler = null;\n      canvas.style.cursor = 'default';\n    }\n  }\n\n  // Convert room surfaces to beam-trace Polygon3D format\n  private extractPolygons(): Polygon3D[] {\n    const room = this.room;\n    if (!room) return [];\n\n    const polygons: Polygon3D[] = [];\n    this.surfaceToPolygonIndex.clear();\n    this.polygonToSurface.clear();\n\n    room.allSurfaces.forEach((surface: Surface) => {\n      const surfacePolygons = this.surfaceToPolygons(surface);\n      const startIndex = polygons.length;\n\n      surfacePolygons.forEach((poly, i) => {\n        this.polygonToSurface.set(startIndex + i, surface);\n        polygons.push(poly);\n      });\n\n      this.surfaceToPolygonIndex.set(\n        surface.uuid,\n        surfacePolygons.map((_, i) => startIndex + i)\n      );\n    });\n\n    return polygons;\n  }\n\n  // Convert a Surface to Polygon3D objects\n  private surfaceToPolygons(surface: Surface): Polygon3D[] {\n    const polygons: Polygon3D[] = [];\n    const geometry = surface.geometry;\n    const posAttr = geometry.getAttribute('position');\n\n    if (!posAttr) return polygons;\n\n    // Get world matrix for the surface\n    surface.updateMatrixWorld(true);\n    const worldMatrix = surface.matrixWorld;\n\n    // Process triangles\n    const indices = geometry.getIndex();\n    const positions = posAttr.array;\n\n    const processTriangle = (i0: number, i1: number, i2: number) => {\n      const v0 = new THREE.Vector3(\n        positions[i0 * 3],\n        positions[i0 * 3 + 1],\n        positions[i0 * 3 + 2]\n      ).applyMatrix4(worldMatrix);\n\n      const v1 = new THREE.Vector3(\n        positions[i1 * 3],\n        positions[i1 * 3 + 1],\n        positions[i1 * 3 + 2]\n      ).applyMatrix4(worldMatrix);\n\n      const v2 = new THREE.Vector3(\n        positions[i2 * 3],\n        positions[i2 * 3 + 1],\n        positions[i2 * 3 + 2]\n      ).applyMatrix4(worldMatrix);\n\n      const vertices: BT_Vector3[] = [\n        [v0.x, v0.y, v0.z],\n        [v1.x, v1.y, v1.z],\n        [v2.x, v2.y, v2.z]\n      ];\n\n      const polygon = Polygon3D.create(vertices);\n      polygons.push(polygon);\n    };\n\n    if (indices) {\n      const indexArray = indices.array;\n      for (let i = 0; i < indexArray.length; i += 3) {\n        processTriangle(indexArray[i], indexArray[i + 1], indexArray[i + 2]);\n      }\n    } else {\n      // Non-indexed geometry\n      const numVertices = posAttr.count;\n      for (let i = 0; i < numVertices; i += 3) {\n        processTriangle(i, i + 1, i + 2);\n      }\n    }\n\n    return polygons;\n  }\n\n  // Check if the beam tree needs to be rebuilt (source moved, room changed, or order changed)\n  private needsBeamTreeRebuild(): boolean {\n    if (!this.btSolver) return true;\n    if (this._lastRoomID !== this.roomID) return true;\n    if (this._lastMaxOrder !== this.maxReflectionOrder) return true;\n    if (this.sourceIDs.length === 0) return true;\n\n    const source = useContainer.getState().containers[this.sourceIDs[0]] as Source;\n    if (!source) return true;\n    if (!this._lastSourcePos || !this._lastSourcePos.equals(source.position)) return true;\n\n    return false;\n  }\n\n  // Build/rebuild the beam-trace solver\n  buildSolver() {\n    if (this.sourceIDs.length === 0) {\n      console.warn(\"BeamTraceSolver: No source selected\");\n      return;\n    }\n\n    const source = useContainer.getState().containers[this.sourceIDs[0]] as Source;\n    if (!source) {\n      console.warn(\"BeamTraceSolver: Source not found\");\n      return;\n    }\n\n    // Extract room geometry\n    this.polygons = this.extractPolygons();\n    if (this.polygons.length === 0) {\n      console.warn(\"BeamTraceSolver: No polygons extracted from room\");\n      return;\n    }\n\n    // Create beam-trace source\n    const sourcePos: BT_Vector3 = [\n      source.position.x,\n      source.position.y,\n      source.position.z\n    ];\n    const btSource = new Source3D(sourcePos);\n\n    // Create solver\n    this.btSolver = new Solver3D(this.polygons, btSource, {\n      maxReflectionOrder: this.maxReflectionOrder\n    });\n\n    // Record the state used for this build (for incremental update detection)\n    this._lastSourcePos = source.position.clone();\n    this._lastRoomID = this.roomID;\n    this._lastMaxOrder = this.maxReflectionOrder;\n\n    console.log(`BeamTraceSolver: Built with ${this.polygons.length} polygons, max order ${this.maxReflectionOrder}`);\n  }\n\n  // Calculate paths to all receivers\n  calculate() {\n    if (this.sourceIDs.length === 0 || this.receiverIDs.length === 0) {\n      console.warn(\"BeamTraceSolver: Need at least one source and one receiver\");\n      return;\n    }\n\n    // Only rebuild beam tree if source, room, or reflection order changed.\n    // If only the listener moved, reuse the existing beam tree (much faster).\n    const needsRebuild = this.needsBeamTreeRebuild();\n    if (needsRebuild) {\n      this.buildSolver();\n    } else if (this.btSolver) {\n      // Clear fail-plane cache so stale listener-position caches don't skip valid paths\n      this.btSolver.clearCache();\n      console.log(\"BeamTraceSolver: Reusing beam tree (listener-only change)\");\n    }\n\n    if (!this.btSolver) {\n      console.warn(\"BeamTraceSolver: Solver not built\");\n      return;\n    }\n\n    this.validPaths = [];\n    this.clearVisualization();\n\n    // Process each receiver\n    this.receiverIDs.forEach(receiverID => {\n      const receiver = useContainer.getState().containers[receiverID] as Receiver;\n      if (!receiver) return;\n\n      const listenerPos: BT_Vector3 = [\n        receiver.position.x,\n        receiver.position.y,\n        receiver.position.z\n      ];\n      // Get paths and detailed paths from beam-trace solver\n      const paths = this.btSolver!.getPaths(listenerPos);\n      this.lastMetrics = this.btSolver!.getMetrics();\n      const detailedPaths = this.btSolver!.getDetailedPaths(listenerPos);\n\n      // Convert to our format, using detailed paths for pre-computed angles\n      paths.forEach((path, i) => {\n        const detailed = i < detailedPaths.length ? detailedPaths[i] : undefined;\n        const btPath = this.convertPath(path, detailed);\n        this.validPaths.push(btPath);\n      });\n    });\n\n    // Compute diffraction paths if enabled\n    if (this.edgeDiffractionEnabled && this.room) {\n      this._computeDiffractionPaths();\n    }\n\n    // Sort by arrival time (including diffraction paths)\n    this.validPaths.sort((a, b) => a.arrivalTime - b.arrivalTime);\n\n    // Build energy histogram for tail synthesis\n    if (this.lateReverbTailEnabled && this.validPaths.length > 0) {\n      this._buildEnergyHistogram();\n    }\n\n    // Update visualization based on current mode\n    switch (this._visualizationMode) {\n      case \"rays\":\n        this.drawPaths();\n        break;\n      case \"beams\":\n        this.drawBeams();\n        break;\n      case \"both\":\n        this.drawPaths();\n        this.drawBeams();\n        break;\n    }\n\n    // Calculate LTP result\n    this.calculateLTP();\n\n    // Calculate per-frequency intensity response with T30 estimates\n    this.calculateResponseByIntensity();\n\n    console.log(`BeamTraceSolver: Found ${this.validPaths.length} valid paths`);\n    if (this.lastMetrics) {\n      console.log(`  Raycasts: ${this.lastMetrics.raycastCount}`);\n      console.log(`  Cache hits: ${this.lastMetrics.failPlaneCacheHits}`);\n      console.log(`  Buckets skipped: ${this.lastMetrics.bucketsSkipped}`);\n    }\n\n    renderer.needsToRender = true;\n  }\n\n  // Convert beam-trace path to our format\n  private convertPath(path: ReflectionPath3D, detailed?: DetailedReflectionPath3D): BeamTracePath {\n    const points = path.map(p => new THREE.Vector3(p.position[0], p.position[1], p.position[2]));\n    const length = computePathLength(path);\n    const arrivalTime = computeArrivalTime(path, this.c);\n    const order = getPathReflectionOrder(path);\n    const polygonIds = path.map(p => p.polygonId);\n\n    // Compute arrival direction (direction from second-to-last point to receiver)\n    // points[0] is the receiver, points[1] is the last reflection point (or source for direct)\n    let arrivalDirection: THREE.Vector3;\n    if (points.length >= 2) {\n      arrivalDirection = new THREE.Vector3()\n        .subVectors(points[0], points[1])\n        .normalize()\n        .negate(); // Negate to get direction ray arrives FROM\n    } else {\n      // Fallback for edge case\n      arrivalDirection = new THREE.Vector3(0, 0, 1);\n    }\n\n    // Populate detailed reflection info from library if available\n    const reflections = detailed?.reflections.map(r => ({\n      polygonId: r.polygonId,\n      hitPoint: new THREE.Vector3(r.hitPoint[0], r.hitPoint[1], r.hitPoint[2]),\n      incidenceAngle: r.incidenceAngle,\n      surfaceNormal: new THREE.Vector3(r.surfaceNormal[0], r.surfaceNormal[1], r.surfaceNormal[2]),\n      isGrazing: r.isGrazing,\n    }));\n\n    return { points, order, length, arrivalTime, polygonIds, arrivalDirection, reflections };\n  }\n\n  // Calculate Level Time Progression result\n  calculateLTP() {\n    if (this.validPaths.length === 0) return;\n\n    // Sort paths by arrival time\n    const sortedPaths = [...this.validPaths].sort((a, b) => a.arrivalTime - b.arrivalTime);\n\n    // Get the current LTP result and update it\n    const levelTimeProgression = { ...useResult.getState().results[this.levelTimeProgression] as Result<ResultKind.LevelTimeProgression> };\n    levelTimeProgression.data = [];\n    levelTimeProgression.info = {\n      ...levelTimeProgression.info,\n      maxOrder: this.maxReflectionOrder,\n      frequency: [this._plotFrequency]\n    };\n\n    // Calculate arrival pressure for each path (with receiver directivity)\n    const recForLTP = this.receiverIDs.length > 0\n      ? useContainer.getState().containers[this.receiverIDs[0]] as Receiver\n      : null;\n\n    for (let i = 0; i < sortedPaths.length; i++) {\n      const path = sortedPaths[i];\n      const dir = path.arrivalDirection;\n      const recGain = recForLTP ? recForLTP.getGain([dir.x, dir.y, dir.z]) : 1.0;\n      const pressure = this.calculateArrivalPressure(levelTimeProgression.info.initialSPL, path, recGain);\n      const pressureLp = ac.P2Lp(pressure) as number[];\n\n      levelTimeProgression.data.push({\n        time: path.arrivalTime,\n        pressure: pressureLp,\n        arrival: i + 1,\n        order: path.order,\n        uuid: `${this.uuid}-path-${i}`\n      });\n    }\n\n    emit(\"UPDATE_RESULT\", { uuid: this.levelTimeProgression, result: levelTimeProgression });\n  }\n\n  // Clear LTP data\n  clearLevelTimeProgressionData() {\n    const levelTimeProgression = { ...useResult.getState().results[this.levelTimeProgression] };\n    levelTimeProgression.data = [];\n    emit(\"UPDATE_RESULT\", { uuid: this.levelTimeProgression, result: levelTimeProgression });\n  }\n\n  // Setter for plot frequency (recalculates LTP when changed)\n  set plotFrequency(f: number) {\n    this._plotFrequency = f;\n    this.calculateLTP();\n  }\n\n  get plotFrequency(): number {\n    return this._plotFrequency;\n  }\n\n  // Plot orders for LTP chart filtering (mirrors ImageSourceSolver API)\n  get plotOrders(): number[] {\n    return this._plotOrders;\n  }\n\n  set plotOrders(orders: number[]) {\n    this._plotOrders = orders;\n    // No need to redraw visualization - beam trace doesn't filter by plotOrders\n    // This is only used by the LTP chart\n  }\n\n  // Toggle ray path highlight when clicking on LTP chart bar\n  // uuid format is `${this.uuid}-path-${index}` from calculateLTP\n  toggleRayPathHighlight(pathUuid: string) {\n    // Extract path index from uuid (format: `{solverUuid}-path-{index}`)\n    const match = pathUuid.match(/-path-(\\d+)$/);\n    if (!match) {\n      console.warn('BeamTraceSolver: Invalid path UUID format:', pathUuid);\n      return;\n    }\n\n    const pathIndex = parseInt(match[1], 10);\n    this.highlightPathByIndex(pathIndex);\n  }\n\n  // Visualization methods\n  private clearVisualization() {\n    // Clear lines and points using renderer.markup (same as ImageSourceSolver)\n    renderer.markup.clearLines();\n    renderer.markup.clearPoints();\n    // Clear virtual source meshes\n    this.clearVirtualSources();\n    this.virtualSourceMap.clear();\n    this.selectedVirtualSource = null;\n  }\n\n  private drawPaths() {\n    // Use renderer.markup.addLine() like ImageSourceSolver for consistent visualization\n    // Use the same color scale as LTPChart for visual consistency\n    // Filter paths by visible orders\n    const filteredPaths = this.validPaths.filter(path => this._visibleOrders.includes(path.order));\n\n    filteredPaths.forEach(path => {\n      const colorHex = getOrderColor(path.order, this.maxReflectionOrder);\n      // Convert hex color to RGB (0-1 range)\n      const r = ((colorHex >> 16) & 0xff) / 255;\n      const g = ((colorHex >> 8) & 0xff) / 255;\n      const b = (colorHex & 0xff) / 255;\n      const color: [number, number, number] = [r, g, b];\n\n      // Draw line segments between consecutive points\n      for (let i = 0; i < path.points.length - 1; i++) {\n        const p1 = path.points[i];\n        const p2 = path.points[i + 1];\n        renderer.markup.addLine(\n          [p1.x, p1.y, p1.z],\n          [p2.x, p2.y, p2.z],\n          color,\n          color\n        );\n      }\n    });\n\n    // Add small spheres at diffraction points to distinguish them from direct paths\n    filteredPaths.forEach(path => {\n      if (path.bandEnergy && path.points.length === 3) {\n        const diffPt = path.points[1]; // [receiver, diffractionPoint, source]\n        const colorHex = getOrderColor(path.order, this.maxReflectionOrder);\n        const geom = new THREE.SphereGeometry(0.06, 8, 8);\n        const mat = new THREE.MeshBasicMaterial({ color: colorHex });\n        const sphere = new THREE.Mesh(geom, mat);\n        sphere.position.copy(diffPt);\n        this.virtualSourcesGroup.add(sphere);\n      }\n    });\n\n    // Get buffer usage stats and store in metrics\n    const usageStats = renderer.markup.getUsageStats();\n    if (this.lastMetrics) {\n      this.lastMetrics.bufferUsage = usageStats;\n    }\n\n    // Log buffer usage warnings\n    if (usageStats.overflowWarning) {\n      console.error(`⚠️ Path buffer overflow! Lines: ${usageStats.linesUsed}/${usageStats.linesCapacity}. Reduce reflection order.`);\n    } else if (usageStats.linesPercent > 80) {\n      console.warn(`Buffer usage high: Lines ${usageStats.linesPercent.toFixed(1)}%`);\n    }\n  }\n\n  private drawBeams() {\n    if (!this.btSolver) return;\n\n    // Clear virtual source meshes and map\n    this.clearVirtualSources();\n    this.virtualSourceMap.clear();\n    this.selectedVirtualSource = null;\n\n    // Get current paths to determine which virtual sources are valid\n    const paths = this.validPaths;\n\n    // Build a map of valid paths by their polygon sequence for quick lookup\n    const validPathsByPolygonSequence = new Map<string, BeamTracePath>();\n    paths.forEach(path => {\n      // Build polygon sequence key (excluding null entries for source/receiver)\n      const polygonSequence = path.polygonIds.filter(id => id !== null).join(',');\n      if (polygonSequence) {\n        validPathsByPolygonSequence.set(polygonSequence, path);\n      }\n    });\n\n    const beamData = this.btSolver.getBeamsForVisualization(this.maxReflectionOrder);\n\n    beamData.forEach((beam: BeamVisualizationData) => {\n      // Filter by visible orders\n      if (!this._visibleOrders.includes(beam.reflectionOrder)) {\n        return;\n      }\n\n      // Check if this beam has a valid path to the receiver\n      const hasValidPath = this.beamHasValidPath(beam, paths);\n\n      // Skip virtual sources without valid paths unless showAllBeams is enabled\n      if (!hasValidPath && !this._showAllBeams) {\n        return;\n      }\n\n      // Calculate sphere radius based on reflection order (smaller for higher orders)\n      const radius = Math.max(0.05, 0.10 - beam.reflectionOrder * 0.01);\n\n      // Get color based on reflection order\n      const colorHex = getOrderColor(beam.reflectionOrder, this.maxReflectionOrder);\n\n      // Dim invalid beams\n      let finalColor = colorHex;\n      if (!hasValidPath) {\n        // Mix with gray to dim\n        const r = ((colorHex >> 16) & 0xff) * 0.4 + 128 * 0.6;\n        const g = ((colorHex >> 8) & 0xff) * 0.4 + 128 * 0.6;\n        const b = (colorHex & 0xff) * 0.4 + 128 * 0.6;\n        finalColor = (Math.round(r) << 16) | (Math.round(g) << 8) | Math.round(b);\n      }\n\n      const vs = new THREE.Vector3(beam.virtualSource[0], beam.virtualSource[1], beam.virtualSource[2]);\n\n      // Create virtual source sphere mesh\n      const vsGeom = new THREE.SphereGeometry(radius, 12, 12);\n      const vsMat = new THREE.MeshStandardMaterial({\n        color: finalColor,\n        transparent: !hasValidPath,\n        opacity: hasValidPath ? 1.0 : 0.4,\n        roughness: 0.6,\n        metalness: 0.1\n      });\n      const vsMesh = new THREE.Mesh(vsGeom, vsMat);\n      vsMesh.position.copy(vs);\n      this.virtualSourcesGroup.add(vsMesh);\n\n      // Register this mesh for click detection (only valid beams are clickable)\n      if (hasValidPath) {\n        this.virtualSourceMap.set(vsMesh, {\n          ...beam,\n          polygonPath: beam.polygonPath || []\n        });\n      }\n\n      // --- Aperture polygon rendering ---\n      const apertureVerts = beam.apertureVertices;\n      if (apertureVerts && apertureVerts.length >= 3) {\n        const aperturePoints = apertureVerts.map(\n          v => new THREE.Vector3(v[0], v[1], v[2])\n        );\n\n        // (a) Filled aperture polygon using triangle fan\n        const fillGeom = new THREE.BufferGeometry();\n        const positions = new Float32Array(aperturePoints.length * 3);\n        for (let i = 0; i < aperturePoints.length; i++) {\n          positions[i * 3] = aperturePoints[i].x;\n          positions[i * 3 + 1] = aperturePoints[i].y;\n          positions[i * 3 + 2] = aperturePoints[i].z;\n        }\n        fillGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n        // Triangle fan indices: (0,1,2), (0,2,3), (0,3,4), ...\n        const indices: number[] = [];\n        for (let i = 1; i < aperturePoints.length - 1; i++) {\n          indices.push(0, i, i + 1);\n        }\n        fillGeom.setIndex(indices);\n        fillGeom.computeVertexNormals();\n\n        const fillMat = new THREE.MeshBasicMaterial({\n          color: finalColor,\n          side: THREE.DoubleSide,\n          transparent: true,\n          opacity: hasValidPath ? 0.20 : 0.08,\n          depthWrite: false,\n        });\n        const fillMesh = new THREE.Mesh(fillGeom, fillMat);\n        this.virtualSourcesGroup.add(fillMesh);\n\n        // (b) Aperture edge outline\n        const outlineGeom = new THREE.BufferGeometry().setFromPoints(aperturePoints);\n        const outlineMat = new THREE.LineBasicMaterial({\n          color: finalColor,\n          transparent: true,\n          opacity: hasValidPath ? 0.50 : 0.20,\n        });\n        const outlineLine = new THREE.LineLoop(outlineGeom, outlineMat);\n        this.virtualSourcesGroup.add(outlineLine);\n\n        // (c) Cone edges: virtual source → each aperture vertex\n        const conePositions: THREE.Vector3[] = [];\n        for (const ap of aperturePoints) {\n          conePositions.push(vs.clone(), ap);\n        }\n        const coneGeom = new THREE.BufferGeometry().setFromPoints(conePositions);\n        const coneMat = new THREE.LineBasicMaterial({\n          color: finalColor,\n          transparent: true,\n          opacity: hasValidPath ? 0.35 : 0.12,\n        });\n        const coneLines = new THREE.LineSegments(coneGeom, coneMat);\n        this.virtualSourcesGroup.add(coneLines);\n      }\n    });\n\n    // Setup click handler for virtual source selection\n    this.setupClickHandler();\n\n    renderer.needsToRender = true;\n  }\n\n  // Check if a beam has a valid path to the receiver\n  private beamHasValidPath(beam: BeamVisualizationData, paths: BeamTracePath[]): boolean {\n    const polygonPath = beam.polygonPath;\n    if (!polygonPath || polygonPath.length === 0) return false;\n\n    const targetOrder = beam.reflectionOrder;\n\n    for (const path of paths) {\n      if (path.order !== targetOrder) continue;\n\n      // Check if the polygon sequence matches\n      // polygonPath is [poly0, poly1, ..., polyN] (first to last reflection)\n      // path.polygonIds is [null, polyN, poly_{N-1}, ..., poly_1, null] (leaf to root order)\n      let matches = true;\n      for (let i = 0; i < polygonPath.length; i++) {\n        const pathIndex = targetOrder - i;\n        const pathPolygonId = path.polygonIds[pathIndex];\n        if (pathPolygonId !== polygonPath[i]) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (matches) return true;\n    }\n\n    return false;\n  }\n\n  // Clear virtual source meshes\n  private clearVirtualSources() {\n    while (this.virtualSourcesGroup.children.length > 0) {\n      const child = this.virtualSourcesGroup.children[0];\n      this.virtualSourcesGroup.remove(child);\n      if (child instanceof THREE.Mesh || child instanceof THREE.Line) {\n        child.geometry?.dispose();\n        const material = child.material;\n        if (Array.isArray(material)) {\n          for (const mat of material) {\n            if (mat instanceof THREE.Material) {\n              mat.dispose();\n            }\n          }\n        } else if (material instanceof THREE.Material) {\n          material.dispose();\n        }\n      }\n    }\n  }\n\n  /**\n   * Compute first-order UTD edge diffraction paths and add them to validPaths.\n   */\n  private _computeDiffractionPaths() {\n    if (!this.room) return;\n\n    const containers = useContainer.getState().containers;\n\n    // Build edge graph from room surfaces\n    this._edgeGraph = buildEdgeGraph(this.room.allSurfaces);\n    if (this._edgeGraph.edges.length === 0) return;\n\n    // Gather source positions and directivity data\n    const sourcePositions = new Map<string, [number, number, number]>();\n    const sourceDirectivity = new Map<string, { handler: any; refPressures: number[] }>();\n    for (const id of this.sourceIDs) {\n      const src = containers[id] as Source;\n      if (src) {\n        sourcePositions.set(id, [src.position.x, src.position.y, src.position.z]);\n        const dh = src.directivityHandler;\n        if (dh) {\n          const refPressures = new Array(this.frequencies.length);\n          for (let f = 0; f < this.frequencies.length; f++) {\n            refPressures[f] = dh.getPressureAtPosition(0, this.frequencies[f], 0, 0) as number;\n          }\n          sourceDirectivity.set(id, { handler: dh, refPressures });\n        }\n      }\n    }\n\n    // Gather receiver positions\n    const receiverPositions = new Map<string, [number, number, number]>();\n    for (const id of this.receiverIDs) {\n      const rec = containers[id];\n      if (rec) {\n        receiverPositions.set(id, [rec.position.x, rec.position.y, rec.position.z]);\n      }\n    }\n\n    // Get surface meshes for LOS checks\n    const surfaces: THREE.Mesh[] = [];\n    this.room.surfaces.traverse((container) => {\n      if (container['kind'] && container['kind'] === 'surface') {\n        surfaces.push((container as Surface).mesh);\n      }\n    });\n\n    const diffractionPaths = findDiffractionPaths(\n      this._edgeGraph,\n      sourcePositions,\n      receiverPositions,\n      this.frequencies,\n      this.c,\n      this.temperature,\n      this._raycaster,\n      surfaces,\n    );\n\n    // Convert DiffractionPath → BeamTracePath and add to validPaths\n    for (const dp of diffractionPaths) {\n      // Apply source directivity to band energies\n      const srcDir = sourceDirectivity.get(dp.sourceId);\n      if (srcDir) {\n        const srcPos = sourcePositions.get(dp.sourceId)!;\n        const dx = dp.diffractionPoint[0] - srcPos[0];\n        const dy = dp.diffractionPoint[1] - srcPos[1];\n        const dz = dp.diffractionPoint[2] - srcPos[2];\n        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (dist > 1e-10) {\n          const theta = Math.acos(Math.max(-1, Math.min(1, dy / dist))) * (180 / Math.PI);\n          const phi = Math.atan2(dz, dx) * (180 / Math.PI);\n          for (let f = 0; f < this.frequencies.length; f++) {\n            try {\n              const dirP = srcDir.handler.getPressureAtPosition(0, this.frequencies[f], Math.abs(phi), theta);\n              const refP = srcDir.refPressures[f];\n              if (typeof dirP === \"number\" && typeof refP === \"number\" && refP > 0) {\n                dp.bandEnergy[f] *= (dirP / refP) ** 2;\n              }\n            } catch (e) {\n              // Fallback to unity gain\n            }\n          }\n        }\n      }\n\n      // Compute arrival direction: diffraction point → receiver (normalized)\n      const recPos = receiverPositions.get(dp.receiverId)!;\n      const adx = recPos[0] - dp.diffractionPoint[0];\n      const ady = recPos[1] - dp.diffractionPoint[1];\n      const adz = recPos[2] - dp.diffractionPoint[2];\n      const adLen = Math.sqrt(adx * adx + ady * ady + adz * adz);\n      const arrivalDir = adLen > 1e-10\n        ? new THREE.Vector3(adx / adLen, ady / adLen, adz / adLen)\n        : new THREE.Vector3(0, 0, 1);\n\n      const srcPos = sourcePositions.get(dp.sourceId)!;\n      const receiverVec = new THREE.Vector3(recPos[0], recPos[1], recPos[2]);\n      const diffPtVec = new THREE.Vector3(dp.diffractionPoint[0], dp.diffractionPoint[1], dp.diffractionPoint[2]);\n      const sourceVec = new THREE.Vector3(srcPos[0], srcPos[1], srcPos[2]);\n\n      const beamPath: BeamTracePath = {\n        points: [receiverVec, diffPtVec, sourceVec],\n        order: 0, // diffraction is a \"direct-like\" path\n        length: dp.totalDistance,\n        arrivalTime: dp.time,\n        polygonIds: [null, null, null],\n        arrivalDirection: arrivalDir,\n        reflections: [],\n        bandEnergy: dp.bandEnergy,\n      };\n\n      this.validPaths.push(beamPath);\n    }\n\n    if (diffractionPaths.length > 0) {\n      console.log(`BeamTraceSolver: Found ${diffractionPaths.length} diffraction paths`);\n    }\n  }\n\n  /**\n   * Build per-band energy histograms from all computed paths (for tail synthesis).\n   */\n  private _buildEnergyHistogram() {\n    const numBands = this.frequencies.length;\n    this._energyHistogram = [];\n    for (let f = 0; f < numBands; f++) {\n      this._energyHistogram.push(new Float32Array(HISTOGRAM_NUM_BINS));\n    }\n\n    const initialSPL = 100;\n    const spls = Array(numBands).fill(initialSPL);\n\n    const recForHist = this.receiverIDs.length > 0\n      ? useContainer.getState().containers[this.receiverIDs[0]] as Receiver\n      : null;\n\n    for (const path of this.validPaths) {\n      const bin = Math.floor(path.arrivalTime / HISTOGRAM_BIN_WIDTH);\n      if (bin < 0 || bin >= HISTOGRAM_NUM_BINS) continue;\n\n      const dir = path.arrivalDirection;\n      const recGain = recForHist ? recForHist.getGain([dir.x, dir.y, dir.z]) : 1.0;\n      const pressure = this.calculateArrivalPressure(spls, path, recGain);\n\n      for (let f = 0; f < numBands; f++) {\n        // Energy = pressure²\n        this._energyHistogram![f][bin] += pressure[f] * pressure[f];\n      }\n    }\n  }\n\n  // Calculate impulse response\n  async calculateImpulseResponse(): Promise<AudioBuffer> {\n    if (this.validPaths.length === 0) {\n      throw new Error(\"No paths calculated yet. Run calculate() first.\");\n    }\n\n    const sampleRate = audioEngine.sampleRate;\n    const initialSPL = 100;\n    const spls = Array(this.frequencies.length).fill(initialSPL);\n\n    const totalTime = this.validPaths[this.validPaths.length - 1].arrivalTime + 0.05;\n    const numberOfSamples = Math.floor(sampleRate * totalTime) * 2;\n\n    const samples: Float32Array[] = [];\n    for (let f = 0; f < this.frequencies.length; f++) {\n      samples.push(new Float32Array(numberOfSamples));\n    }\n\n    // Add contributions from each path (with receiver directivity)\n    const recForIR = this.receiverIDs.length > 0\n      ? useContainer.getState().containers[this.receiverIDs[0]] as Receiver\n      : null;\n\n    for (const path of this.validPaths) {\n      const randomPhase = Math.random() > 0.5 ? 1 : -1;\n      const dir = path.arrivalDirection;\n      const recGain = recForIR ? recForIR.getGain([dir.x, dir.y, dir.z]) : 1.0;\n      const pressure = this.calculateArrivalPressure(spls, path, recGain);\n      const roundedSample = Math.floor(path.arrivalTime * sampleRate);\n\n      for (let f = 0; f < this.frequencies.length; f++) {\n        if (roundedSample < samples[f].length) {\n          samples[f][roundedSample] += pressure[f] * randomPhase;\n        }\n      }\n    }\n\n    // Apply late reverberation tail synthesis\n    let finalSamples = samples;\n    if (this.lateReverbTailEnabled && this._energyHistogram) {\n      const decayParams = extractDecayParameters(\n        this._energyHistogram, this.frequencies,\n        this.tailCrossfadeTime, HISTOGRAM_BIN_WIDTH\n      );\n      const { tailSamples, tailStartSample } = synthesizeTail(decayParams, sampleRate);\n      const crossfadeDurationSamples = Math.floor(this.tailCrossfadeDuration * sampleRate);\n      finalSamples = assembleFinalIR(samples, tailSamples, tailStartSample, crossfadeDurationSamples);\n    }\n\n    // Use filter worker (similar to RayTracer)\n    const FilterWorker = () => new Worker(new URL('../../audio-engine/filter.worker.ts', import.meta.url));\n    const worker = FilterWorker();\n\n    return new Promise((resolve, reject) => {\n      worker.postMessage({ samples: finalSamples });\n\n      worker.onmessage = (event) => {\n        const filteredSamples = event.data.samples as Float32Array[];\n        const signal = new Float32Array(filteredSamples[0].length >> 1);\n\n        let max = 0;\n        for (let i = 0; i < filteredSamples.length; i++) {\n          for (let j = 0; j < signal.length; j++) {\n            signal[j] += filteredSamples[i][j];\n            if (Math.abs(signal[j]) > max) {\n              max = Math.abs(signal[j]);\n            }\n          }\n        }\n\n        const normalizedSignal = normalize(signal);\n        const offlineContext = audioEngine.createOfflineContext(1, signal.length, sampleRate);\n        const source = audioEngine.createBufferSource(normalizedSignal, offlineContext);\n\n        source.connect(offlineContext.destination);\n        source.start();\n\n        audioEngine.renderContextAsync(offlineContext)\n          .then(ir => {\n            this.impulseResponse = ir;\n            this.updateImpulseResponseResult(ir, sampleRate);\n            resolve(ir);\n          })\n          .catch(reject)\n          .finally(() => worker.terminate());\n      };\n\n      worker.onerror = (error) => {\n        worker.terminate();\n        reject(error);\n      };\n    });\n  }\n\n  // Calculate arrival pressure for a path\n  private calculateArrivalPressure(initialSPL: number[], path: BeamTracePath, receiverGain: number = 1.0): number[] {\n    // Diffraction paths have pre-computed per-band energy — convert to pressure directly\n    if (path.bandEnergy) {\n      const initialIntensities = ac.P2I(ac.Lp2P(initialSPL)) as number[];\n      const pressures: number[] = new Array(this.frequencies.length);\n      for (let f = 0; f < this.frequencies.length; f++) {\n        const arrivalIntensity = initialIntensities[f] * path.bandEnergy[f];\n        pressures[f] = (ac.I2P([arrivalIntensity]) as number[])[0] * receiverGain;\n      }\n      return pressures;\n    }\n\n    const intensities = ac.P2I(ac.Lp2P(initialSPL)) as number[];\n\n    // Apply source directivity weighting\n    // Direction from source (last point) toward the first reflection (or receiver for direct path)\n    const sourceIdx = path.points.length - 1;\n    if (sourceIdx >= 1 && this.sourceIDs.length > 0) {\n      const source = useContainer.getState().containers[this.sourceIDs[0]] as Source;\n      if (source?.directivityHandler) {\n        const sourcePos = path.points[sourceIdx];\n        const nextPoint = path.points[sourceIdx - 1];\n        const worldDir = new THREE.Vector3().subVectors(nextPoint, sourcePos).normalize();\n\n        // Convert world direction to source-local spherical angles\n        const localDir = worldDir.clone().applyEuler(\n          new THREE.Euler(-source.rotation.x, -source.rotation.y, -source.rotation.z, source.rotation.order)\n        );\n        const r = localDir.length();\n        if (r > 1e-10) {\n          const theta = Math.acos(Math.min(1, Math.max(-1, localDir.z / r)));\n          const phi = Math.atan2(localDir.y, localDir.x);\n          const phiDeg = ((phi * 180 / Math.PI) % 360 + 360) % 360;\n          const thetaDeg = theta * 180 / Math.PI;\n\n          for (let f = 0; f < this.frequencies.length; f++) {\n            const dirPressure = source.directivityHandler.getPressureAtPosition(0, this.frequencies[f], phiDeg, thetaDeg);\n            const refPressure = source.directivityHandler.getPressureAtPosition(0, this.frequencies[f], 0, 0);\n            if (typeof dirPressure === 'number' && typeof refPressure === 'number' && refPressure > 0) {\n              intensities[f] *= (dirPressure / refPressure) ** 2;\n            }\n          }\n        }\n      }\n    }\n\n    // Apply angle-dependent reflection at each reflection point\n    // path.reflections (from DetailedReflectionPath3D) lists only actual reflections in order,\n    // while path.polygonIds includes null entries for source/receiver.\n    let reflectionIdx = 0;\n\n    path.polygonIds.forEach((polygonId, idx) => {\n      if (polygonId === null) return; // Source or receiver point\n\n      const surface = this.polygonToSurface.get(polygonId);\n      if (!surface) {\n        reflectionIdx++;\n        return;\n      }\n\n      // Use pre-computed incidence angle from library when available\n      let angle = 0; // fallback to normal incidence\n      if (path.reflections && reflectionIdx < path.reflections.length) {\n        angle = path.reflections[reflectionIdx].incidenceAngle;\n      } else if (idx > 0 && idx < path.points.length - 1) {\n        // Fallback: compute from path geometry\n        const toSource = new THREE.Vector3().subVectors(path.points[idx + 1], path.points[idx]).normalize();\n        const toReceiver = new THREE.Vector3().subVectors(path.points[idx - 1], path.points[idx]).normalize();\n        const cosAngle = Math.min(1, Math.max(-1, toSource.dot(toReceiver)));\n        angle = Math.acos(cosAngle) / 2;\n      }\n      reflectionIdx++;\n\n      for (let f = 0; f < this.frequencies.length; f++) {\n        const R = Math.abs(surface.reflectionFunction(this.frequencies[f], angle));\n        intensities[f] *= R;\n      }\n    });\n\n    // Convert back to SPL and apply air absorption\n    const arrivalLp = ac.P2Lp(ac.I2P(intensities)) as number[];\n    const airAttenuationdB = ac.airAttenuation(this.frequencies, this.temperature);\n\n    for (let f = 0; f < this.frequencies.length; f++) {\n      arrivalLp[f] -= airAttenuationdB[f] * path.length;\n    }\n\n    // Apply receiver directivity gain\n    const pressures = ac.Lp2P(arrivalLp) as number[];\n    if (receiverGain !== 1.0) {\n      for (let f = 0; f < pressures.length; f++) {\n        pressures[f] *= receiverGain;\n      }\n    }\n    return pressures;\n  }\n\n  // Update the IR result with calculated data\n  private updateImpulseResponseResult(ir: AudioBuffer, sampleRate: number) {\n    const containers = useContainer.getState().containers;\n    const sourceName = this.sourceIDs.length > 0 ? containers[this.sourceIDs[0]]?.name || 'source' : 'source';\n    const receiverName = this.receiverIDs.length > 0 ? containers[this.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n\n    // Convert AudioBuffer to time/amplitude data for the chart\n    const channelData = ir.getChannelData(0);\n    const data: { time: number; amplitude: number }[] = [];\n\n    // Downsample for display (show every Nth sample to keep data manageable)\n    const downsampleFactor = Math.max(1, Math.floor(channelData.length / 2000));\n    for (let i = 0; i < channelData.length; i += downsampleFactor) {\n      data.push({\n        time: i / sampleRate,\n        amplitude: channelData[i]\n      });\n    }\n\n    console.log(`BeamTraceSolver: Updating IR result with ${data.length} samples, duration: ${(channelData.length / sampleRate).toFixed(3)}s`);\n\n    const result: Result<ResultKind.ImpulseResponse> = {\n      kind: ResultKind.ImpulseResponse,\n      data,\n      info: {\n        sampleRate,\n        sourceName,\n        receiverName,\n        sourceId: this.sourceIDs[0] || \"\",\n        receiverId: this.receiverIDs[0] || \"\"\n      },\n      name: `IR: ${sourceName} → ${receiverName}`,\n      uuid: this.impulseResponseResult,\n      from: this.uuid\n    };\n\n    emit(\"UPDATE_RESULT\", { uuid: this.impulseResponseResult, result });\n  }\n\n  async playImpulseResponse() {\n    const result = await sharedPlayIR(\n      this.impulseResponse, () => this.calculateImpulseResponse(), this.uuid, \"BEAMTRACE_SET_PROPERTY\"\n    );\n    this.impulseResponse = result.impulseResponse;\n  }\n\n  async downloadImpulseResponse(filename: string, sampleRate = audioEngine.sampleRate) {\n    const result = await sharedDownloadIR(\n      this.impulseResponse, () => this.calculateImpulseResponse(), filename, sampleRate\n    );\n    this.impulseResponse = result.impulseResponse;\n  }\n\n  // Ambisonic impulse response storage\n  ambisonicImpulseResponse?: AudioBuffer;\n  ambisonicOrder: number = 1;\n\n  /**\n   * Calculate an ambisonic impulse response from the beam-traced paths.\n   * Each reflection is encoded based on its arrival direction at the receiver.\n   *\n   * @param order - Ambisonic order (1 = first order with 4 channels, 2 = 9 channels, etc.)\n   * @returns Promise resolving to an AudioBuffer with ambisonic channels\n   */\n  async calculateAmbisonicImpulseResponse(order: number = 1): Promise<AudioBuffer> {\n    if (this.validPaths.length === 0) {\n      throw new Error(\"No paths calculated yet. Run calculate() first.\");\n    }\n\n    const sampleRate = audioEngine.sampleRate;\n    const initialSPL = 100;\n    const spls = Array(this.frequencies.length).fill(initialSPL);\n\n    const totalTime = this.validPaths[this.validPaths.length - 1].arrivalTime + 0.05;\n    if (totalTime <= 0) throw new Error(\"Invalid impulse response duration\");\n    const numberOfSamples = Math.floor(sampleRate * totalTime) * 2;\n    if (numberOfSamples < 2) throw new Error(\"Impulse response too short to process\");\n    const nCh = getAmbisonicChannelCount(order);\n\n    // Create per-frequency, per-channel sample buffers\n    const samples: Float32Array[][] = [];\n    for (let f = 0; f < this.frequencies.length; f++) {\n      samples.push([]);\n      for (let ch = 0; ch < nCh; ch++) {\n        samples[f].push(new Float32Array(numberOfSamples));\n      }\n    }\n\n    // Process each path (with receiver directivity)\n    const recForAmbi = this.receiverIDs.length > 0\n      ? useContainer.getState().containers[this.receiverIDs[0]] as Receiver\n      : null;\n\n    for (const path of this.validPaths) {\n      const randomPhase = Math.random() > 0.5 ? 1 : -1;\n      const dir = path.arrivalDirection;\n      const recGain = recForAmbi ? recForAmbi.getGain([dir.x, dir.y, dir.z]) : 1.0;\n      const pressure = this.calculateArrivalPressure(spls, path, recGain);\n      const roundedSample = Math.floor(path.arrivalTime * sampleRate);\n\n      if (roundedSample >= numberOfSamples) continue;\n\n      // Create a single-sample impulse for this reflection\n      const impulse = new Float32Array(1);\n\n      // Encode each frequency band\n      for (let f = 0; f < this.frequencies.length; f++) {\n        impulse[0] = pressure[f] * randomPhase;\n\n        // Encode the impulse at this direction (using Three.js coordinate system)\n        const encoded = encodeBufferFromDirection(impulse, dir.x, dir.y, dir.z, order, 'threejs');\n\n        // Add to the output buffers\n        for (let ch = 0; ch < nCh; ch++) {\n          samples[f][ch][roundedSample] += encoded[ch][0];\n        }\n      }\n    }\n\n    // Apply late reverberation tail synthesis to W-channel (channel 0) only\n    if (this.lateReverbTailEnabled && this._energyHistogram) {\n      const decayParams = extractDecayParameters(\n        this._energyHistogram, this.frequencies,\n        this.tailCrossfadeTime, HISTOGRAM_BIN_WIDTH\n      );\n      const { tailSamples, tailStartSample } = synthesizeTail(decayParams, sampleRate);\n      const crossfadeDurationSamples = Math.floor(this.tailCrossfadeDuration * sampleRate);\n      // Gather W-channel (ch=0) per-band samples\n      const wChannelSamples: Float32Array[] = [];\n      for (let f = 0; f < this.frequencies.length; f++) {\n        wChannelSamples.push(samples[f][0]);\n      }\n      const extendedW = assembleFinalIR(wChannelSamples, tailSamples, tailStartSample, crossfadeDurationSamples);\n      // Write back extended W-channel samples\n      for (let f = 0; f < this.frequencies.length; f++) {\n        samples[f][0] = extendedW[f];\n      }\n    }\n\n    // Use filter worker to apply octave-band filtering\n    const FilterWorker = () => new Worker(new URL('../../audio-engine/filter.worker.ts', import.meta.url));\n\n    return new Promise((resolve, reject) => {\n      // Process each ambisonic channel through the filter bank\n      const processChannel = async (chIndex: number): Promise<Float32Array> => {\n        return new Promise((resolveChannel) => {\n          const channelFreqSamples: Float32Array[] = [];\n          for (let f = 0; f < this.frequencies.length; f++) {\n            channelFreqSamples.push(samples[f][chIndex]);\n          }\n\n          const channelWorker = FilterWorker();\n          channelWorker.postMessage({ samples: channelFreqSamples });\n          channelWorker.onmessage = (event) => {\n            const filteredSamples = event.data.samples as Float32Array[];\n            const signal = new Float32Array(filteredSamples[0].length >> 1);\n\n            for (let f = 0; f < filteredSamples.length; f++) {\n              for (let j = 0; j < signal.length; j++) {\n                signal[j] += filteredSamples[f][j];\n              }\n            }\n\n            channelWorker.terminate();\n            resolveChannel(signal);\n          };\n        });\n      };\n\n      // Process all channels\n      Promise.all(\n        Array.from({ length: nCh }, (_, ch) => processChannel(ch))\n      ).then((channelSignals) => {\n        // Find global max for normalization\n        let max = 0;\n        for (const signal of channelSignals) {\n          for (let j = 0; j < signal.length; j++) {\n            if (Math.abs(signal[j]) > max) {\n              max = Math.abs(signal[j]);\n            }\n          }\n        }\n\n        // Normalize all channels by the same factor\n        if (max > 0) {\n          for (const signal of channelSignals) {\n            for (let j = 0; j < signal.length; j++) {\n              signal[j] /= max;\n            }\n          }\n        }\n\n        // Create multi-channel AudioBuffer\n        const signalLength = channelSignals[0].length;\n        if (signalLength === 0) {\n          reject(new Error(\"Filtered signal has zero length\"));\n          return;\n        }\n        const offlineContext = audioEngine.createOfflineContext(nCh, signalLength, sampleRate);\n        const buffer = offlineContext.createBuffer(nCh, signalLength, sampleRate);\n\n        for (let ch = 0; ch < nCh; ch++) {\n          buffer.copyToChannel(new Float32Array(channelSignals[ch]), ch);\n        }\n\n        this.ambisonicImpulseResponse = buffer;\n        this.ambisonicOrder = order;\n        resolve(buffer);\n      }).catch(reject);\n    });\n  }\n\n  async downloadAmbisonicImpulseResponse(\n    filename: string,\n    order: number = 1\n  ) {\n    const result = await sharedDownloadAmbisonicIR(\n      this.ambisonicImpulseResponse,\n      (o: number) => this.calculateAmbisonicImpulseResponse(o),\n      this.ambisonicOrder, order, filename\n    );\n    this.ambisonicImpulseResponse = result.ambisonicImpulseResponse;\n    this.ambisonicOrder = result.ambisonicOrder;\n  }\n\n  async calculateBinauralImpulseResponse(order: number = 1): Promise<AudioBuffer> {\n    // Get or compute ambisonic IR\n    if (!this.ambisonicImpulseResponse || this.ambisonicOrder !== order) {\n      this.ambisonicImpulseResponse = await this.calculateAmbisonicImpulseResponse(order);\n      this.ambisonicOrder = order;\n    }\n\n    this.binauralImpulseResponse = await calculateBinauralFromAmbisonic({\n      ambisonicImpulseResponse: this.ambisonicImpulseResponse,\n      order,\n      hrtfSubjectId: this.hrtfSubjectId,\n      headYaw: this.headYaw,\n      headPitch: this.headPitch,\n      headRoll: this.headRoll,\n    });\n    return this.binauralImpulseResponse;\n  }\n\n  async playBinauralImpulseResponse(order: number = 1) {\n    const result = await sharedPlayBinauralIR(\n      this.binauralImpulseResponse,\n      () => this.calculateBinauralImpulseResponse(order),\n      this.uuid, \"BEAMTRACE_SET_PROPERTY\"\n    );\n    this.binauralImpulseResponse = result.binauralImpulseResponse;\n  }\n\n  async downloadBinauralImpulseResponse(filename: string, order: number = 1) {\n    const result = await sharedDownloadBinauralIR(\n      this.binauralImpulseResponse,\n      () => this.calculateBinauralImpulseResponse(order),\n      filename\n    );\n    this.binauralImpulseResponse = result.binauralImpulseResponse;\n  }\n\n  /**\n   * Calculate per-frequency intensity response with T20/T30/T60 decay estimates.\n   * Uses existing calculateArrivalPressure() to convert beam-trace paths into\n   * the same RayPathResult format the raytracer uses, then delegates to the\n   * shared resampleResponseByIntensity() for decay-time fitting.\n   */\n  calculateResponseByIntensity() {\n    if (this.validPaths.length === 0) return;\n    if (this.receiverIDs.length === 0 || this.sourceIDs.length === 0) return;\n\n    const recId = this.receiverIDs[0];\n    const srcId = this.sourceIDs[0];\n    const initialSPL = 100;\n    const spls = Array(this.frequencies.length).fill(initialSPL);\n\n    const recForIntensity = useContainer.getState().containers[recId] as Receiver;\n\n    const sortedPaths = [...this.validPaths].sort((a, b) => a.arrivalTime - b.arrivalTime);\n\n    const response: RayPathResult[] = [];\n\n    for (const path of sortedPaths) {\n      const dir = path.arrivalDirection;\n      const recGain = recForIntensity ? recForIntensity.getGain([dir.x, dir.y, dir.z]) : 1.0;\n      const pressure = this.calculateArrivalPressure(spls, path, recGain);\n      const level = ac.P2Lp(pressure) as number[];\n\n      response.push({\n        time: path.arrivalTime,\n        bounces: path.order,\n        level,\n      });\n    }\n\n    const rbi: KVP<KVP<ResponseByIntensity>> = {\n      [recId]: {\n        [srcId]: {\n          freqs: this.frequencies,\n          response,\n        }\n      }\n    };\n\n    this.responseByIntensity = resampleResponseByIntensity(rbi, DEFAULT_INTENSITY_SAMPLE_RATE);\n  }\n\n  /**\n   * Export per-octave-band impulse responses as individual WAV files.\n   * Skips the filter worker — writes one WAV per frequency band directly.\n   */\n  downloadOctaveBandIR(filename: string, sampleRate = audioEngine.sampleRate) {\n    if (this.validPaths.length === 0) {\n      throw new Error(\"No paths calculated yet. Run calculate() first.\");\n    }\n\n    const initialSPL = 100;\n    const spls = Array(this.frequencies.length).fill(initialSPL);\n    const sortedPaths = [...this.validPaths].sort((a, b) => a.arrivalTime - b.arrivalTime);\n\n    const totalTime = sortedPaths[sortedPaths.length - 1].arrivalTime + 0.05;\n    const numberOfSamples = Math.floor(sampleRate * totalTime);\n\n    const samples: Float32Array[] = [];\n    for (let f = 0; f < this.frequencies.length; f++) {\n      samples.push(new Float32Array(numberOfSamples));\n    }\n\n    const recForDownload = this.receiverIDs.length > 0\n      ? useContainer.getState().containers[this.receiverIDs[0]] as Receiver\n      : null;\n\n    for (const path of sortedPaths) {\n      const randomPhase = Math.random() > 0.5 ? 1 : -1;\n      const dir = path.arrivalDirection;\n      const recGain = recForDownload ? recForDownload.getGain([dir.x, dir.y, dir.z]) : 1.0;\n      const pressure = this.calculateArrivalPressure(spls, path, recGain);\n      const roundedSample = Math.floor(path.arrivalTime * sampleRate);\n\n      for (let f = 0; f < this.frequencies.length; f++) {\n        if (roundedSample < samples[f].length) {\n          samples[f][roundedSample] += pressure[f] * randomPhase;\n        }\n      }\n    }\n\n    for (let f = 0; f < this.frequencies.length; f++) {\n      const blob = ac.wavAsBlob([normalize(samples[f])], { sampleRate, bitDepth: 32 });\n      FileSaver.saveAs(blob, `${this.frequencies[f]}_${filename}.wav`);\n    }\n  }\n\n  /**\n   * Quick RT60 estimate by shooting random rays through the room geometry.\n   * Runs in batches via setInterval to avoid blocking the UI.\n   */\n  startQuickEstimate(numRays: number = 500) {\n    // Cancel any running estimate\n    if (this._quickEstimateInterval !== null) {\n      window.clearInterval(this._quickEstimateInterval);\n      this._quickEstimateInterval = null;\n    }\n\n    if (this.sourceIDs.length === 0) return;\n    const source = useContainer.getState().containers[this.sourceIDs[0]] as Source;\n    if (!source) return;\n\n    // Gather surface meshes for raycasting (same as _computeDiffractionPaths)\n    const room = this.room;\n    if (!room) return;\n\n    const surfaceMeshes: THREE.Object3D[] = [];\n    room.surfaces.traverse((child: THREE.Object3D) => {\n      if ((child as THREE.Mesh).isMesh) {\n        surfaceMeshes.push(child);\n      }\n    });\n    if (surfaceMeshes.length === 0) return;\n\n    this.quickEstimateResults = [];\n    this.estimatedT30 = null;\n    let count = 0;\n    const batchSize = 10;\n\n    this._quickEstimateInterval = window.setInterval(() => {\n      for (let i = 0; i < batchSize && count < numRays; i++, count++) {\n        const result = sharedQuickEstimateStep(\n          this._raycaster, surfaceMeshes,\n          source.position, source.initialIntensity,\n          this.frequencies, this.temperature\n        );\n        this.quickEstimateResults.push(result);\n      }\n\n      if (count >= numRays) {\n        window.clearInterval(this._quickEstimateInterval!);\n        this._quickEstimateInterval = null;\n\n        // Average per-band RT60s\n        const numBands = this.frequencies.length;\n        const avgRt60s = Array(numBands).fill(0);\n        let validCounts = Array(numBands).fill(0);\n\n        for (const r of this.quickEstimateResults) {\n          for (let f = 0; f < numBands; f++) {\n            if (r.rt60s[f] > 0) {\n              avgRt60s[f] += r.rt60s[f];\n              validCounts[f]++;\n            }\n          }\n        }\n\n        for (let f = 0; f < numBands; f++) {\n          avgRt60s[f] = validCounts[f] > 0 ? avgRt60s[f] / validCounts[f] : 0;\n        }\n\n        this.estimatedT30 = avgRt60s;\n        emit(\"BEAMTRACE_QUICK_ESTIMATE_COMPLETE\", this.uuid);\n      }\n    }, 5);\n  }\n\n  // Clear results\n  reset() {\n    this.validPaths = [];\n    this.clearVisualization();\n    this.btSolver = null;\n    this.lastMetrics = null;\n\n    // Clear response-by-intensity data\n    this.responseByIntensity = undefined;\n\n    // Clear quick estimate\n    if (this._quickEstimateInterval !== null) {\n      window.clearInterval(this._quickEstimateInterval);\n      this._quickEstimateInterval = null;\n    }\n    this.quickEstimateResults = [];\n    this.estimatedT30 = null;\n\n    // Clear LTP data\n    this.clearLevelTimeProgressionData();\n\n    // Clear highlighted path and beams\n    (this.selectedPath.geometry as MeshLine).setPoints([]);\n    this.clearSelectedBeams();\n\n    renderer.needsToRender = true;\n  }\n\n  // Helper to clear highlighted beam lines\n  private clearSelectedBeams() {\n    while (this.selectedBeamsGroup.children.length > 0) {\n      const child = this.selectedBeamsGroup.children[0];\n      this.selectedBeamsGroup.remove(child);\n      if (child instanceof THREE.Mesh || child instanceof THREE.Line) {\n        child.geometry?.dispose();\n        if (child.material instanceof THREE.Material) {\n          child.material.dispose();\n        }\n      }\n    }\n  }\n\n  // Getters and setters\n  get room(): Room | undefined {\n    return useContainer.getState().containers[this.roomID] as Room | undefined;\n  }\n\n  get sources(): Source[] {\n    return this.sourceIDs\n      .map(id => useContainer.getState().containers[id] as Source)\n      .filter(Boolean);\n  }\n\n  get receivers(): Receiver[] {\n    return this.receiverIDs\n      .map(id => useContainer.getState().containers[id] as Receiver)\n      .filter(Boolean);\n  }\n\n  get numValidPaths(): number {\n    return this.validPaths.length;\n  }\n\n  set maxReflectionOrderReset(order: number) {\n    // Clamp to non-negative integer\n    this.maxReflectionOrder = Math.max(0, Math.floor(order));\n    // Update plotOrders and visibleOrders to include all orders up to the new max\n    this._plotOrders = Array.from({ length: this.maxReflectionOrder + 1 }, (_, i) => i);\n    this._visibleOrders = Array.from({ length: this.maxReflectionOrder + 1 }, (_, i) => i);\n    // Auto-recalculate if we have sources and receivers configured\n    if (this.sourceIDs.length > 0 && this.receiverIDs.length > 0) {\n      this.calculate();\n      emit(\"BEAMTRACE_CALCULATE_COMPLETE\", this.uuid);\n    } else {\n      this.reset();\n    }\n  }\n\n  get maxReflectionOrderReset(): number {\n    return this.maxReflectionOrder;\n  }\n\n  get visualizationMode(): VisualizationMode {\n    return this._visualizationMode;\n  }\n\n  set visualizationMode(mode: VisualizationMode) {\n    this._visualizationMode = mode;\n\n    // Clear and redraw based on mode\n    this.clearVisualization();\n\n    switch (mode) {\n      case \"rays\":\n        if (this.validPaths.length > 0) {\n          this.drawPaths();\n        }\n        break;\n      case \"beams\":\n        if (this.btSolver) {\n          this.drawBeams();\n        }\n        break;\n      case \"both\":\n        if (this.validPaths.length > 0) {\n          this.drawPaths();\n        }\n        if (this.btSolver) {\n          this.drawBeams();\n        }\n        break;\n    }\n\n    renderer.needsToRender = true;\n  }\n\n  // Show all beams toggle (including invalid/orphaned beams)\n  get showAllBeams(): boolean {\n    return this._showAllBeams;\n  }\n\n  set showAllBeams(value: boolean) {\n    this._showAllBeams = value;\n    // Redraw beams if in beams or both mode\n    if (this._visualizationMode === \"beams\" || this._visualizationMode === \"both\") {\n      this.clearVisualization();\n      if (this._visualizationMode === \"both\" && this.validPaths.length > 0) {\n        this.drawPaths();\n      }\n      if (this.btSolver) {\n        this.drawBeams();\n      }\n      renderer.needsToRender = true;\n    }\n  }\n\n  // Visible reflection orders for filtering visualization\n  get visibleOrders(): number[] {\n    return this._visibleOrders;\n  }\n\n  set visibleOrders(orders: number[]) {\n    this._visibleOrders = orders;\n    // Redraw visualization with new filter\n    this.clearVisualization();\n    switch (this._visualizationMode) {\n      case \"rays\":\n        if (this.validPaths.length > 0) {\n          this.drawPaths();\n        }\n        break;\n      case \"beams\":\n        if (this.btSolver) {\n          this.drawBeams();\n        }\n        break;\n      case \"both\":\n        if (this.validPaths.length > 0) {\n          this.drawPaths();\n        }\n        if (this.btSolver) {\n          this.drawBeams();\n        }\n        break;\n    }\n    renderer.needsToRender = true;\n  }\n\n  // Debug a specific beam path by polygon IDs\n  debugBeamPath(polygonPath: number[]) {\n    if (!this.btSolver) {\n      console.warn(\"BeamTraceSolver: No solver built. Run calculate() first.\");\n      return;\n    }\n    if (this.receiverIDs.length === 0) {\n      console.warn(\"BeamTraceSolver: No receiver selected for debugging.\");\n      return;\n    }\n\n    const receiver = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\n    if (!receiver) {\n      console.warn(\"BeamTraceSolver: Receiver not found.\");\n      return;\n    }\n\n    const listenerPos: BT_Vector3 = [\n      receiver.position.x,\n      receiver.position.y,\n      receiver.position.z\n    ];\n\n    console.group(`🔍 Debugging beam path: [${polygonPath.join(' → ')}]`);\n    this.btSolver.debugBeamPath(listenerPos, polygonPath);\n    console.groupEnd();\n  }\n\n  // Enable/disable BSP debug output (placeholder - setBSPDebug not exported from beam-trace)\n  setBSPDebug(enabled: boolean) {\n    // Note: setBSPDebug is not currently exported from beam-trace package\n    // This is a placeholder that logs the intent\n    console.log(`BeamTraceSolver: BSP debug ${enabled ? 'enabled' : 'disabled'} (note: requires beam-trace package update to export setBSPDebug)`);\n  }\n\n  // Get detailed paths with reflection information\n  getDetailedPaths(): DetailedReflectionPath3D[] {\n    if (!this.btSolver) {\n      console.warn(\"BeamTraceSolver: No solver built. Run calculate() first.\");\n      return [];\n    }\n    if (this.receiverIDs.length === 0) {\n      console.warn(\"BeamTraceSolver: No receiver selected.\");\n      return [];\n    }\n\n    const receiver = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\n    if (!receiver) {\n      console.warn(\"BeamTraceSolver: Receiver not found.\");\n      return [];\n    }\n\n    const listenerPos: BT_Vector3 = [\n      receiver.position.x,\n      receiver.position.y,\n      receiver.position.z\n    ];\n\n    return this.btSolver.getDetailedPaths(listenerPos);\n  }\n\n  // Highlight a specific path by index (for interactive selection)\n  highlightPathByIndex(pathIndex: number) {\n    const sortedPaths = [...this.validPaths].sort((a, b) => a.arrivalTime - b.arrivalTime);\n\n    if (pathIndex < 0 || pathIndex >= sortedPaths.length) {\n      console.warn('BeamTraceSolver: Path index out of bounds:', pathIndex);\n      return;\n    }\n\n    const path = sortedPaths[pathIndex];\n\n    // Clear previous selections\n    (this.selectedPath.geometry as MeshLine).setPoints([]);\n    this.clearSelectedBeams();\n\n    // Get the order-based color for this path\n    const pathColorHex = getOrderColor(path.order, this.maxReflectionOrder);\n\n    // Draw the ray path inside the room with order-based color (solid lines)\n    const rayMaterial = new THREE.LineBasicMaterial({\n      color: pathColorHex,\n      linewidth: 2,\n      transparent: false\n    });\n\n    // Draw each segment of the ray path\n    for (let i = 0; i < path.points.length - 1; i++) {\n      const segmentGeom = new THREE.BufferGeometry().setFromPoints([\n        path.points[i],\n        path.points[i + 1]\n      ]);\n      const segmentLine = new THREE.Line(segmentGeom, rayMaterial);\n      this.selectedBeamsGroup.add(segmentLine);\n    }\n\n    // Draw dashed line from virtual source to receiver for each reflection order\n    if (this.btSolver && this.receiverIDs.length > 0) {\n      const receiver = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\n      if (receiver) {\n        // Find the virtual source for the highest order beam in this path\n        const beamData = this.btSolver.getBeamsForVisualization(this.maxReflectionOrder);\n        const lastPolygonId = path.polygonIds[path.order];\n\n        if (lastPolygonId !== null) {\n          const matchingBeam = beamData.find((beam: BeamVisualizationData) =>\n            beam.polygonId === lastPolygonId && beam.reflectionOrder === path.order\n          );\n\n          if (matchingBeam) {\n            const dashedMaterial = new THREE.LineDashedMaterial({\n              color: pathColorHex,\n              linewidth: 1,\n              dashSize: 0.3,\n              gapSize: 0.15,\n              transparent: true,\n              opacity: 0.7\n            });\n\n            const virtualSourcePos = new THREE.Vector3(\n              matchingBeam.virtualSource[0],\n              matchingBeam.virtualSource[1],\n              matchingBeam.virtualSource[2]\n            );\n            const receiverPos = receiver.position.clone();\n\n            const dashedLineGeom = new THREE.BufferGeometry().setFromPoints([virtualSourcePos, receiverPos]);\n            const dashedLine = new THREE.Line(dashedLineGeom, dashedMaterial);\n            dashedLine.computeLineDistances();\n            this.selectedBeamsGroup.add(dashedLine);\n          }\n        }\n      }\n    }\n\n    console.log(`BeamTraceSolver: Highlighting path ${pathIndex} with order ${path.order}, arrival time ${path.arrivalTime.toFixed(4)}s`);\n\n    renderer.needsToRender = true;\n  }\n\n  // Clear the current path highlight\n  clearPathHighlight() {\n    (this.selectedPath.geometry as MeshLine).setPoints([]);\n    this.clearSelectedBeams();\n    renderer.needsToRender = true;\n  }\n}\n\nexport default BeamTraceSolver;\n\n// Event type declarations\ndeclare global {\n  interface EventTypes {\n    ADD_BEAMTRACE: BeamTraceSolver | undefined;\n    REMOVE_BEAMTRACE: string;\n    BEAMTRACE_SET_PROPERTY: SetPropertyPayload<BeamTraceSolver>;\n    BEAMTRACE_CALCULATE: string;\n    BEAMTRACE_CALCULATE_COMPLETE: string;\n    BEAMTRACE_RESET: string;\n    BEAMTRACE_PLAY_IR: string;\n    BEAMTRACE_DOWNLOAD_IR: string;\n    BEAMTRACE_DOWNLOAD_AMBISONIC_IR: { uuid: string; order: number };\n    BEAMTRACE_PLAY_BINAURAL_IR: { uuid: string; order: number };\n    BEAMTRACE_DOWNLOAD_BINAURAL_IR: { uuid: string; order: number };\n    BEAMTRACE_DOWNLOAD_OCTAVE_IR: string;\n    BEAMTRACE_QUICK_ESTIMATE: string;\n    BEAMTRACE_QUICK_ESTIMATE_COMPLETE: string;\n    SHOULD_ADD_BEAMTRACE: undefined;\n  }\n}\n\n// Event handlers\non(\"BEAMTRACE_SET_PROPERTY\", setSolverProperty);\non(\"REMOVE_BEAMTRACE\", removeSolver);\non(\"ADD_BEAMTRACE\", addSolver(BeamTraceSolver));\n\non(\"BEAMTRACE_CALCULATE\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  solver.calculate();\n  // Defer the complete event to allow React state updates to flush\n  // This ensures setCalculating(true) is processed before setCalculating(false)\n  setTimeout(() => emit(\"BEAMTRACE_CALCULATE_COMPLETE\", uuid), 0);\n});\n\non(\"BEAMTRACE_RESET\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  solver.reset();\n});\n\non(\"BEAMTRACE_PLAY_IR\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  solver.playImpulseResponse().catch((err: Error) => {\n    window.alert(err.message || \"Failed to play impulse response\");\n  });\n});\n\non(\"BEAMTRACE_DOWNLOAD_IR\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  const containers = useContainer.getState().containers;\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n  const filename = `ir-beamtrace-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\n  solver.downloadImpulseResponse(filename).catch((err: Error) => {\n    window.alert(err.message || \"Failed to download impulse response\");\n  });\n});\n\non(\"BEAMTRACE_DOWNLOAD_AMBISONIC_IR\", ({ uuid, order }: { uuid: string; order: number }) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  const containers = useContainer.getState().containers;\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n  const filename = `ir-beamtrace-ambi-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\n  solver.downloadAmbisonicImpulseResponse(filename, order).catch((err: Error) => {\n    window.alert(err.message || \"Failed to download ambisonic impulse response\");\n  });\n});\n\non(\"BEAMTRACE_PLAY_BINAURAL_IR\", ({ uuid, order }: { uuid: string; order: number }) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  solver.playBinauralImpulseResponse(order).catch((err: Error) => {\n    window.alert(err.message || \"Failed to play binaural impulse response\");\n  });\n});\n\non(\"BEAMTRACE_DOWNLOAD_BINAURAL_IR\", ({ uuid, order }: { uuid: string; order: number }) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  const containers = useContainer.getState().containers;\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n  const filename = `ir-beamtrace-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\n  solver.downloadBinauralImpulseResponse(filename, order).catch((err: Error) => {\n    window.alert(err.message || \"Failed to download binaural impulse response\");\n  });\n});\n\non(\"BEAMTRACE_DOWNLOAD_OCTAVE_IR\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  const containers = useContainer.getState().containers;\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n  const filename = `ir-beamtrace-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\n  try {\n    solver.downloadOctaveBandIR(filename);\n  } catch (err: any) {\n    window.alert(err.message || \"Failed to download octave-band impulse responses\");\n  }\n});\n\non(\"BEAMTRACE_QUICK_ESTIMATE\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\n  solver.startQuickEstimate();\n});\n\non(\"SHOULD_ADD_BEAMTRACE\", () => {\n  emit(\"ADD_BEAMTRACE\", undefined);\n});\n"],"names":["Vector3","x","y","z","v","a","b","s","len","epsilon","normal","d","bLenSq","scale","precision","Plane3D","point","n","p1","p2","p3","v1","v2","c","plane","dist","planeToMirror","mirrorPlane","offset","tangent","bitangent","p1m","p2m","p3m","rayOrigin","rayDirection","denom","t","dotNormals","Polygon3D","vertices","materialId","verts","poly","sum","total","v0","i","cross","result","next","front","back","classification","edge","toPoint","min","max","areaThreshold","reversedVerts","flippedPlane","splitPolygon","frontVerts","backVerts","d1","d2","c1","c2","intersection","clipPolygonByPlane","input","output","current","dCurrent","dNext","currentInside","nextInside","clipPolygonByPlanes","planes","quickRejectPolygon","allBehind","buildBSP","polygons","indexed","polygon","buildBSPRecursive","splitterIndex","chooseSplitter","splitter","frontPolys","backPolys","bestIndex","bestScore","sampleSize","step","splits","j","score","rayTraceBSP","origin","direction","node","tMin","tMax","ignoreId","dOrigin","dDir","near","far","tSplit","hit","polyHit","rayTraceBSPMultiIgnore","ignoreIds","constructBeamBoundaryPlanes","virtualSource","aperture","edges","apertureCentroid","edgePlane","aperturePlane","mirrorPointAcrossPolygon","isPolygonFacingSource","centroid","toSource","MIN_APERTURE_AREA","buildBeamTree3D","sourcePosition","maxReflectionOrder","root","childVS","childBoundaries","childNode","buildBeamChildren","leafNodes","collectLeafNodes","currentOrder","maxOrder","clipped","child","clearFailPlanes","tree","clearFailPlanesRecursive","detectFailPlane","listenerPos","polyPlane","getNodeDepth","edgeCount","type","depth","isListenerBehindFailPlane","failPlane","DEFAULT_BUCKET_SIZE_3D","createBuckets3D","bucketSize","buckets","isInsideSkipSphere","skipSphere","checkSkipSphere","bucket","createSkipSphere","nodes","minDist","invalidateSkipSphere","clearBucketFailPlanes","OptimizedSolver3D","config","validPaths","directPath","intermediatePaths","skipStatus","allFailed","allHaveFailPlanes","path","convertToDetailedPath3D","dir","paths","debug","pathPoints","polygonPath","tempNode","currentPoint","currentNode","segmentIndex","imageSource","occluder","xAtCross","zAtCross","polyId","testHit","tMinVal","tMaxVal","finalHit","leafNode","failInfo","findNode","targetNode","p","beams","effectiveMaxOrder","traverse","order","pathSoFar","currentPath","computePathLength","length","computeArrivalTime","speedOfSound","getPathReflectionOrder","GRAZING_THRESHOLD_3D","calculateIncidenceAngle3D","incomingDir","surfaceNormal","cosAngle","clampedCos","getOrientedNormal3D","listenerPosition","reflections","segments","cumulativeDistance","startPoint","endPoint","segmentLength","endPolygonId","hitPoint","incomingDirection","nextPoint","outgoingDirection","incidenceAngle","reflectionAngle","isGrazing","Source3D","position","Solver3D","source","listener","pos","createHighlightLine","line","MeshLine","material","MeshLineMaterial","THREE","colorScale","chroma","getOrderColor","numColors","colors","colorIndex","color","defaults","BeamTraceSolver","Solver","params","uuidv4","_","rooms","getRooms","emit","ResultKind","renderer","ac.soundSpeed","pickProps","state","canvas","getMouseNDC","event","rect","mouse","raycaster","virtualSourceMeshes","intersects","clickedMesh","beam","colorHex","vs","receiver","useContainer","receiverPos","dashedMaterial","unfoldedLineGeom","unfoldedLine","highlightGeom","highlightMat","highlightMesh","targetOrder","pathOrder","matches","pathIndex","points","numReflections","start","end","segLen","midPoint","segmentOrder","segColor","cylGeom","cylMat","cyl","quaternion","pointOrder","pointColor","pointGeom","pointMat","pointMesh","room","surface","surfacePolygons","startIndex","geometry","posAttr","worldMatrix","indices","positions","processTriangle","i0","i1","i2","indexArray","numVertices","sourcePos","btSource","receiverID","detailedPaths","detailed","btPath","arrivalTime","polygonIds","arrivalDirection","r","sortedPaths","levelTimeProgression","useResult","recForLTP","recGain","pressure","pressureLp","ac.P2Lp","f","orders","pathUuid","match","filteredPaths","g","diffPt","geom","mat","sphere","usageStats","validPathsByPolygonSequence","polygonSequence","id","hasValidPath","radius","finalColor","vsGeom","vsMat","vsMesh","apertureVerts","aperturePoints","fillGeom","fillMat","fillMesh","outlineGeom","outlineMat","outlineLine","conePositions","ap","coneGeom","coneMat","coneLines","containers","buildEdgeGraph","sourcePositions","sourceDirectivity","src","dh","refPressures","receiverPositions","rec","surfaces","container","diffractionPaths","findDiffractionPaths","dp","srcDir","srcPos","dx","dy","dz","theta","phi","dirP","refP","recPos","adx","ady","adz","adLen","arrivalDir","receiverVec","diffPtVec","sourceVec","beamPath","numBands","HISTOGRAM_NUM_BINS","spls","recForHist","bin","HISTOGRAM_BIN_WIDTH","sampleRate","audioEngine","totalTime","numberOfSamples","samples","recForIR","randomPhase","roundedSample","finalSamples","decayParams","extractDecayParameters","tailSamples","tailStartSample","synthesizeTail","crossfadeDurationSamples","assembleFinalIR","worker","resolve","reject","filteredSamples","signal","normalizedSignal","normalize","offlineContext","ir","error","initialSPL","receiverGain","initialIntensities","ac.P2I","ac.Lp2P","pressures","arrivalIntensity","ac.I2P","intensities","sourceIdx","localDir","phiDeg","thetaDeg","dirPressure","refPressure","reflectionIdx","polygonId","idx","angle","toReceiver","R","arrivalLp","airAttenuationdB","ac.airAttenuation","sourceName","receiverName","channelData","data","downsampleFactor","sharedPlayIR","filename","sharedDownloadIR","nCh","getAmbisonicChannelCount","ch","recForAmbi","impulse","encoded","encodeBufferFromDirection","wChannelSamples","extendedW","FilterWorker","processChannel","chIndex","resolveChannel","channelFreqSamples","channelWorker","channelSignals","signalLength","buffer","sharedDownloadAmbisonicIR","o","calculateBinauralFromAmbisonic","sharedPlayBinauralIR","sharedDownloadBinauralIR","recId","srcId","recForIntensity","response","level","rbi","resampleResponseByIntensity","DEFAULT_INTENSITY_SAMPLE_RATE","recForDownload","blob","ac.wavAsBlob","FileSaver","numRays","surfaceMeshes","count","batchSize","sharedQuickEstimateStep","avgRt60s","validCounts","mode","value","enabled","pathColorHex","rayMaterial","segmentGeom","segmentLine","beamData","lastPolygonId","matchingBeam","virtualSourcePos","dashedLineGeom","dashedLine","on","setSolverProperty","removeSolver","addSolver","uuid","useSolver","err","solver"],"mappings":";;;;;;;;;;AAKO,MAAMA,IAAU;AAAA;AAAA;AAAA;AAAA,EAInB,OAAOC,GAAGC,GAAGC,GAAG;AACZ,WAAO,CAACF,GAAGC,GAAGC,CAAC;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO;AACH,WAAO,CAAC,GAAG,GAAG,CAAC;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAMC,GAAG;AACL,WAAO,CAACA,EAAE,CAAC,GAAGA,EAAE,CAAC,GAAGA,EAAE,CAAC,CAAC;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAIA,IAAIC,GAAGC,GAAG;AACN,WAAO,CAACD,EAAE,CAAC,IAAIC,EAAE,CAAC,GAAGD,EAAE,CAAC,IAAIC,EAAE,CAAC,GAAGD,EAAE,CAAC,IAAIC,EAAE,CAAC,CAAC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAIA,SAASD,GAAGC,GAAG;AACX,WAAO,CAACD,EAAE,CAAC,IAAIC,EAAE,CAAC,GAAGD,EAAE,CAAC,IAAIC,EAAE,CAAC,GAAGD,EAAE,CAAC,IAAIC,EAAE,CAAC,CAAC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAMF,GAAGG,GAAG;AACR,WAAO,CAACH,EAAE,CAAC,IAAIG,GAAGH,EAAE,CAAC,IAAIG,GAAGH,EAAE,CAAC,IAAIG,CAAC;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAIA,OAAOH,GAAG;AACN,WAAO,CAAC,CAACA,EAAE,CAAC,GAAG,CAACA,EAAE,CAAC,GAAG,CAACA,EAAE,CAAC,CAAC;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAIA,IAAIC,GAAGC,GAAG;AACN,WAAOD,EAAE,CAAC,IAAIC,EAAE,CAAC,IAAID,EAAE,CAAC,IAAIC,EAAE,CAAC,IAAID,EAAE,CAAC,IAAIC,EAAE,CAAC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAMD,GAAGC,GAAG;AACR,WAAO;AAAA,MACHD,EAAE,CAAC,IAAIC,EAAE,CAAC,IAAID,EAAE,CAAC,IAAIC,EAAE,CAAC;AAAA,MACxBD,EAAE,CAAC,IAAIC,EAAE,CAAC,IAAID,EAAE,CAAC,IAAIC,EAAE,CAAC;AAAA,MACxBD,EAAE,CAAC,IAAIC,EAAE,CAAC,IAAID,EAAE,CAAC,IAAIC,EAAE,CAAC;AAAA,IACpC;AAAA,EACI;AAAA;AAAA;AAAA;AAAA,EAIA,cAAcF,GAAG;AACb,WAAOA,EAAE,CAAC,IAAIA,EAAE,CAAC,IAAIA,EAAE,CAAC,IAAIA,EAAE,CAAC,IAAIA,EAAE,CAAC,IAAIA,EAAE,CAAC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAIA,OAAOA,GAAG;AACN,WAAO,KAAK,KAAKJ,EAAQ,cAAcI,CAAC,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAUA,GAAG;AACT,UAAMI,IAAMR,EAAQ,OAAOI,CAAC;AAC5B,WAAII,IAAM,QACC,CAAC,GAAG,GAAG,CAAC,IACZ,CAACJ,EAAE,CAAC,IAAII,GAAKJ,EAAE,CAAC,IAAII,GAAKJ,EAAE,CAAC,IAAII,CAAG;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAIA,KAAKH,GAAGC,GAAG,GAAG;AACV,WAAO;AAAA,MACHD,EAAE,CAAC,IAAI,KAAKC,EAAE,CAAC,IAAID,EAAE,CAAC;AAAA,MACtBA,EAAE,CAAC,IAAI,KAAKC,EAAE,CAAC,IAAID,EAAE,CAAC;AAAA,MACtBA,EAAE,CAAC,IAAI,KAAKC,EAAE,CAAC,IAAID,EAAE,CAAC;AAAA,IAClC;AAAA,EACI;AAAA;AAAA;AAAA;AAAA,EAIA,SAASA,GAAGC,GAAG;AACX,WAAON,EAAQ,OAAOA,EAAQ,SAASK,GAAGC,CAAC,CAAC;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAIA,gBAAgBD,GAAGC,GAAG;AAClB,WAAON,EAAQ,cAAcA,EAAQ,SAASK,GAAGC,CAAC,CAAC;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAIA,OAAOD,GAAGC,GAAGG,IAAU,OAAO;AAC1B,WAAO,KAAK,IAAIJ,EAAE,CAAC,IAAIC,EAAE,CAAC,CAAC,IAAIG,KAC3B,KAAK,IAAIJ,EAAE,CAAC,IAAIC,EAAE,CAAC,CAAC,IAAIG,KACxB,KAAK,IAAIJ,EAAE,CAAC,IAAIC,EAAE,CAAC,CAAC,IAAIG;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAIA,IAAIJ,GAAGC,GAAG;AACN,WAAO;AAAA,MACH,KAAK,IAAID,EAAE,CAAC,GAAGC,EAAE,CAAC,CAAC;AAAA,MACnB,KAAK,IAAID,EAAE,CAAC,GAAGC,EAAE,CAAC,CAAC;AAAA,MACnB,KAAK,IAAID,EAAE,CAAC,GAAGC,EAAE,CAAC,CAAC;AAAA,IAC/B;AAAA,EACI;AAAA;AAAA;AAAA;AAAA,EAIA,IAAID,GAAGC,GAAG;AACN,WAAO;AAAA,MACH,KAAK,IAAID,EAAE,CAAC,GAAGC,EAAE,CAAC,CAAC;AAAA,MACnB,KAAK,IAAID,EAAE,CAAC,GAAGC,EAAE,CAAC,CAAC;AAAA,MACnB,KAAK,IAAID,EAAE,CAAC,GAAGC,EAAE,CAAC,CAAC;AAAA,IAC/B;AAAA,EACI;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQF,GAAGM,GAAQ;AACf,UAAMC,IAAI,IAAIX,EAAQ,IAAII,GAAGM,CAAM;AACnC,WAAOV,EAAQ,SAASI,GAAGJ,EAAQ,MAAMU,GAAQC,CAAC,CAAC;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQN,GAAGC,GAAG;AACV,UAAMM,IAASZ,EAAQ,cAAcM,CAAC;AACtC,QAAIM,IAAS;AACT,aAAO,CAAC,GAAG,GAAG,CAAC;AACnB,UAAMC,IAAQb,EAAQ,IAAIK,GAAGC,CAAC,IAAIM;AAClC,WAAOZ,EAAQ,MAAMM,GAAGO,CAAK;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAIA,OAAOR,GAAGC,GAAG;AACT,WAAON,EAAQ,SAASK,GAAGL,EAAQ,QAAQK,GAAGC,CAAC,CAAC;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAIA,SAASF,GAAGU,IAAY,GAAG;AACvB,WAAO,IAAIV,EAAE,CAAC,EAAE,QAAQU,CAAS,CAAC,KAAKV,EAAE,CAAC,EAAE,QAAQU,CAAS,CAAC,KAAKV,EAAE,CAAC,EAAE,QAAQU,CAAS,CAAC;AAAA,EAC9F;AACJ,GC7JaC,IAAU;AAAA;AAAA;AAAA;AAAA,EAInB,mBAAmBL,GAAQM,GAAO;AAC9B,UAAMC,IAAIjB,EAAQ,UAAUU,CAAM,GAC5BC,IAAI,CAACX,EAAQ,IAAIiB,GAAGD,CAAK;AAC/B,WAAO,EAAE,GAAGC,EAAE,CAAC,GAAG,GAAGA,EAAE,CAAC,GAAG,GAAGA,EAAE,CAAC,GAAG,GAAAN,EAAC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAWO,GAAIC,GAAIC,GAAI;AACnB,UAAMC,IAAKrB,EAAQ,SAASmB,GAAID,CAAE,GAC5BI,IAAKtB,EAAQ,SAASoB,GAAIF,CAAE,GAC5BR,IAASV,EAAQ,UAAUA,EAAQ,MAAMqB,GAAIC,CAAE,CAAC;AACtD,WAAOP,EAAQ,mBAAmBL,GAAQQ,CAAE;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAIA,OAAOb,GAAGC,GAAGiB,GAAGZ,GAAG;AACf,WAAO,EAAE,GAAAN,GAAG,GAAAC,GAAG,GAAAiB,GAAG,GAAAZ,EAAC;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,OAAOa,GAAO;AACV,WAAO,CAACA,EAAM,GAAGA,EAAM,GAAGA,EAAM,CAAC;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAeR,GAAOQ,GAAO;AACzB,WAAOA,EAAM,IAAIR,EAAM,CAAC,IAAIQ,EAAM,IAAIR,EAAM,CAAC,IAAIQ,EAAM,IAAIR,EAAM,CAAC,IAAIQ,EAAM;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA,EAIA,SAASR,GAAOQ,GAAO;AACnB,WAAO,KAAK,IAAIT,EAAQ,eAAeC,GAAOQ,CAAK,CAAC;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA,EAIA,cAAcR,GAAOQ,GAAOf,IAAU,MAAM;AACxC,UAAMgB,IAAOV,EAAQ,eAAeC,GAAOQ,CAAK;AAChD,WAAIC,IAAOhB,IACA,UACPgB,IAAO,CAAChB,IACD,SACJ;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,eAAeO,GAAOQ,GAAOf,IAAU,MAAM;AACzC,WAAOM,EAAQ,eAAeC,GAAOQ,CAAK,IAAIf;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAIA,cAAcO,GAAOQ,GAAOf,IAAU,MAAM;AACxC,WAAOM,EAAQ,eAAeC,GAAOQ,CAAK,IAAI,CAACf;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAIA,UAAUO,GAAOQ,GAAOf,IAAU,MAAM;AACpC,WAAO,KAAK,IAAIM,EAAQ,eAAeC,GAAOQ,CAAK,CAAC,KAAKf;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAYO,GAAOQ,GAAO;AACtB,UAAMC,IAAOV,EAAQ,eAAeC,GAAOQ,CAAK,GAC1Cd,IAASK,EAAQ,OAAOS,CAAK;AACnC,WAAOxB,EAAQ,SAASgB,GAAOhB,EAAQ,MAAMU,GAAQ,IAAIe,CAAI,CAAC;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAYC,GAAeC,GAAa;AACpC,UAAMV,IAAIF,EAAQ,OAAOW,CAAa;AAEtC,QAAIR;AACJ,IAAI,KAAK,IAAID,EAAE,CAAC,CAAC,IAAI,MACjBC,IAAK,CAAC,GAAG,GAAG,CAACQ,EAAc,IAAIA,EAAc,CAAC,IAEzC,KAAK,IAAIT,EAAE,CAAC,CAAC,IAAI,MACtBC,IAAK,CAAC,GAAG,CAACQ,EAAc,IAAIA,EAAc,GAAG,CAAC,IAG9CR,IAAK,CAAC,CAACQ,EAAc,IAAIA,EAAc,GAAG,GAAG,CAAC;AAGlD,UAAME,IAAS,KAAK,IAAIX,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,GACpDY,IAAU7B,EAAQ,UAAUA,EAAQ,MAAMiB,GAAGW,CAAM,CAAC,GACpDT,IAAKnB,EAAQ,IAAIkB,GAAIW,CAAO,GAE5BC,IAAY9B,EAAQ,MAAMiB,GAAGY,CAAO,GACpCT,IAAKpB,EAAQ,IAAIkB,GAAIY,CAAS,GAE9BC,IAAMhB,EAAQ,YAAYG,GAAIS,CAAW,GACzCK,IAAMjB,EAAQ,YAAYI,GAAIQ,CAAW,GACzCM,IAAMlB,EAAQ,YAAYK,GAAIO,CAAW;AAC/C,WAAOZ,EAAQ,WAAWgB,GAAKC,GAAKC,CAAG;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAIA,KAAKT,GAAO;AACR,WAAO,EAAE,GAAG,CAACA,EAAM,GAAG,GAAG,CAACA,EAAM,GAAG,GAAG,CAACA,EAAM,GAAG,GAAG,CAACA,EAAM,EAAC;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,gBAAgBU,GAAWC,GAAcX,GAAO;AAC5C,UAAMd,IAASK,EAAQ,OAAOS,CAAK,GAC7BY,IAAQpC,EAAQ,IAAIU,GAAQyB,CAAY;AAC9C,WAAI,KAAK,IAAIC,CAAK,IAAI,QACX,OAED,EAAEpC,EAAQ,IAAIU,GAAQwB,CAAS,IAAIV,EAAM,KAAKY;AAAA,EAE5D;AAAA;AAAA;AAAA;AAAA,EAIA,qBAAqBF,GAAWC,GAAcX,GAAO;AACjD,UAAMa,IAAItB,EAAQ,gBAAgBmB,GAAWC,GAAcX,CAAK;AAChE,WAAIa,MAAM,OACC,OACJrC,EAAQ,IAAIkC,GAAWlC,EAAQ,MAAMmC,GAAcE,CAAC,CAAC;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAIA,aAAarB,GAAOQ,GAAO;AACvB,UAAMC,IAAOV,EAAQ,eAAeC,GAAOQ,CAAK,GAC1Cd,IAASK,EAAQ,OAAOS,CAAK;AACnC,WAAOxB,EAAQ,SAASgB,GAAOhB,EAAQ,MAAMU,GAAQe,CAAI,CAAC;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAIA,OAAOpB,GAAGC,GAAGG,IAAU,MAAM;AAEzB,UAAM6B,IAAajC,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE;AACnD,WAAI,KAAK,IAAIgC,IAAa,CAAC,IAAI7B,IAEpB,KAAK,IAAIJ,EAAE,IAAIC,EAAE,CAAC,IAAIG,IAE7B,KAAK,IAAI6B,IAAa,CAAC,IAAI7B,IAEpB,KAAK,IAAIJ,EAAE,IAAIC,EAAE,CAAC,IAAIG,IAE1B;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,SAASe,GAAOV,IAAY,GAAG;AAC3B,WAAO,WAAWU,EAAM,EAAE,QAAQV,CAAS,CAAC,OAAOU,EAAM,EAAE,QAAQV,CAAS,CAAC,OAAOU,EAAM,EAAE,QAAQV,CAAS,CAAC,OAAOU,EAAM,EAAE,QAAQV,CAAS,CAAC;AAAA,EACnJ;AACJ,GCtLayB,IAAY;AAAA;AAAA;AAAA;AAAA;AAAA,EAKrB,OAAOC,GAAUC,GAAY;AACzB,QAAID,EAAS,SAAS;AAClB,YAAM,IAAI,MAAM,sCAAsC;AAG1D,UAAME,IAAQF,EAAS,IAAI,CAAApC,MAAKJ,EAAQ,MAAMI,CAAC,CAAC,GAC1CoB,IAAQT,EAAQ,WAAW2B,EAAM,CAAC,GAAGA,EAAM,CAAC,GAAGA,EAAM,CAAC,CAAC;AAC7D,WAAO,EAAE,UAAUA,GAAO,OAAAlB,GAAO,YAAAiB,EAAU;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAIA,gBAAgBD,GAAUhB,GAAOiB,GAAY;AACzC,QAAID,EAAS,SAAS;AAClB,YAAM,IAAI,MAAM,sCAAsC;AAG1D,WAAO,EAAE,UADKA,EAAS,IAAI,CAAApC,MAAKJ,EAAQ,MAAMI,CAAC,CAAC,GACtB,OAAAoB,GAAO,YAAAiB,EAAU;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAIA,YAAYE,GAAM;AACd,WAAOA,EAAK,SAAS;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAIA,SAASA,GAAM;AACX,UAAMC,IAAM,CAAC,GAAG,GAAG,CAAC;AACpB,eAAWxC,KAAKuC,EAAK;AACjB,MAAAC,EAAI,CAAC,KAAKxC,EAAE,CAAC,GACbwC,EAAI,CAAC,KAAKxC,EAAE,CAAC,GACbwC,EAAI,CAAC,KAAKxC,EAAE,CAAC;AAEjB,UAAMa,IAAI0B,EAAK,SAAS;AACxB,WAAO,CAACC,EAAI,CAAC,IAAI3B,GAAG2B,EAAI,CAAC,IAAI3B,GAAG2B,EAAI,CAAC,IAAI3B,CAAC;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAIA,KAAK0B,GAAM;AACP,QAAIA,EAAK,SAAS,SAAS;AACvB,aAAO;AACX,QAAIE,IAAQ,CAAC,GAAG,GAAG,CAAC;AACpB,UAAMC,IAAKH,EAAK,SAAS,CAAC;AAC1B,aAASI,IAAI,GAAGA,IAAIJ,EAAK,SAAS,SAAS,GAAGI,KAAK;AAC/C,YAAM1B,IAAKsB,EAAK,SAASI,CAAC,GACpBzB,IAAKqB,EAAK,SAASI,IAAI,CAAC,GACxBC,IAAQhD,EAAQ,MAAMA,EAAQ,SAASqB,GAAIyB,CAAE,GAAG9C,EAAQ,SAASsB,GAAIwB,CAAE,CAAC;AAC9E,MAAAD,IAAQ7C,EAAQ,IAAI6C,GAAOG,CAAK;AAAA,IACpC;AACA,WAAO,MAAMhD,EAAQ,OAAO6C,CAAK;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAIA,OAAOF,GAAM;AACT,WAAO5B,EAAQ,OAAO4B,EAAK,KAAK;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAIA,MAAMA,GAAM;AACR,UAAMM,IAAS,CAAA;AACf,aAASF,IAAI,GAAGA,IAAIJ,EAAK,SAAS,QAAQI,KAAK;AAC3C,YAAMG,KAAQH,IAAI,KAAKJ,EAAK,SAAS;AACrC,MAAAM,EAAO,KAAK,CAACN,EAAK,SAASI,CAAC,GAAGJ,EAAK,SAASO,CAAI,CAAC,CAAC;AAAA,IACvD;AACA,WAAOD;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,SAASN,GAAMnB,GAAOf,IAAU,MAAM;AAClC,QAAI0C,IAAQ,GACRC,IAAO;AACX,eAAWhD,KAAKuC,EAAK,UAAU;AAC3B,YAAMU,IAAiBtC,EAAQ,cAAcX,GAAGoB,GAAOf,CAAO;AAC9D,MAAI4C,MAAmB,UACnBF,MACKE,MAAmB,UACxBD;AAAA,IACR;AACA,WAAID,IAAQ,KAAKC,IAAO,IACb,aACPD,IAAQ,IACD,UACPC,IAAO,IACA,SACJ;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,cAAcT,GAAM3B,GAAOP,IAAU,MAAM;AACvC,UAAMC,IAASK,EAAQ,OAAO4B,EAAK,KAAK,GAClC1B,IAAI0B,EAAK,SAAS;AACxB,aAAS,IAAI,GAAG,IAAI1B,GAAG,KAAK;AACxB,YAAMI,IAAKsB,EAAK,SAAS,CAAC,GACpBrB,IAAKqB,EAAK,UAAU,IAAI,KAAK1B,CAAC,GAC9BqC,IAAOtD,EAAQ,SAASsB,GAAID,CAAE,GAC9BkC,IAAUvD,EAAQ,SAASgB,GAAOK,CAAE,GACpC2B,IAAQhD,EAAQ,MAAMsD,GAAMC,CAAO;AAEzC,UAAIvD,EAAQ,IAAIgD,GAAOtC,CAAM,IAAI,CAACD;AAC9B,eAAO;AAAA,IAEf;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgByB,GAAWC,GAAcQ,GAAMlC,IAAU,MAAM;AAC3D,UAAM4B,IAAItB,EAAQ,gBAAgBmB,GAAWC,GAAcQ,EAAK,KAAK;AACrE,QAAIN,MAAM,QAAQA,IAAI;AAClB,aAAO;AAEX,UAAMrB,IAAQhB,EAAQ,IAAIkC,GAAWlC,EAAQ,MAAMmC,GAAcE,CAAC,CAAC;AAEnE,WAAKE,EAAU,cAAcI,GAAM3B,GAAOP,CAAO,IAG1C,EAAE,GAAA4B,GAAG,OAAArB,EAAK,IAFN;AAAA,EAGf;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY2B,GAAM;AACd,UAAMa,IAAM,CAAC,OAAU,OAAU,KAAQ,GACnCC,IAAM,CAAC,QAAW,QAAW,MAAS;AAC5C,eAAWrD,KAAKuC,EAAK;AACjB,MAAAa,EAAI,CAAC,IAAI,KAAK,IAAIA,EAAI,CAAC,GAAGpD,EAAE,CAAC,CAAC,GAC9BoD,EAAI,CAAC,IAAI,KAAK,IAAIA,EAAI,CAAC,GAAGpD,EAAE,CAAC,CAAC,GAC9BoD,EAAI,CAAC,IAAI,KAAK,IAAIA,EAAI,CAAC,GAAGpD,EAAE,CAAC,CAAC,GAC9BqD,EAAI,CAAC,IAAI,KAAK,IAAIA,EAAI,CAAC,GAAGrD,EAAE,CAAC,CAAC,GAC9BqD,EAAI,CAAC,IAAI,KAAK,IAAIA,EAAI,CAAC,GAAGrD,EAAE,CAAC,CAAC,GAC9BqD,EAAI,CAAC,IAAI,KAAK,IAAIA,EAAI,CAAC,GAAGrD,EAAE,CAAC,CAAC;AAElC,WAAO,EAAE,KAAAoD,GAAK,KAAAC,EAAG;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAIA,aAAad,GAAMe,IAAgB,OAAO;AACtC,WAAOf,EAAK,SAAS,SAAS,KAAKJ,EAAU,KAAKI,CAAI,IAAIe;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAIA,KAAKf,GAAM;AACP,UAAMgB,IAAgB,CAAC,GAAGhB,EAAK,QAAQ,EAAE,QAAO,GAC1CiB,IAAe7C,EAAQ,KAAK4B,EAAK,KAAK;AAC5C,WAAO;AAAA,MACH,UAAUgB;AAAA,MACV,OAAOC;AAAA,MACP,YAAYjB,EAAK;AAAA,IAC7B;AAAA,EACI;AAAA;AAAA;AAAA;AAAA,EAIA,MAAMA,GAAM;AACR,WAAO;AAAA,MACH,UAAUA,EAAK,SAAS,IAAI,CAAAvC,MAAKJ,EAAQ,MAAMI,CAAC,CAAC;AAAA,MACjD,OAAO,EAAE,GAAGuC,EAAK,MAAK;AAAA,MACtB,YAAYA,EAAK;AAAA,IAC7B;AAAA,EACI;AAAA;AAAA;AAAA;AAAA,EAIA,SAASA,GAAM;AACX,UAAMD,IAAQC,EAAK,SAAS,IAAI,CAAAvC,MAAKJ,EAAQ,SAASI,GAAG,CAAC,CAAC,EAAE,KAAK,IAAI;AACtE,WAAO,aAAauC,EAAK,SAAS,MAAM,eAAeD,CAAK;AAAA,EAChE;AACJ;AC9KO,SAASmB,GAAalB,GAAMnB,GAAOf,IAAU,MAAM;AACtD,QAAM4C,IAAiBd,EAAU,SAASI,GAAMnB,GAAOf,CAAO;AAE9D,MAAI4C,MAAmB,WAAWA,MAAmB;AACjD,WAAO,EAAE,OAAOV,GAAM,MAAM,KAAI;AAEpC,MAAIU,MAAmB;AACnB,WAAO,EAAE,OAAO,MAAM,MAAMV,EAAI;AAGpC,QAAMmB,IAAa,CAAA,GACbC,IAAY,CAAA,GACZ9C,IAAI0B,EAAK,SAAS;AACxB,WAASI,IAAI,GAAGA,IAAI9B,GAAG8B,KAAK;AACxB,UAAM1B,IAAKsB,EAAK,SAASI,CAAC,GACpBzB,IAAKqB,EAAK,UAAUI,IAAI,KAAK9B,CAAC,GAC9B+C,IAAKjD,EAAQ,eAAeM,GAAIG,CAAK,GACrCyC,IAAKlD,EAAQ,eAAeO,GAAIE,CAAK,GACrC0C,IAAKF,IAAKvD,IAAU,UAAUuD,IAAK,CAACvD,IAAU,SAAS,MACvD0D,IAAKF,IAAKxD,IAAU,UAAUwD,IAAK,CAACxD,IAAU,SAAS;AAc7D,QAZIyD,MAAO,UACPJ,EAAW,KAAKzC,CAAE,KAEb6C,MAAO,UAKZJ,EAAW,KAAKzC,CAAE,GAClB0C,EAAU,KAAK1C,CAAE,IAGhB6C,MAAO,WAAWC,MAAO,UAAYD,MAAO,UAAUC,MAAO,SAAU;AAExE,YAAM9B,IAAI2B,KAAMA,IAAKC,IACfG,IAAepE,EAAQ,KAAKqB,GAAIC,GAAIe,CAAC;AAE3C,MAAAyB,EAAW,KAAKM,CAAY,GAC5BL,EAAU,KAAKK,CAAY;AAAA,IAC/B;AAAA,EACJ;AAEA,QAAMjB,IAAQW,EAAW,UAAU,IAC7BvB,EAAU,gBAAgBuB,GAAYnB,EAAK,OAAOA,EAAK,UAAU,IACjE,MACAS,IAAOW,EAAU,UAAU,IAC3BxB,EAAU,gBAAgBwB,GAAWpB,EAAK,OAAOA,EAAK,UAAU,IAChE;AACN,SAAO,EAAE,OAAAQ,GAAO,MAAAC,EAAI;AACxB;AChDO,SAASiB,GAAmB1B,GAAMnB,GAAOf,IAAU,MAAM;AAC5D,QAAM6D,IAAQ3B,EAAK,UACb4B,IAAS,CAAA;AACf,MAAID,EAAM,SAAS;AACf,WAAO;AACX,WAAS,IAAI,GAAG,IAAIA,EAAM,QAAQ,KAAK;AACnC,UAAME,IAAUF,EAAM,CAAC,GACjBpB,IAAOoB,GAAO,IAAI,KAAKA,EAAM,MAAM,GACnCG,IAAW1D,EAAQ,eAAeyD,GAAShD,CAAK,GAChDkD,IAAQ3D,EAAQ,eAAemC,GAAM1B,CAAK,GAE1CmD,IAAgBF,KAAY,CAAChE,GAC7BmE,IAAaF,KAAS,CAACjE;AAM7B,QALIkE,KAEAJ,EAAO,KAAKC,CAAO,GAGlBG,KAAiB,CAACC,KAAgB,CAACD,KAAiBC,GAAa;AAElE,YAAMvC,IAAIoC,KAAYA,IAAWC,IAC3BN,IAAepE,EAAQ,KAAKwE,GAAStB,GAAM,KAAK,IAAI,GAAG,KAAK,IAAI,GAAGb,CAAC,CAAC,CAAC;AAC5E,MAAAkC,EAAO,KAAKH,CAAY;AAAA,IAC5B;AAAA,EACJ;AACA,SAAIG,EAAO,SAAS,IACT,OACJhC,EAAU,gBAAgBgC,GAAQ5B,EAAK,OAAOA,EAAK,UAAU;AACxE;AAYO,SAASkC,GAAoBlC,GAAMmC,GAAQrE,IAAU,MAAM;AAC9D,MAAI+D,IAAU7B;AACd,aAAWnB,KAASsD,GAAQ;AACxB,QAAI,CAACN;AACD,aAAO;AACX,IAAAA,IAAUH,GAAmBG,GAAShD,GAAOf,CAAO;AAAA,EACxD;AACA,SAAO+D;AACX;AAYO,SAASO,GAAmBpC,GAAMmC,GAAQrE,IAAU,MAAM;AAC7D,aAAWe,KAASsD,GAAQ;AACxB,QAAIE,IAAY;AAChB,eAAW5E,KAAKuC,EAAK;AACjB,UAAI5B,EAAQ,eAAeX,GAAGoB,CAAK,KAAK,CAACf,GAAS;AAC9C,QAAAuE,IAAY;AACZ;AAAA,MACJ;AAEJ,QAAIA;AACA,aAAO;AAAA,EAEf;AACA,SAAO;AACX;AC9EO,SAASC,GAASC,GAAU;AAC/B,MAAIA,EAAS,WAAW;AACpB,WAAO;AAEX,QAAMC,IAAUD,EAAS,IAAI,CAACE,GAASrC,OAAO;AAAA,IAC1C,SAAAqC;AAAA,IACA,YAAYrC;AAAA,EACpB,EAAM;AACF,SAAOsC,EAAkBF,CAAO;AACpC;AAIA,SAASE,EAAkBH,GAAU;AACjC,MAAIA,EAAS,WAAW;AACpB,WAAO;AAEX,QAAMI,IAAgBC,GAAeL,CAAQ,GACvCM,IAAWN,EAASI,CAAa,GACjC9D,IAAQgE,EAAS,QAAQ,OACzBC,IAAa,CAAA,GACbC,IAAY,CAAA;AAElB,WAAS3C,IAAI,GAAGA,IAAImC,EAAS,QAAQnC,KAAK;AACtC,QAAIA,MAAMuC;AACN;AACJ,UAAMH,IAAUD,EAASnC,CAAC,GACpB,EAAE,OAAAI,GAAO,MAAAC,EAAI,IAAKS,GAAasB,EAAQ,SAAS3D,CAAK;AAE3D,IAAI2B,KACAsC,EAAW,KAAK,EAAE,SAAStC,GAAO,YAAYgC,EAAQ,YAAY,GAElE/B,KACAsC,EAAU,KAAK,EAAE,SAAStC,GAAM,YAAY+B,EAAQ,YAAY;AAAA,EAExE;AACA,SAAO;AAAA,IACH,OAAA3D;AAAA,IACA,SAASgE,EAAS;AAAA,IAClB,WAAWA,EAAS;AAAA,IACpB,OAAOH,EAAkBI,CAAU;AAAA,IACnC,MAAMJ,EAAkBK,CAAS;AAAA,EACzC;AACA;AAQA,SAASH,GAAeL,GAAU;AAC9B,MAAIA,EAAS,UAAU;AACnB,WAAO;AACX,MAAIS,IAAY,GACZC,IAAY;AAEhB,QAAMC,IAAa,KAAK,IAAIX,EAAS,QAAQ,EAAE,GACzCY,IAAO,KAAK,IAAI,GAAG,KAAK,MAAMZ,EAAS,SAASW,CAAU,CAAC;AACjE,WAAS,IAAI,GAAG,IAAIX,EAAS,QAAQ,KAAKY,GAAM;AAC5C,UAAMtE,IAAQ0D,EAAS,CAAC,EAAE,QAAQ;AAClC,QAAI/B,IAAQ,GACRC,IAAO,GACP2C,IAAS;AACb,aAASC,IAAI,GAAGA,IAAId,EAAS,QAAQc,KAAK;AACtC,UAAI,MAAMA;AACN;AACJ,YAAM3C,IAAiBd,EAAU,SAAS2C,EAASc,CAAC,EAAE,SAASxE,CAAK;AACpE,MAAI6B,MAAmB,UACnBF,MAEKE,MAAmB,SACxBD,MAEKC,MAAmB,eACxBF,KACAC,KACA2C;AAAA,IAGR;AAEA,UAAME,IAAQF,IAAS,IAAI,KAAK,IAAI5C,IAAQC,CAAI;AAChD,IAAI6C,IAAQL,MACRA,IAAYK,GACZN,IAAY;AAAA,EAEpB;AACA,SAAOA;AACX;AAYO,SAASO,EAAYC,GAAQC,GAAWC,GAAMC,IAAO,GAAGC,IAAO,OAAUC,IAAW,IAAI;AAC3F,MAAI,CAACH;AACD,WAAO;AAEX,QAAMI,IAAU1F,EAAQ,eAAeoF,GAAQE,EAAK,KAAK,GACnD3F,IAASK,EAAQ,OAAOsF,EAAK,KAAK,GAClCK,IAAO1G,EAAQ,IAAIU,GAAQ0F,CAAS;AAE1C,MAAIO,GACAC;AACJ,EAAIH,KAAW,KACXE,IAAON,EAAK,OACZO,IAAMP,EAAK,SAGXM,IAAON,EAAK,MACZO,IAAMP,EAAK;AAGf,MAAIQ,IAAS;AACb,EAAI,KAAK,IAAIH,CAAI,IAAI,UACjBG,IAAS,CAACJ,IAAUC;AAExB,MAAII,IAAM;AAIV,MAAID,MAAW,QAAQA,IAASP,GAAM;AAIlC,QAFAQ,IAAMZ,EAAYC,GAAQC,GAAWO,GAAML,GAAMC,GAAMC,CAAQ,GAE3D,CAACM,KAAOT,EAAK,cAAcG,GAAU;AACrC,YAAMO,IAAUxE,EAAU,gBAAgB4D,GAAQC,GAAWC,EAAK,OAAO;AACzE,MAAIU,KAAWA,EAAQ,KAAKT,KAAQS,EAAQ,KAAKR,MAC7CO,IAAM;AAAA,QACF,GAAGC,EAAQ;AAAA,QACX,OAAOA,EAAQ;AAAA,QACf,WAAWV,EAAK;AAAA,QAChB,SAASA,EAAK;AAAA,MAClC;AAAA,IAEQ;AAEA,IAAKS,MACDA,IAAMZ,EAAYC,GAAQC,GAAWQ,GAAKN,GAAMC,GAAMC,CAAQ;AAAA,EAEtE,WACSK,IAASN,GAAM;AAIpB,QAFAO,IAAMZ,EAAYC,GAAQC,GAAWO,GAAML,GAAMC,GAAMC,CAAQ,GAE3D,CAACM,KAAOT,EAAK,cAAcG,GAAU;AACrC,YAAMO,IAAUxE,EAAU,gBAAgB4D,GAAQC,GAAWC,EAAK,OAAO;AACzE,MAAIU,KAAWA,EAAQ,KAAKT,KAAQS,EAAQ,KAAKR,MAC7CO,IAAM;AAAA,QACF,GAAGC,EAAQ;AAAA,QACX,OAAOA,EAAQ;AAAA,QACf,WAAWV,EAAK;AAAA,QAChB,SAASA,EAAK;AAAA,MAClC;AAAA,IAEQ;AAEA,IAAKS,MACDA,IAAMZ,EAAYC,GAAQC,GAAWQ,GAAKN,GAAMC,GAAMC,CAAQ;AAAA,EAEtE,OACK;AAID,QAFAM,IAAMZ,EAAYC,GAAQC,GAAWO,GAAML,GAAMO,GAAQL,CAAQ,GAE7D,CAACM,KAAOT,EAAK,cAAcG,GAAU;AACrC,YAAMO,IAAUxE,EAAU,gBAAgB4D,GAAQC,GAAWC,EAAK,OAAO;AACzE,MAAIU,KAAWA,EAAQ,KAAKT,KAAQS,EAAQ,KAAKR,MAC7CO,IAAM;AAAA,QACF,GAAGC,EAAQ;AAAA,QACX,OAAOA,EAAQ;AAAA,QACf,WAAWV,EAAK;AAAA,QAChB,SAASA,EAAK;AAAA,MAClC;AAAA,IAEQ;AAEA,IAAKS,MACDA,IAAMZ,EAAYC,GAAQC,GAAWQ,GAAKC,GAAQN,GAAMC,CAAQ;AAAA,EAExE;AACA,SAAOM;AACX;AAmBO,SAASE,EAAuBb,GAAQC,GAAWC,GAAMC,GAAMC,GAAMU,GAAW;AACnF,MAAI,CAACZ;AACD,WAAO;AAEX,QAAMI,IAAU1F,EAAQ,eAAeoF,GAAQE,EAAK,KAAK,GACnD3F,IAASK,EAAQ,OAAOsF,EAAK,KAAK,GAClCK,IAAO1G,EAAQ,IAAIU,GAAQ0F,CAAS;AAC1C,MAAIO,GACAC;AACJ,EAAIH,KAAW,KACXE,IAAON,EAAK,OACZO,IAAMP,EAAK,SAGXM,IAAON,EAAK,MACZO,IAAMP,EAAK;AAEf,MAAIQ,IAAS;AACb,EAAI,KAAK,IAAIH,CAAI,IAAI,UACjBG,IAAS,CAACJ,IAAUC;AAKxB,MAAII,IAAM;AAKV,MAAID,MAAW,QAAQA,IAASP,GAAM;AASlC,QAHAQ,IAAME,EAAuBb,GAAQC,GAAWO,GAAML,GAAMC,GAAMU,CAAS,GAGvE,CAACH,KAAO,CAACG,EAAU,IAAIZ,EAAK,SAAS,GAAG;AACxC,YAAMU,IAAUxE,EAAU,gBAAgB4D,GAAQC,GAAWC,EAAK,OAAO;AAOzE,MAAIU,KAAWA,EAAQ,KAAKT,KAAQS,EAAQ,KAAKR,MAC7CO,IAAM;AAAA,QACF,GAAGC,EAAQ;AAAA,QACX,OAAOA,EAAQ;AAAA,QACf,WAAWV,EAAK;AAAA,QAChB,SAASA,EAAK;AAAA,MAClC;AAAA,IAEQ;AAKA,IAAKS,MAEDA,IAAME,EAAuBb,GAAQC,GAAWQ,GAAKN,GAAMC,GAAMU,CAAS;AAAA,EAGlF,WACSJ,IAASN,GAAM;AASpB,QAHAO,IAAME,EAAuBb,GAAQC,GAAWO,GAAML,GAAMC,GAAMU,CAAS,GAGvE,CAACH,KAAO,CAACG,EAAU,IAAIZ,EAAK,SAAS,GAAG;AACxC,YAAMU,IAAUxE,EAAU,gBAAgB4D,GAAQC,GAAWC,EAAK,OAAO;AAOzE,MAAIU,KAAWA,EAAQ,KAAKT,KAAQS,EAAQ,KAAKR,MAC7CO,IAAM;AAAA,QACF,GAAGC,EAAQ;AAAA,QACX,OAAOA,EAAQ;AAAA,QACf,WAAWV,EAAK;AAAA,QAChB,SAASA,EAAK;AAAA,MAClC;AAAA,IAEQ;AAKA,IAAKS,MAEDA,IAAME,EAAuBb,GAAQC,GAAWQ,GAAKN,GAAMC,GAAMU,CAAS;AAAA,EAGlF,OACK;AAQD,QAFAH,IAAME,EAAuBb,GAAQC,GAAWO,GAAML,GAAMO,GAAQI,CAAS,GAEzE,CAACH,KAAO,CAACG,EAAU,IAAIZ,EAAK,SAAS,GAAG;AACxC,YAAMU,IAAUxE,EAAU,gBAAgB4D,GAAQC,GAAWC,EAAK,OAAO;AAOzE,MAAIU,KAAWA,EAAQ,KAAKT,KAAQS,EAAQ,KAAKR,MAC7CO,IAAM;AAAA,QACF,GAAGC,EAAQ;AAAA,QACX,OAAOA,EAAQ;AAAA,QACf,WAAWV,EAAK;AAAA,QAChB,SAASA,EAAK;AAAA,MAClC;AAAA,IAEQ;AAIA,IAAKS,MAEDA,IAAME,EAAuBb,GAAQC,GAAWQ,GAAKC,GAAQN,GAAMU,CAAS;AAAA,EAGpF;AAIA,SAAOH;AACX;ACrVO,SAASI,GAA4BC,GAAeC,GAAU;AACjE,QAAMtC,IAAS,CAAA,GACTuC,IAAQ9E,EAAU,MAAM6E,CAAQ,GAChCE,IAAmB/E,EAAU,SAAS6E,CAAQ;AAGpD,aAAW,CAAC/F,GAAIC,CAAE,KAAK+F,GAAO;AAG1B,QAAIE,IAAYxG,EAAQ,WAAWoG,GAAe9F,GAAIC,CAAE;AAExD,IAAIP,EAAQ,eAAeuG,GAAkBC,CAAS,IAAI,MACtDA,IAAYxG,EAAQ,KAAKwG,CAAS,IAEtCzC,EAAO,KAAKyC,CAAS;AAAA,EACzB;AAGA,MAAIC,IAAgBJ,EAAS;AAC7B,SAAIrG,EAAQ,eAAeoG,GAAeK,CAAa,IAAI,MACvDA,IAAgBzG,EAAQ,KAAKyG,CAAa,IAE9C1C,EAAO,KAAK0C,CAAa,GAClB1C;AACX;AAqEO,SAAS2C,GAAyBzG,GAAOoE,GAAS;AACrD,SAAOrE,EAAQ,YAAYC,GAAOoE,EAAQ,KAAK;AACnD;AA6BO,SAASsC,GAAsBtC,GAAS+B,GAAe;AAC1D,QAAMQ,IAAWpF,EAAU,SAAS6C,CAAO,GACrCwC,IAAW5H,EAAQ,SAASmH,GAAeQ,CAAQ,GACnDjH,IAASK,EAAQ,OAAOqE,EAAQ,KAAK;AAC3C,SAAOpF,EAAQ,IAAIU,GAAQkH,CAAQ,IAAI;AAC3C;ACzIA,MAAMC,KAAoB;AASnB,SAASC,GAAgBC,GAAgB7C,GAAU8C,GAAoB;AAE1E,QAAMC,IAAO;AAAA,IACT,IAAI;AAAA,IACJ,QAAQ;AAAA,IACR,eAAejI,EAAQ,MAAM+H,CAAc;AAAA,IAC3C,UAAU,CAAA;AAAA,EAClB;AAGI,MAAIC,KAAsB;AACtB,aAAS,IAAI,GAAG,IAAI9C,EAAS,QAAQ,KAAK;AACtC,YAAMvC,IAAOuC,EAAS,CAAC;AAEvB,UAAI,CAACwC,GAAsB/E,GAAMoF,CAAc;AAC3C;AAGJ,YAAMG,IAAUT,GAAyBM,GAAgBpF,CAAI,GAEvDwF,IAAkBjB,GAA4BgB,GAASvF,CAAI,GAC3DyF,IAAY;AAAA,QACd,IAAI;AAAA,QACJ,QAAQH;AAAA,QACR,eAAeC;AAAA,QACf,UAAU3F,EAAU,MAAMI,CAAI;AAAA,QAC9B,gBAAgBwF;AAAA,QAChB,UAAU,CAAA;AAAA,MAC1B;AACY,MAAAF,EAAK,SAAS,KAAKG,CAAS,GAExBJ,IAAqB,KACrBK,GAAkBD,GAAWlD,GAAU,GAAG8C,CAAkB;AAAA,IAEpE;AAGJ,QAAMM,IAAY,CAAA;AAClB,SAAAC,GAAiBN,GAAMK,CAAS,GACzB;AAAA,IACH,MAAAL;AAAA,IACA,WAAAK;AAAA,IACA,UAAApD;AAAA,IACA,oBAAA8C;AAAA,EACR;AACA;AAIA,SAASK,GAAkBhC,GAAMnB,GAAUsD,GAAcC,GAAU;AAC/D,MAAI,EAAAD,IAAeC,MAEf,GAACpC,EAAK,kBAAkB,CAACA,EAAK;AAElC,aAAStD,IAAI,GAAGA,IAAImC,EAAS,QAAQnC,KAAK;AAEtC,UAAIA,MAAMsD,EAAK;AACX;AACJ,YAAM1D,IAAOuC,EAASnC,CAAC;AAMvB,UAJIgC,GAAmBpC,GAAM0D,EAAK,cAAc,KAI5C,CAACqB,GAAsB/E,GAAM0D,EAAK,aAAa;AAC/C;AAGJ,YAAMqC,IAAU7D,GAAoBlC,GAAM0D,EAAK,cAAc;AAK7D,UAJI,CAACqC,KAGQnG,EAAU,KAAKmG,CAAO,IACxBb;AACP;AAEJ,YAAMK,IAAUT,GAAyBpB,EAAK,eAAe1D,CAAI,GAC3DwF,IAAkBjB,GAA4BgB,GAASQ,CAAO,GAC9DN,IAAY;AAAA,QACd,IAAIrF;AAAA,QACJ,QAAQsD;AAAA,QACR,eAAe6B;AAAA,QACf,UAAUQ;AAAA,QACV,gBAAgBP;AAAA,QAChB,UAAU,CAAA;AAAA,MACtB;AACQ,MAAA9B,EAAK,SAAS,KAAK+B,CAAS,GAExBI,IAAeC,KACfJ,GAAkBD,GAAWlD,GAAUsD,IAAe,GAAGC,CAAQ;AAAA,IAEzE;AACJ;AAIA,SAASF,GAAiBlC,GAAMpD,GAAQ;AACpC,EAAIoD,EAAK,SAAS,WAAW,KAAKA,EAAK,OAAO,MAC1CpD,EAAO,KAAKoD,CAAI;AAEpB,aAAWsC,KAAStC,EAAK;AACrB,IAAAkC,GAAiBI,GAAO1F,CAAM;AAEtC;AAmFO,SAAS2F,GAAgBC,GAAM;AAClC,EAAAC,GAAyBD,EAAK,IAAI;AACtC;AACA,SAASC,GAAyBzC,GAAM;AACpC,EAAAA,EAAK,YAAY,QACjBA,EAAK,gBAAgB;AACrB,aAAWsC,KAAStC,EAAK;AACrB,IAAAyC,GAAyBH,CAAK;AAEtC;ACjMO,SAASI,GAAgBC,GAAa3C,GAAMnB,GAAU;AACzD,MAAI,CAACmB,EAAK,YAAY,CAACA,EAAK;AACxB,WAAO;AAKX,MAAI4C,IADmB/D,EAASmB,EAAK,EAAE,EACR;AAM/B,MAJItF,EAAQ,eAAesF,EAAK,eAAe4C,CAAS,IAAI,MACxDA,IAAYlI,EAAQ,KAAKkI,CAAS,IAGlClI,EAAQ,eAAeiI,GAAaC,CAAS,IAAI;AACjD,WAAO;AAAA,MACH,OAAOA;AAAA,MACP,MAAM;AAAA,MACN,WAAWC,GAAa7C,CAAI;AAAA,IACxC;AAII,QAAM8C,IAAY9C,EAAK,eAAe,SAAS;AAC/C,WAAStD,IAAI,GAAGA,IAAIsD,EAAK,eAAe,QAAQtD,KAAK;AACjD,UAAMvB,IAAQ6E,EAAK,eAAetD,CAAC;AACnC,QAAIhC,EAAQ,eAAeiI,GAAaxH,CAAK,IAAI,GAAG;AAChD,YAAM4H,IAAOrG,IAAIoG,IAAY,SAAS;AACtC,aAAO;AAAA,QACH,OAAA3H;AAAA,QACA,MAAA4H;AAAA,QACA,WAAWF,GAAa7C,CAAI;AAAA,MAC5C;AAAA,IACQ;AAAA,EACJ;AACA,SAAO;AACX;AAIA,SAAS6C,GAAa7C,GAAM;AACxB,MAAIgD,IAAQ,GACR7E,IAAU6B;AACd,SAAO7B,KAAWA,EAAQ,OAAO;AAC7B,IAAA6E,KACA7E,IAAUA,EAAQ;AAEtB,SAAO6E;AACX;AAuCO,SAASC,GAA0BN,GAAaO,GAAW;AAC9D,SAAOxI,EAAQ,eAAeiI,GAAaO,CAAS,IAAI;AAC5D;AC9FO,MAAMC,KAAyB;AAU/B,SAASC,GAAgBnB,GAAWoB,IAAaF,IAAwB;AAC5E,QAAMG,IAAU,CAAA;AAChB,WAAS5G,IAAI,GAAGA,IAAIuF,EAAU,QAAQvF,KAAK2G;AACvC,IAAAC,EAAQ,KAAK;AAAA,MACT,IAAIA,EAAQ;AAAA,MACZ,OAAOrB,EAAU,MAAMvF,GAAG,KAAK,IAAIA,IAAI2G,GAAYpB,EAAU,MAAM,CAAC;AAAA,MACpE,YAAY;AAAA,IACxB,CAAS;AAEL,SAAOqB;AACX;AAIO,SAASC,GAAmB5I,GAAO6I,GAAY;AAElD,SADa7J,EAAQ,SAASgB,GAAO6I,EAAW,MAAM,IACxCA,EAAW;AAC7B;AAUO,SAASC,GAAgBd,GAAae,GAAQ;AACjD,SAAKA,EAAO,aAGLH,GAAmBZ,GAAae,EAAO,UAAU,IAAI,WAAW,YAF5D;AAGf;AAYO,SAASC,GAAiBhB,GAAaiB,GAAO;AACjD,MAAIC,IAAU;AACd,aAAW7D,KAAQ4D,GAAO;AACtB,QAAI,CAAC5D,EAAK;AAEN,aAAO;AAGX,UAAM5E,IAAO,KAAK,IAAIV,EAAQ,eAAeiI,GAAa3C,EAAK,SAAS,CAAC;AACzE,IAAA6D,IAAU,KAAK,IAAIA,GAASzI,CAAI;AAAA,EACpC;AAEA,SAAIyI,MAAY,SAAYA,KAAW,QAC5B,OAEJ;AAAA,IACH,QAAQlK,EAAQ,MAAMgJ,CAAW;AAAA,IACjC,QAAQkB;AAAA,EAChB;AACA;AAMO,SAASC,GAAqBJ,GAAQ;AACzC,EAAAA,EAAO,aAAa;AACxB;AAMO,SAASK,GAAsBL,GAAQ;AAC1C,aAAW1D,KAAQ0D,EAAO;AACtB,IAAA1D,EAAK,YAAY,QACjBA,EAAK,gBAAgB;AAE7B;ACtFO,MAAMgE,GAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ3B,YAAYnF,GAAU6C,GAAgBuC,IAAS,CAAA,GAAI;AAC/C,UAAM7B,IAAW6B,EAAO,sBAAsB,GACxCZ,IAAaY,EAAO,cAAcd;AACxC,SAAK,WAAWtE,GAChB,KAAK,iBAAiBlF,EAAQ,MAAM+H,CAAc,GAClD,KAAK,UAAUuC,EAAO,WAAW,MAEjC,KAAK,UAAUrF,GAASC,CAAQ,GAEhC,KAAK,WAAW4C,GAAgBC,GAAgB7C,GAAUuD,CAAQ,GAElE,KAAK,UAAUgB,GAAgB,KAAK,SAAS,WAAWC,CAAU,GAElE,KAAK,UAAU,KAAK,mBAAkB,GACtC,KAAK,QAAQ,iBAAiB,KAAK,SAAS,UAAU,QACtD,KAAK,QAAQ,eAAe,KAAK,QAAQ;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAASV,GAAa;AAClB,SAAK,aAAY;AACjB,UAAMuB,IAAa,CAAA,GAEbC,IAAa,KAAK,mBAAmBxB,CAAW;AACtD,IAAIwB,KACAD,EAAW,KAAKC,CAAU;AAG9B,UAAMC,IAAoB,KAAK,sBAAsBzB,GAAa,KAAK,SAAS,IAAI;AACpF,IAAAuB,EAAW,KAAK,GAAGE,CAAiB;AAEpC,eAAWV,KAAU,KAAK,SAAS;AAC/B,YAAMW,IAAaZ,GAAgBd,GAAae,CAAM;AACtD,UAAIW,MAAe,UAAU;AAEzB,aAAK,QAAQ;AACb;AAAA,MACJ;AACA,MAAIA,MAAe,cAEfP,GAAqBJ,CAAM,GAC3BK,GAAsBL,CAAM,IAEhC,KAAK,QAAQ;AACb,UAAIY,IAAY,IACZC,IAAoB;AACxB,iBAAWvE,KAAQ0D,EAAO,OAAO;AAE7B,YAAI1D,EAAK,aAAaiD,GAA0BN,GAAa3C,EAAK,SAAS,GAAG;AAC1E,eAAK,QAAQ;AACb;AAAA,QACJ;AAEA,QAAIA,EAAK,cACLA,EAAK,YAAY,QACjBA,EAAK,gBAAgB,QACrB,KAAK,QAAQ;AAGjB,cAAMpD,IAAS,KAAK,aAAa+F,GAAa3C,CAAI;AAClD,QAAIpD,EAAO,SAASA,EAAO,QACvBsH,EAAW,KAAKtH,EAAO,IAAI,GAC3B0H,IAAY,IACZC,IAAoB,MAEdvE,EAAK,cACXuE,IAAoB;AAAA,MAE5B;AAEA,MAAID,KAAaC,KAAqBb,EAAO,MAAM,SAAS,MACxDA,EAAO,aAAaC,GAAiBhB,GAAae,EAAO,KAAK,GAC1DA,EAAO,cACP,KAAK,QAAQ;AAAA,IAGzB;AACA,gBAAK,QAAQ,iBAAiBQ,EAAW,QAClCA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,iBAAiBvB,GAAa;AAE1B,WADoB,KAAK,SAASA,CAAW,EAC1B,IAAI,CAAA6B,MAAQC,GAAwBD,GAAM,KAAK,QAAQ,CAAC;AAAA,EAC/E;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB7B,GAAa;AAC5B,UAAM5C,IAAYpG,EAAQ,SAAS,KAAK,gBAAgBgJ,CAAW,GAC7DvH,IAAOzB,EAAQ,OAAOoG,CAAS,GAC/B2E,IAAM/K,EAAQ,UAAUoG,CAAS;AACvC,SAAK,QAAQ;AACb,UAAMU,IAAMZ,EAAY8C,GAAa+B,GAAK,KAAK,SAAS,GAAGtJ,GAAM,EAAE;AAEnE,WAAIqF,KAAOA,EAAI,IAAIrF,IAAO,KAAK,UACpB,OAEJ;AAAA,MACH,EAAE,UAAUzB,EAAQ,MAAMgJ,CAAW,GAAG,WAAW,KAAI;AAAA,MACvD,EAAE,UAAUhJ,EAAQ,MAAM,KAAK,cAAc,GAAG,WAAW,KAAI;AAAA,IAC3E;AAAA,EACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,sBAAsBgJ,GAAa3C,GAAM;AACrC,UAAM2E,IAAQ,CAAA;AAEd,eAAWrC,KAAStC,EAAK;AACrB,MAAIsC,EAAM,SAAS,SAAS,KAExBqC,EAAM,KAAK,GAAG,KAAK,sBAAsBhC,GAAaL,CAAK,CAAC;AAIpE,QAAItC,EAAK,OAAO,MAAMA,EAAK,UAAU;AACjC,YAAMwE,IAAO,KAAK,aAAa7B,GAAa3C,CAAI;AAChD,MAAIwE,KACAG,EAAM,KAAKH,CAAI;AAAA,IAEvB;AACA,WAAOG;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,aAAahC,GAAa3C,GAAM4E,IAAQ,IAAO;AAC3C,UAAMC,IAAa;AAAA,MACf,EAAE,UAAUlL,EAAQ,MAAMgJ,CAAW,GAAG,WAAW,KAAI;AAAA,IACnE,GAEcmC,IAAc,CAAA;AACpB,QAAIC,IAAW/E;AACf,WAAO+E,KAAYA,EAAS,OAAO;AAC/B,MAAAD,EAAY,QAAQC,EAAS,EAAE,GAC/BA,IAAWA,EAAS;AAExB,IAAIH,MACA,QAAQ,IAAI,oDAAoDE,EAAY,KAAK,IAAI,CAAC,GAAG,GACzF,QAAQ,IAAI,gBAAgBnC,EAAY,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAY,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAY,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GACpH,QAAQ,IAAI,sBAAsB3C,EAAK,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAK,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAK,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG;AAEnJ,QAAIgF,IAAerC,GACfsC,IAAcjF;AAGlB,UAAMY,IAAY,oBAAI,IAAG;AACzB,QAAIsE,IAAe;AAEnB,WAAOD,KAAeA,EAAY,OAAO,MAAI;AACzC,YAAM3I,IAAO,KAAK,SAAS2I,EAAY,EAAE,GACnCE,IAAcF,EAAY,eAE1BP,IAAM/K,EAAQ,UAAUA,EAAQ,SAASwL,GAAaH,CAAY,CAAC,GAEnEvE,IAAMvE,EAAU,gBAAgB8I,GAAcN,GAAKpI,CAAI;AAC7D,UAAI,CAACmE;AACD,eAAImE,KACA,QAAQ,IAAI,cAAcM,CAAY,wCAAwCD,EAAY,EAAE,EAAE,GAE3F;AAEX,MAAIL,MACA,QAAQ,IAAI,cAAcM,CAAY,eAAeF,EAAa,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAa,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAa,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GAChJ,QAAQ,IAAI,mBAAmBN,EAAI,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAI,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAI,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GAC/F,QAAQ,IAAI,mBAAmBO,EAAY,EAAE,SAASxE,EAAI,EAAE,QAAQ,CAAC,CAAC,YAAYA,EAAI,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAI,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAI,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,IAMxKG,EAAU,IAAIqE,EAAY,EAAE,GAC5B,KAAK,QAAQ;AACb,YAAMG,IAAWzE,EAAuBqE,GAAcN,GAAK,KAAK,SAAS,KAAK,SAASjE,EAAI,IAAI,KAAK,SAASG,CAAS;AACtH,UAAIwE;AACA,eAAIR,MACA,QAAQ,IAAI,2BAA2BQ,EAAS,SAAS,SAASA,EAAS,EAAE,QAAQ,CAAC,CAAC,YAAYA,EAAS,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAS,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAS,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GACpM,QAAQ,IAAI,mBAAmB,MAAM,KAAKxE,CAAS,EAAE,KAAK,IAAI,CAAC,GAAG,IAE/D;AAEX,MAAIgE,KACA,QAAQ,IAAI,sCAAsC,MAAM,KAAKhE,CAAS,EAAE,KAAK,IAAI,CAAC,IAAI,GAG1FiE,EAAW,KAAK;AAAA,QACZ,UAAUlL,EAAQ,MAAM8G,EAAI,KAAK;AAAA,QACjC,WAAWwE,EAAY;AAAA,MACvC,CAAa,GACDD,IAAevE,EAAI,OAGnBwE,IAAcA,EAAY,QAC1BC;AAAA,IACJ;AAEA,QAAID,GAAa;AACb,YAAMP,IAAM/K,EAAQ,UAAUA,EAAQ,SAASsL,EAAY,eAAeD,CAAY,CAAC,GACjF5J,IAAOzB,EAAQ,SAASsL,EAAY,eAAeD,CAAY;AACrE,UAAIJ,GAAO;AACP,gBAAQ,IAAI,+BAA+BI,EAAa,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAa,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAa,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GACtI,QAAQ,IAAI,mBAAmBC,EAAY,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAY,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAY,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GACjK,QAAQ,IAAI,mBAAmBP,EAAI,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAI,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAI,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GAC/F,QAAQ,IAAI,iBAAiBtJ,EAAK,QAAQ,CAAC,CAAC,EAAE,GAC9C,QAAQ,IAAI,aAAa,KAAK,OAAO,YAAYA,IAAO,KAAK,SAAS,QAAQ,CAAC,CAAC,EAAE,GAClF,QAAQ,IAAI,mBAAmB,MAAM,KAAKwF,CAAS,EAAE,KAAK,IAAI,CAAC,GAAG;AAGlE,cAAM/F,IAAKmK,GACLlK,IAAKmK,EAAY;AACvB,YAAKpK,EAAG,CAAC,IAAI,SAASC,EAAG,CAAC,IAAI,SAAWD,EAAG,CAAC,IAAI,SAASC,EAAG,CAAC,IAAI,OAAQ;AACtE,gBAAMkB,KAAK,QAAQnB,EAAG,CAAC,MAAMC,EAAG,CAAC,IAAID,EAAG,CAAC,IACnCwK,IAAWxK,EAAG,CAAC,IAAImB,KAAKlB,EAAG,CAAC,IAAID,EAAG,CAAC,IACpCyK,IAAWzK,EAAG,CAAC,IAAImB,KAAKlB,EAAG,CAAC,IAAID,EAAG,CAAC;AAG1C,cAFA,QAAQ,IAAI,6BAA6BmB,EAAE,QAAQ,CAAC,CAAC,OAAOqJ,EAAS,QAAQ,CAAC,CAAC,OAAOC,EAAS,QAAQ,CAAC,CAAC,EAAE,GAC3G,QAAQ,IAAI,iDAAiD,GACzDD,KAAY,SAASA,KAAY,SAASC,KAAY,KAAKA,KAAY,OAAO;AAC9E,oBAAQ,IAAI,8CAA8C,GAE1D,QAAQ,IAAI,uCAAuC;AACnD,uBAAWC,KAAU,CAAC,GAAG,CAAC,GAAG;AACzB,oBAAMjJ,IAAO,KAAK,SAASiJ,CAAM,GAC3BC,IAAUtJ,EAAU,gBAAgB8I,GAAcN,GAAKpI,CAAI;AACjE,cAAIkJ,IACA,QAAQ,IAAI,iBAAiBD,CAAM,cAAcC,EAAQ,EAAE,QAAQ,CAAC,CAAC,YAAYA,EAAQ,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAQ,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAQ,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,KAG/K,QAAQ,IAAI,iBAAiBD,CAAM,UAAU,GAE7C,QAAQ,IAAI,qBAAqBjJ,EAAK,SAAS,IAAI,CAAAvC,MAAK,IAAIA,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,YAE5I;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,WAAK,QAAQ;AAEb,YAAM0L,IAAU,KAAK,SACfC,IAAUtK,IAAO,KAAK,SACtBuK,IAAWhF,EAAuBqE,GAAcN,GAAK,KAAK,SAASe,GAASC,GAAS9E,CAAS;AACpG,UAAI+E;AACA,eAAIf,KACA,QAAQ,IAAI,2BAA2Be,EAAS,SAAS,SAASA,EAAS,EAAE,QAAQ,CAAC,CAAC,YAAYA,EAAS,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAS,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAS,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GAEjM;AAEX,MAAIf,KACA,QAAQ,IAAI,sBAAsB,GAGtCC,EAAW,KAAK;AAAA,QACZ,UAAUlL,EAAQ,MAAMsL,EAAY,aAAa;AAAA,QACjD,WAAW;AAAA,MAC3B,CAAa;AAAA,IACL;AACA,WAAOJ;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,aAAalC,GAAaiD,GAAU;AAChC,UAAMpB,IAAO,KAAK,aAAa7B,GAAaiD,CAAQ;AACpD,QAAIpB;AACA,aAAO,EAAE,OAAO,IAAM,MAAAA,EAAI;AAG9B,UAAMqB,IAAWnD,GAAgBC,GAAaiD,GAAU,KAAK,QAAQ;AACrE,WAAIC,MACAD,EAAS,YAAYC,EAAS,OAC9BD,EAAS,gBAAgBC,EAAS,OAE/B,EAAE,OAAO,IAAO,MAAM,KAAI;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa;AACT,WAAO,EAAE,GAAG,KAAK,QAAO;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,cAAclD,GAAamC,GAAa;AACpC,YAAQ,IAAI,yBAAyB,GACrC,QAAQ,IAAI,cAAcnC,EAAY,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAY,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAY,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,GAClH,QAAQ,IAAI,kBAAkBmC,EAAY,KAAK,IAAI,CAAC,GAAG,GACvD,QAAQ,IAAI,YAAY,KAAK,eAAe,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,eAAe,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,eAAe,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG;AAExI,UAAMgB,IAAW,CAAC9F,GAAMwE,GAAMxB,MAAU;AACpC,UAAIA,MAAUwB,EAAK;AACf,eAAOxE;AAEX,iBAAWsC,KAAStC,EAAK;AACrB,YAAIsC,EAAM,OAAOkC,EAAKxB,CAAK;AACvB,iBAAO8C,EAASxD,GAAOkC,GAAMxB,IAAQ,CAAC;AAG9C,aAAO;AAAA,IACX,GACM+C,IAAaD,EAAS,KAAK,SAAS,MAAMhB,GAAa,CAAC;AAC9D,QAAI,CAACiB,GAAY;AACb,cAAQ,IAAI,uDAAuD;AACnE;AAAA,IACJ;AACA,YAAQ,IAAI,yCAAyCA,EAAW,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAW,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAW,cAAc,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG;AAEpL,UAAMnJ,IAAS,KAAK,aAAa+F,GAAaoD,GAAY,EAAI;AAC9D,QAAInJ,GAAQ;AACR,cAAQ,IAAI,6BAA6B;AACzC,eAASF,IAAI,GAAGA,IAAIE,EAAO,QAAQF,KAAK;AACpC,cAAMsJ,IAAIpJ,EAAOF,CAAC;AAClB,gBAAQ,IAAI,MAAMA,CAAC,UAAUsJ,EAAE,SAAS,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAE,SAAS,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAKA,EAAE,SAAS,CAAC,EAAE,QAAQ,CAAC,CAAC,gBAAgBA,EAAE,SAAS,EAAE;AAAA,MAChJ;AAAA,IACJ;AAEI,cAAQ,IAAI,cAAc;AAE9B,YAAQ,IAAI,mBAAmB;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa;AACT,IAAAzD,GAAgB,KAAK,QAAQ;AAC7B,eAAWmB,KAAU,KAAK;AACtB,MAAAI,GAAqBJ,CAAM;AAAA,EAEnC;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB;AACf,WAAO,KAAK,SAAS,UAAU;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAIA,wBAAwB;AACpB,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAIA,oBAAoB;AAChB,WAAO/J,EAAQ,MAAM,KAAK,cAAc;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyByI,GAAU;AAC/B,UAAM6D,IAAQ,CAAA,GACRC,IAAoB9D,KAAY,KAAK,SAAS,oBAC9C+D,IAAW,CAACnG,GAAMoG,GAAOC,MAAc;AACzC,UAAID,IAAQF;AACR;AAEJ,YAAMI,IAActG,EAAK,OAAO,KAAK,CAAC,GAAGqG,GAAWrG,EAAK,EAAE,IAAIqG;AAC/D,MAAIrG,EAAK,OAAO,MAAMA,EAAK,YACvBiG,EAAM,KAAK;AAAA,QACP,eAAetM,EAAQ,MAAMqG,EAAK,aAAa;AAAA,QAC/C,kBAAkBA,EAAK,SAAS,SAAS,IAAI,CAAAjG,MAAKJ,EAAQ,MAAMI,CAAC,CAAC;AAAA,QAClE,iBAAiBqM;AAAA,QACjB,WAAWpG,EAAK;AAAA,QAChB,aAAasG;AAAA,MACjC,CAAiB;AAEL,iBAAWhE,KAAStC,EAAK;AACrB,QAAAmG,EAAS7D,GAAO8D,IAAQ,GAAGE,CAAW;AAAA,IAE9C;AACA,WAAAH,EAAS,KAAK,SAAS,MAAM,GAAG,CAAA,CAAE,GAC3BF;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,qBAAqB;AACjB,WAAO;AAAA,MACH,gBAAgB;AAAA,MAChB,cAAc;AAAA,MACd,gBAAgB;AAAA,MAChB,gBAAgB;AAAA,MAChB,oBAAoB;AAAA,MACpB,sBAAsB;AAAA,MACtB,cAAc;AAAA,MACd,iBAAiB;AAAA,MACjB,gBAAgB;AAAA,IAC5B;AAAA,EACI;AAAA;AAAA;AAAA;AAAA,EAIA,eAAe;AACX,UAAMzJ,IAAQ,KAAK,QAAQ,gBACrB8G,IAAU,KAAK,QAAQ;AAC7B,SAAK,UAAU,KAAK,mBAAkB,GACtC,KAAK,QAAQ,iBAAiB9G,GAC9B,KAAK,QAAQ,eAAe8G;AAAA,EAChC;AACJ;AAIO,SAASiD,GAAkB/B,GAAM;AACpC,MAAIgC,IAAS;AACb,WAAS9J,IAAI,GAAGA,IAAI8H,EAAK,QAAQ9H;AAC7B,IAAA8J,KAAU7M,EAAQ,SAAS6K,EAAK9H,IAAI,CAAC,EAAE,UAAU8H,EAAK9H,CAAC,EAAE,QAAQ;AAErE,SAAO8J;AACX;AAIO,SAASC,GAAmBjC,GAAMkC,IAAe,KAAK;AACzD,SAAOH,GAAkB/B,CAAI,IAAIkC;AACrC;AAIO,SAASC,GAAuBnC,GAAM;AAEzC,SAAOA,EAAK,OAAO,CAAAwB,MAAKA,EAAE,cAAc,IAAI,EAAE;AAClD;AAKA,MAAMY,KAAuB;AAK7B,SAASC,GAA0BC,GAAaC,GAAe;AAG3D,QAAMC,IAAW,KAAK,IAAIrN,EAAQ,IAAIA,EAAQ,OAAOmN,CAAW,GAAGC,CAAa,CAAC,GAE3EE,IAAa,KAAK,IAAI,IAAI,KAAK,IAAI,GAAGD,CAAQ,CAAC;AACrD,SAAO,KAAK,KAAKC,CAAU;AAC/B;AAKA,SAASC,GAAoBnI,GAAS+H,GAAa;AAC/C,QAAMzM,IAASK,EAAQ,OAAOqE,EAAQ,KAAK;AAG3C,SADYpF,EAAQ,IAAImN,GAAazM,CAAM,IACjC,IACCV,EAAQ,OAAOU,CAAM,IAEzBV,EAAQ,MAAMU,CAAM;AAC/B;AAQO,SAASoK,GAAwBD,GAAM3F,GAAU;AACpD,MAAI2F,EAAK,SAAS;AACd,UAAM,IAAI,MAAM,wDAAwD;AAE5E,QAAM2C,IAAmBxN,EAAQ,MAAM6K,EAAK,CAAC,EAAE,QAAQ,GACjD9C,IAAiB/H,EAAQ,MAAM6K,EAAKA,EAAK,SAAS,CAAC,EAAE,QAAQ,GAC7D4C,IAAc,CAAA,GACdC,IAAW,CAAA;AACjB,MAAIC,IAAqB;AAEzB,WAAS5K,IAAI,GAAGA,IAAI8H,EAAK,SAAS,GAAG9H,KAAK;AACtC,UAAM6K,IAAa/C,EAAK9H,CAAC,EAAE,UACrB8K,IAAWhD,EAAK9H,IAAI,CAAC,EAAE,UAEvB+K,IAAgB9N,EAAQ,SAAS4N,GAAYC,CAAQ;AAC3D,IAAAH,EAAS,KAAK;AAAA,MACV,YAAY1N,EAAQ,MAAM4N,CAAU;AAAA,MACpC,UAAU5N,EAAQ,MAAM6N,CAAQ;AAAA,MAChC,QAAQC;AAAA,MACR,cAAc/K;AAAA,IAC1B,CAAS;AAED,UAAMgL,IAAelD,EAAK9H,IAAI,CAAC,EAAE;AACjC,QAAIgL,MAAiB,MAAM;AACvB,YAAM3I,IAAUF,EAAS6I,CAAY,GAC/BC,IAAWnD,EAAK9H,IAAI,CAAC,EAAE,UAEvBkL,IAAoBjO,EAAQ,UAAUA,EAAQ,SAASgO,GAAUJ,CAAU,CAAC,GAE5EM,IAAYrD,EAAK9H,IAAI,CAAC,GAAG;AAC/B,UAAIoL;AACJ,MAAID,IACAC,IAAoBnO,EAAQ,UAAUA,EAAQ,SAASkO,GAAWF,CAAQ,CAAC,IAI3EG,IAAoBnO,EAAQ,QAAQiO,GAAmBlN,EAAQ,OAAOqE,EAAQ,KAAK,CAAC;AAGxF,YAAMgI,IAAgBG,GAAoBnI,GAAS6I,CAAiB,GAE9DG,IAAiBlB,GAA0Be,GAAmBb,CAAa,GAC3EiB,IAAkBD;AAExB,MAAAT,KAAsBG;AAEtB,YAAMQ,IAAY,KAAK,IAAIF,IAAiB,KAAK,KAAK,CAAC,IAAInB;AAC3D,MAAAQ,EAAY,KAAK;AAAA,QACb,SAAArI;AAAA,QACA,WAAW2I;AAAA,QACX,UAAU/N,EAAQ,MAAMgO,CAAQ;AAAA,QAChC,gBAAAI;AAAA,QACA,iBAAAC;AAAA,QACA,mBAAAJ;AAAA,QACA,mBAAAE;AAAA,QACA,eAAAf;AAAA,QACA,iBAAiBK,EAAY,SAAS;AAAA,QACtC,oBAAAE;AAAA,QACA,uBAAuBG;AAAA,QACvB,WAAAQ;AAAA,MAChB,CAAa;AAAA,IACL;AAGI,MAAAX,KAAsBG;AAAA,EAE9B;AACA,SAAO;AAAA,IACH,kBAAAN;AAAA,IACA,gBAAAzF;AAAA,IACA,iBAAiB4F;AAAA,IACjB,iBAAiBF,EAAY;AAAA,IAC7B,aAAAA;AAAA,IACA,UAAAC;AAAA,IACA,YAAY7C;AAAA,EACpB;AACA;AC3hBO,MAAM0D,GAAS;AAAA,EAClB,YAAYC,GAAU;AAClB,SAAK,WAAWxO,EAAQ,MAAMwO,CAAQ;AAAA,EAC1C;AACJ;AAkBO,MAAMC,GAAS;AAAA,EAClB,YAAYvJ,GAAUwJ,GAAQpE,GAAQ;AAClC,SAAK,SAASoE,GACd,KAAK,SAAS,IAAIrE,GAAkBnF,GAAUwJ,EAAO,UAAUpE,CAAM;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA,EAIA,SAASqE,GAAU;AACf,UAAMC,IAAM,MAAM,QAAQD,CAAQ,IAAIA,IAAWA,EAAS;AAC1D,WAAO,KAAK,OAAO,SAASC,CAAG;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,iBAAiBD,GAAU;AACvB,UAAMC,IAAM,MAAM,QAAQD,CAAQ,IAAIA,IAAWA,EAAS;AAC1D,WAAO,KAAK,OAAO,iBAAiBC,CAAG;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa;AACT,WAAO,KAAK,OAAO,WAAU;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa;AACT,SAAK,OAAO,WAAU;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB;AACf,WAAO,KAAK,OAAO,iBAAgB;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAIA,wBAAwB;AACpB,WAAO,KAAK,OAAO,sBAAqB;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAIA,yBAAyBnG,GAAU;AAC/B,WAAO,KAAK,OAAO,yBAAyBA,CAAQ;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,cAAckG,GAAUxD,GAAa;AACjC,UAAMyD,IAAM,MAAM,QAAQD,CAAQ,IAAIA,IAAWA,EAAS;AAC1D,SAAK,OAAO,cAAcC,GAAKzD,CAAW;AAAA,EAC9C;AACJ;ACvFA,SAAS0D,KAAkC;AACzC,QAAMC,IAAO,IAAIC,GAAA;AACjB,EAAAD,EAAK,UAAU,EAAE;AACjB,QAAME,IAAW,IAAIC,GAAiB;AAAA,IACpC,WAAW;AAAA,IACX,OAAO;AAAA,IACP,iBAAiB;AAAA,EAAA,CAClB;AACD,SAAO,IAAIC,EAAM,KAAKJ,GAAME,CAAQ;AACtC;AAIA,MAAMG,KAAaC,GAAO,MAAM,CAAC,WAAW,SAAS,CAAC,EAAE,KAAK,KAAK;AAIlE,SAASC,EAAc5C,GAAehE,GAA0B;AAC9D,QAAM6G,IAAY7G,IAAW,GACvB8G,IAASJ,GAAW,OAAOG,CAAS,GACpCE,IAAa,KAAK,IAAI/C,GAAO6C,IAAY,CAAC,GAC1CG,IAAQL,GAAOG,EAAOC,CAAU,CAAC;AACvC,SAAO,SAASC,EAAM,IAAA,EAAM,MAAM,CAAC,GAAG,EAAE;AAC1C;AAwEA,MAAMC,KAA4C;AAAA,EAChD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,WAAW,CAAA;AAAA,EACX,aAAa,CAAA;AAAA,EACb,oBAAoB;AAAA,EACpB,mBAAmB;AAAA,EACnB,cAAc;AAAA,EACd,eAAe,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA,EAC1B,aAAa,CAAC,KAAK,KAAK,KAAK,KAAM,KAAM,KAAM,GAAI;AAAA,EACnD,sBAAsB;AAAA,EACtB,uBAAuB;AAAA,EACvB,eAAe;AAAA,EACf,SAAS;AAAA,EACT,WAAW;AAAA,EACX,UAAU;AAAA,EACV,wBAAwB;AAAA,EACxB,uBAAuB;AAAA,EACvB,mBAAmB;AAAA,EACnB,uBAAuB;AACzB;AAEO,MAAMC,WAAwBC,GAAO;AAAA,EAC1C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEQ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA,WAA4B;AAAA,EAC5B,WAAwB,CAAA;AAAA,EACxB,4CAAmD,IAAA;AAAA,EACnD,uCAA6C,IAAA;AAAA;AAAA,EAGrD;AAAA,EACQ,aAA+B;AAAA,EAC/B,aAA8B,IAAIV,EAAM,UAAA;AAAA;AAAA,EAGhD;AAAA,EACA;AAAA,EACA;AAAA,EACQ,mBAA0C;AAAA;AAAA,EAGlD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,kBAA2B;AAAA;AAAA,EAG3B,aAA8B,CAAA;AAAA,EAC9B;AAAA,EACA,yBAAkC;AAAA;AAAA,EAGlC;AAAA;AAAA,EAGA,uBAAkD,CAAA;AAAA,EAClD,eAAgC;AAAA,EACxB,yBAAwC;AAAA;AAAA,EAGhD,cAcW;AAAA;AAAA,EAGH;AAAA;AAAA,EAEA,uCAA2F,IAAA;AAAA;AAAA,EAE3F,wBAA2C;AAAA;AAAA,EAG3C,eAAqD;AAAA,EACrD,eAAqD;AAAA;AAAA,EAGrD;AAAA,EACA;AAAA;AAAA,EAGA,iBAAuC;AAAA,EACvC,cAAsB;AAAA,EACtB,gBAAwB;AAAA,EAEhC,YAAYW,IAAgC,IAAI;AAC9C,UAAMA,CAAM;AACZ,UAAMxD,IAAI,EAAE,GAAGqD,IAAU,GAAGG,EAAA;AA2B5B,QAzBA,KAAK,OAAO,cACZ,KAAK,OAAOxD,EAAE,QAAQyD,EAAA,GACtB,KAAK,OAAOzD,EAAE,MACd,KAAK,SAASA,EAAE,QAChB,KAAK,YAAYA,EAAE,WACnB,KAAK,cAAcA,EAAE,aACrB,KAAK,qBAAqBA,EAAE,oBAC5B,KAAK,cAAcA,EAAE,aACrB,KAAK,gBAAgBA,EAAE,eACvB,KAAK,UAAUA,EAAE,SACjB,KAAK,YAAYA,EAAE,WACnB,KAAK,WAAWA,EAAE,UAClB,KAAK,yBAAyBA,EAAE,wBAChC,KAAK,wBAAwBA,EAAE,uBAC/B,KAAK,oBAAoBA,EAAE,mBAC3B,KAAK,wBAAwBA,EAAE,uBAC/B,KAAK,qBAAqBA,EAAE,mBAC5B,KAAK,gBAAgBA,EAAE,cACvB,KAAK,iBAAiBA,EAAE,cAAc,SAAS,IAAIA,EAAE,gBAAgB,MAAM,KAAK,EAAE,QAAQA,EAAE,qBAAqB,EAAA,GAAK,CAAC0D,GAAGhN,MAAMA,CAAC,GACjI,KAAK,iBAAiB,KACtB,KAAK,cAAc,MAAM,KAAK,EAAE,QAAQsJ,EAAE,qBAAqB,EAAA,GAAK,CAAC0D,GAAGhN,MAAMA,CAAC,GAC/E,KAAK,uBAAuBsJ,EAAE,wBAAwByD,EAAA,GACtD,KAAK,wBAAwBzD,EAAE,yBAAyByD,EAAA,GAGpD,CAAC,KAAK,QAAQ;AAChB,YAAME,IAAQC,GAAA;AACd,MAAID,EAAM,SAAS,MACjB,KAAK,SAASA,EAAM,CAAC,EAAE;AAAA,IAE3B;AAGA,IAAAE,EAAK,cAAc;AAAA,MACjB,MAAMC,EAAW;AAAA,MACjB,MAAM,CAAA;AAAA,MACN,MAAM;AAAA,QACJ,YAAY,CAAC,GAAG;AAAA,QAChB,WAAW,CAAC,KAAK,cAAc;AAAA,QAC/B,UAAU,KAAK;AAAA,MAAA;AAAA,MAEjB,MAAM,SAAS,KAAK,IAAI;AAAA,MACxB,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,IAAA,CAC+B,GAG5CD,EAAK,cAAc;AAAA,MACjB,MAAMC,EAAW;AAAA,MACjB,MAAM,CAAA;AAAA,MACN,MAAM;AAAA,QACJ,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,cAAc;AAAA,QACd,UAAU,KAAK,UAAU,CAAC,KAAK;AAAA,QAC/B,YAAY,KAAK,YAAY,CAAC,KAAK;AAAA,MAAA;AAAA,MAErC,MAAM,QAAQ,KAAK,IAAI;AAAA,MACvB,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,IAAA,CAC0B,GAGvC,KAAK,eAAetB,GAAA,GACpBuB,EAAS,OAAO,IAAI,KAAK,YAAY,GAGrC,KAAK,qBAAqB,IAAIlB,EAAM,MAAA,GACpC,KAAK,mBAAmB,OAAO,4BAC/BkB,EAAS,OAAO,IAAI,KAAK,kBAAkB,GAG3C,KAAK,sBAAsB,IAAIlB,EAAM,MAAA,GACrC,KAAK,oBAAoB,OAAO,mBAChCkB,EAAS,OAAO,IAAI,KAAK,mBAAmB;AAAA,EAC9C;AAAA,EAEA,IAAI,cAAsB;AACxB,WAAO,KAAK,MAAM,eAAe;AAAA,EACnC;AAAA,EAEA,IAAI,IAAY;AACd,WAAOC,GAAc,KAAK,WAAW;AAAA,EACvC;AAAA,EAEA,OAA4B;AAC1B,WAAO;AAAA,MACL,GAAGC,GAAU;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA,GACC,IAAI;AAAA,MACP,mBAAmB,KAAK;AAAA,MACxB,cAAc,KAAK;AAAA,MACnB,eAAe,KAAK;AAAA,IAAA;AAAA,EAExB;AAAA,EAEA,QAAQC,GAAkC;AACxC,gBAAK,OAAOA,EAAM,MAClB,KAAK,OAAOA,EAAM,MAClB,KAAK,gBAAgBA,EAAM,iBAAiB,IAC5C,KAAK,SAASA,EAAM,QACpB,KAAK,YAAYA,EAAM,WACvB,KAAK,cAAcA,EAAM,aACzB,KAAK,qBAAqBA,EAAM,oBAChC,KAAK,qBAAqBA,EAAM,qBAAqB,QACrD,KAAK,gBAAgBA,EAAM,gBAAgB,IAC3C,KAAK,iBAAiBA,EAAM,iBAAiB,MAAM,KAAK,EAAE,QAAQ,KAAK,qBAAqB,EAAA,GAAK,CAACR,GAAGhN,MAAMA,CAAC,GAC5G,KAAK,cAAcwN,EAAM,aACzB,KAAK,uBAAuBA,EAAM,wBAAwBT,EAAA,GAC1D,KAAK,wBAAwBS,EAAM,yBAAyBT,EAAA,GAC5D,KAAK,gBAAgBS,EAAM,iBAAiB,MAC5C,KAAK,UAAUA,EAAM,WAAW,GAChC,KAAK,YAAYA,EAAM,aAAa,GACpC,KAAK,WAAWA,EAAM,YAAY,GAClC,KAAK,yBAAyBA,EAAM,0BAA0B,IAC9D,KAAK,wBAAwBA,EAAM,yBAAyB,IAC5D,KAAK,oBAAoBA,EAAM,qBAAqB,GACpD,KAAK,wBAAwBA,EAAM,yBAAyB,MACrD;AAAA,EACT;AAAA,EAEA,UAAU;AACR,SAAK,mBAAA,GACL,KAAK,mBAAA,GACLH,EAAS,OAAO,OAAO,KAAK,YAAY,GACxCA,EAAS,OAAO,OAAO,KAAK,kBAAkB,GAC9CA,EAAS,OAAO,OAAO,KAAK,mBAAmB,GAC/CF,EAAK,iBAAiB,KAAK,oBAAoB,GAC/CA,EAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EAEQ,oBAAoB;AAE1B,SAAK,mBAAA;AAEL,UAAMM,IAASJ,EAAS,SAAS,YAG3BK,IAAc,CAACC,MAAqC;AACxD,YAAMC,IAAOH,EAAO,sBAAA;AACpB,aAAO,IAAItB,EAAM;AAAA,SACbwB,EAAM,UAAUC,EAAK,QAAQA,EAAK,QAAS,IAAI;AAAA,QACjD,GAAGD,EAAM,UAAUC,EAAK,OAAOA,EAAK,UAAU,IAAI;AAAA,MAAA;AAAA,IAEtD;AAGA,SAAK,eAAe,CAACD,MAAsB;AACzC,UAAI,KAAK,iBAAiB,SAAS,GAAG;AACpC,QAAAF,EAAO,MAAM,SAAS;AACtB;AAAA,MACF;AAEA,YAAMI,IAAQH,EAAYC,CAAK,GACzBG,IAAY,IAAI3B,EAAM,UAAA;AAC5B,MAAA2B,EAAU,cAAcD,GAAOR,EAAS,MAAM;AAE9C,YAAMU,IAAsB,MAAM,KAAK,KAAK,iBAAiB,MAAM;AAGnE,MAFmBD,EAAU,iBAAiBC,CAAmB,EAElD,SAAS,IACtBN,EAAO,MAAM,SAAS,YAEtBA,EAAO,MAAM,SAAS;AAAA,IAE1B,GAGA,KAAK,eAAe,CAACE,MAAsB;AAGzC,UADIA,EAAM,WAAW,KACjB,KAAK,iBAAiB,SAAS,EAAG;AAEtC,YAAME,IAAQH,EAAYC,CAAK,GACzBG,IAAY,IAAI3B,EAAM,UAAA;AAC5B,MAAA2B,EAAU,cAAcD,GAAOR,EAAS,MAAM;AAE9C,YAAMU,IAAsB,MAAM,KAAK,KAAK,iBAAiB,MAAM,GAC7DC,IAAaF,EAAU,iBAAiBC,CAAmB;AAEjE,UAAIC,EAAW,SAAS,GAAG;AACzB,cAAMC,IAAcD,EAAW,CAAC,EAAE,QAC5BE,IAAO,KAAK,iBAAiB,IAAID,CAAW;AAElD,QAAIC,MAEE,KAAK,0BAA0BD,KACjC,KAAK,wBAAwB,MAC7B,KAAK,mBAAA,MAEL,KAAK,wBAAwBA,GAC7B,KAAK,2BAA2BC,CAAI;AAAA,MAG1C;AAAA,IACF,GAEAT,EAAO,iBAAiB,SAAS,KAAK,YAAY,GAClDA,EAAO,iBAAiB,aAAa,KAAK,YAAY;AAAA,EACxD;AAAA;AAAA;AAAA,EAIQ,2BAA2BS,GAAyD;AAEzF,SAAK,aAAa,SAAsB,UAAU,CAAA,CAAE,GACrD,KAAK,mBAAA;AAEL,UAAMC,IAAW7B,EAAc4B,EAAK,iBAAiB,KAAK,kBAAkB,GACtEE,IAAK,IAAIjC,EAAM,QAAQ+B,EAAK,cAAc,CAAC,GAAGA,EAAK,cAAc,CAAC,GAAGA,EAAK,cAAc,CAAC,CAAC;AAGhG,QAAI,KAAK,YAAY,WAAW,EAAG;AACnC,UAAMG,IAAWC,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC;AACvE,QAAI,CAACD,EAAU;AACf,UAAME,IAAcF,EAAS,SAAS,MAAA,GAGhCG,IAAiB,IAAIrC,EAAM,mBAAmB;AAAA,MAClD,OAAOgC;AAAA,MACP,aAAa;AAAA,MACb,SAAS;AAAA,MACT,UAAU;AAAA,MACV,SAAS;AAAA,IAAA,CACV,GACKM,IAAmB,IAAItC,EAAM,eAAA,EAAiB,cAAc,CAACiC,GAAIG,CAAW,CAAC,GAC7EG,IAAe,IAAIvC,EAAM,KAAKsC,GAAkBD,CAAc;AACpE,IAAAE,EAAa,qBAAA,GACb,KAAK,mBAAmB,IAAIA,CAAY;AAGxC,UAAMC,IAAgB,IAAIxC,EAAM,eAAe,MAAM,IAAI,EAAE,GACrDyC,IAAe,IAAIzC,EAAM,kBAAkB;AAAA,MAC/C,OAAOgC;AAAA,MACP,aAAa;AAAA,MACb,SAAS;AAAA,IAAA,CACV,GACKU,IAAgB,IAAI1C,EAAM,KAAKwC,GAAeC,CAAY;AAChE,IAAAC,EAAc,SAAS,KAAKT,CAAE,GAC9B,KAAK,mBAAmB,IAAIS,CAAa;AAGzC,UAAMzG,IAAc8F,EAAK;AACzB,QAAI,CAAC9F,KAAeA,EAAY,WAAW,EAAG;AAE9C,UAAM0G,IAAcZ,EAAK;AAEzB,eAAWpG,KAAQ,KAAK,YAAY;AAGlC,YAAMiH,IAAYjH,EAAK;AAEvB,UAAIiH,MAAcD,EAAa;AAM/B,UAAIE,IAAU;AACd,eAAShP,IAAI,GAAGA,IAAIoI,EAAY,QAAQpI,KAAK;AAC3C,cAAMiP,IAAYF,IAAY/O;AAE9B,YADsB8H,EAAK,WAAWmH,CAAS,MACzB7G,EAAYpI,CAAC,GAAG;AACpC,UAAAgP,IAAU;AACV;AAAA,QACF;AAAA,MACF;AAEA,UAAIA,GAAS;AAEX,cAAME,IAASpH,EAAK,QACdqH,IAAiBrH,EAAK;AAE5B,iBAAS9H,IAAI,GAAGA,IAAIkP,EAAO,SAAS,GAAGlP,KAAK;AAC1C,gBAAMoP,IAAQF,EAAOlP,CAAC,GAChBqP,IAAMH,EAAOlP,IAAI,CAAC,GAClBsP,IAASF,EAAM,WAAWC,CAAG,GAC7BE,IAAW,IAAIpD,EAAM,QAAA,EAAU,WAAWiD,GAAOC,CAAG,EAAE,eAAe,GAAG,GAGxEG,IAAeL,IAAiBnP,GAChCyP,IAAYD,MAAiB,IAAK,WAAWlD,EAAckD,GAAc,KAAK,kBAAkB,GAEhGE,IAAU,IAAIvD,EAAM,iBAAiB,OAAO,OAAOmD,GAAQ,CAAC,GAC5DK,IAAS,IAAIxD,EAAM,kBAAkB,EAAE,OAAOsD,GAAU,GACxDG,IAAM,IAAIzD,EAAM,KAAKuD,GAASC,CAAM;AAE1C,UAAAC,EAAI,SAAS,KAAKL,CAAQ;AAC1B,gBAAMlM,IAAY,IAAI8I,EAAM,QAAA,EAAU,WAAWkD,GAAKD,CAAK,EAAE,UAAA,GACvDS,IAAa,IAAI1D,EAAM,WAAA;AAC7B,UAAA0D,EAAW,mBAAmB,IAAI1D,EAAM,QAAQ,GAAG,GAAG,CAAC,GAAG9I,CAAS,GACnEuM,EAAI,0BAA0BC,CAAU,GAExC,KAAK,mBAAmB,IAAID,CAAG;AAAA,QACjC;AAGA,iBAAS5P,IAAI,GAAGA,IAAI8H,EAAK,OAAO,SAAS,GAAG9H,KAAK;AAC/C,gBAAM8P,IAAaX,IAAiBnP,IAAI,GAClC+P,IAAazD,EAAcwD,GAAY,KAAK,kBAAkB,GAE9DE,IAAY,IAAI7D,EAAM,eAAe,MAAM,IAAI,EAAE,GACjD8D,IAAW,IAAI9D,EAAM,kBAAkB,EAAE,OAAO4D,GAAY,GAC5DG,IAAY,IAAI/D,EAAM,KAAK6D,GAAWC,CAAQ;AACpD,UAAAC,EAAU,SAAS,KAAKpI,EAAK,OAAO9H,CAAC,CAAC,GACtC,KAAK,mBAAmB,IAAIkQ,CAAS;AAAA,QACvC;AAEA,QAAA7C,EAAS,gBAAgB;AACzB;AAAA,MACF;AAAA,IACF;AAEA,IAAAA,EAAS,gBAAgB;AAAA,EAC3B;AAAA,EAEQ,qBAAqB;AAC3B,UAAMI,IAASJ,EAAS,SAAS;AACjC,IAAI,KAAK,iBACPI,EAAO,oBAAoB,SAAS,KAAK,YAAY,GACrD,KAAK,eAAe,OAElB,KAAK,iBACPA,EAAO,oBAAoB,aAAa,KAAK,YAAY,GACzD,KAAK,eAAe,MACpBA,EAAO,MAAM,SAAS;AAAA,EAE1B;AAAA;AAAA,EAGQ,kBAA+B;AACrC,UAAM0C,IAAO,KAAK;AAClB,QAAI,CAACA,EAAM,QAAO,CAAA;AAElB,UAAMhO,IAAwB,CAAA;AAC9B,gBAAK,sBAAsB,MAAA,GAC3B,KAAK,iBAAiB,MAAA,GAEtBgO,EAAK,YAAY,QAAQ,CAACC,MAAqB;AAC7C,YAAMC,IAAkB,KAAK,kBAAkBD,CAAO,GAChDE,IAAanO,EAAS;AAE5B,MAAAkO,EAAgB,QAAQ,CAACzQ,GAAMI,MAAM;AACnC,aAAK,iBAAiB,IAAIsQ,IAAatQ,GAAGoQ,CAAO,GACjDjO,EAAS,KAAKvC,CAAI;AAAA,MACpB,CAAC,GAED,KAAK,sBAAsB;AAAA,QACzBwQ,EAAQ;AAAA,QACRC,EAAgB,IAAI,CAACrD,GAAGhN,MAAMsQ,IAAatQ,CAAC;AAAA,MAAA;AAAA,IAEhD,CAAC,GAEMmC;AAAA,EACT;AAAA;AAAA,EAGQ,kBAAkBiO,GAA+B;AACvD,UAAMjO,IAAwB,CAAA,GACxBoO,IAAWH,EAAQ,UACnBI,IAAUD,EAAS,aAAa,UAAU;AAEhD,QAAI,CAACC,EAAS,QAAOrO;AAGrB,IAAAiO,EAAQ,kBAAkB,EAAI;AAC9B,UAAMK,IAAcL,EAAQ,aAGtBM,IAAUH,EAAS,SAAA,GACnBI,IAAYH,EAAQ,OAEpBI,IAAkB,CAACC,GAAYC,GAAYC,MAAe;AAC9D,YAAMhR,IAAK,IAAIoM,EAAM;AAAA,QACnBwE,EAAUE,IAAK,CAAC;AAAA,QAChBF,EAAUE,IAAK,IAAI,CAAC;AAAA,QACpBF,EAAUE,IAAK,IAAI,CAAC;AAAA,MAAA,EACpB,aAAaJ,CAAW,GAEpBnS,IAAK,IAAI6N,EAAM;AAAA,QACnBwE,EAAUG,IAAK,CAAC;AAAA,QAChBH,EAAUG,IAAK,IAAI,CAAC;AAAA,QACpBH,EAAUG,IAAK,IAAI,CAAC;AAAA,MAAA,EACpB,aAAaL,CAAW,GAEpBlS,IAAK,IAAI4N,EAAM;AAAA,QACnBwE,EAAUI,IAAK,CAAC;AAAA,QAChBJ,EAAUI,IAAK,IAAI,CAAC;AAAA,QACpBJ,EAAUI,IAAK,IAAI,CAAC;AAAA,MAAA,EACpB,aAAaN,CAAW,GAEpBhR,IAAyB;AAAA,QAC7B,CAACM,EAAG,GAAGA,EAAG,GAAGA,EAAG,CAAC;AAAA,QACjB,CAACzB,EAAG,GAAGA,EAAG,GAAGA,EAAG,CAAC;AAAA,QACjB,CAACC,EAAG,GAAGA,EAAG,GAAGA,EAAG,CAAC;AAAA,MAAA,GAGb8D,IAAU7C,EAAU,OAAOC,CAAQ;AACzC,MAAA0C,EAAS,KAAKE,CAAO;AAAA,IACvB;AAEA,QAAIqO,GAAS;AACX,YAAMM,IAAaN,EAAQ;AAC3B,eAAS1Q,IAAI,GAAGA,IAAIgR,EAAW,QAAQhR,KAAK;AAC1C,QAAA4Q,EAAgBI,EAAWhR,CAAC,GAAGgR,EAAWhR,IAAI,CAAC,GAAGgR,EAAWhR,IAAI,CAAC,CAAC;AAAA,IAEvE,OAAO;AAEL,YAAMiR,IAAcT,EAAQ;AAC5B,eAASxQ,IAAI,GAAGA,IAAIiR,GAAajR,KAAK;AACpC,QAAA4Q,EAAgB5Q,GAAGA,IAAI,GAAGA,IAAI,CAAC;AAAA,IAEnC;AAEA,WAAOmC;AAAA,EACT;AAAA;AAAA,EAGQ,uBAAgC;AAItC,QAHI,CAAC,KAAK,YACN,KAAK,gBAAgB,KAAK,UAC1B,KAAK,kBAAkB,KAAK,sBAC5B,KAAK,UAAU,WAAW,EAAG,QAAO;AAExC,UAAMwJ,IAAS2C,EAAa,SAAA,EAAW,WAAW,KAAK,UAAU,CAAC,CAAC;AAEnE,WADI,CAAC3C,KACD,CAAC,KAAK,kBAAkB,CAAC,KAAK,eAAe,OAAOA,EAAO,QAAQ;AAAA,EAGzE;AAAA;AAAA,EAGA,cAAc;AACZ,QAAI,KAAK,UAAU,WAAW,GAAG;AAC/B,cAAQ,KAAK,qCAAqC;AAClD;AAAA,IACF;AAEA,UAAMA,IAAS2C,EAAa,SAAA,EAAW,WAAW,KAAK,UAAU,CAAC,CAAC;AACnE,QAAI,CAAC3C,GAAQ;AACX,cAAQ,KAAK,mCAAmC;AAChD;AAAA,IACF;AAIA,QADA,KAAK,WAAW,KAAK,gBAAA,GACjB,KAAK,SAAS,WAAW,GAAG;AAC9B,cAAQ,KAAK,kDAAkD;AAC/D;AAAA,IACF;AAGA,UAAMuF,IAAwB;AAAA,MAC5BvF,EAAO,SAAS;AAAA,MAChBA,EAAO,SAAS;AAAA,MAChBA,EAAO,SAAS;AAAA,IAAA,GAEZwF,IAAW,IAAI3F,GAAS0F,CAAS;AAGvC,SAAK,WAAW,IAAIxF,GAAS,KAAK,UAAUyF,GAAU;AAAA,MACpD,oBAAoB,KAAK;AAAA,IAAA,CAC1B,GAGD,KAAK,iBAAiBxF,EAAO,SAAS,MAAA,GACtC,KAAK,cAAc,KAAK,QACxB,KAAK,gBAAgB,KAAK,oBAE1B,QAAQ,IAAI,+BAA+B,KAAK,SAAS,MAAM,wBAAwB,KAAK,kBAAkB,EAAE;AAAA,EAClH;AAAA;AAAA,EAGA,YAAY;AACV,QAAI,KAAK,UAAU,WAAW,KAAK,KAAK,YAAY,WAAW,GAAG;AAChE,cAAQ,KAAK,4DAA4D;AACzE;AAAA,IACF;AAaA,QATqB,KAAK,qBAAA,IAExB,KAAK,YAAA,IACI,KAAK,aAEd,KAAK,SAAS,WAAA,GACd,QAAQ,IAAI,2DAA2D,IAGrE,CAAC,KAAK,UAAU;AAClB,cAAQ,KAAK,mCAAmC;AAChD;AAAA,IACF;AA0CA,YAxCA,KAAK,aAAa,CAAA,GAClB,KAAK,mBAAA,GAGL,KAAK,YAAY,QAAQ,CAAAyF,MAAc;AACrC,YAAM/C,IAAWC,EAAa,SAAA,EAAW,WAAW8C,CAAU;AAC9D,UAAI,CAAC/C,EAAU;AAEf,YAAMpI,IAA0B;AAAA,QAC9BoI,EAAS,SAAS;AAAA,QAClBA,EAAS,SAAS;AAAA,QAClBA,EAAS,SAAS;AAAA,MAAA,GAGdpG,IAAQ,KAAK,SAAU,SAAShC,CAAW;AACjD,WAAK,cAAc,KAAK,SAAU,WAAA;AAClC,YAAMoL,IAAgB,KAAK,SAAU,iBAAiBpL,CAAW;AAGjE,MAAAgC,EAAM,QAAQ,CAACH,GAAM9H,MAAM;AACzB,cAAMsR,IAAWtR,IAAIqR,EAAc,SAASA,EAAcrR,CAAC,IAAI,QACzDuR,IAAS,KAAK,YAAYzJ,GAAMwJ,CAAQ;AAC9C,aAAK,WAAW,KAAKC,CAAM;AAAA,MAC7B,CAAC;AAAA,IACH,CAAC,GAGG,KAAK,0BAA0B,KAAK,QACtC,KAAK,yBAAA,GAIP,KAAK,WAAW,KAAK,CAACjU,GAAGC,MAAMD,EAAE,cAAcC,EAAE,WAAW,GAGxD,KAAK,yBAAyB,KAAK,WAAW,SAAS,KACzD,KAAK,sBAAA,GAIC,KAAK,oBAAA;AAAA,MACX,KAAK;AACH,aAAK,UAAA;AACL;AAAA,MACF,KAAK;AACH,aAAK,UAAA;AACL;AAAA,MACF,KAAK;AACH,aAAK,UAAA,GACL,KAAK,UAAA;AACL;AAAA,IAAA;AAIJ,SAAK,aAAA,GAGL,KAAK,6BAAA,GAEL,QAAQ,IAAI,0BAA0B,KAAK,WAAW,MAAM,cAAc,GACtE,KAAK,gBACP,QAAQ,IAAI,eAAe,KAAK,YAAY,YAAY,EAAE,GAC1D,QAAQ,IAAI,iBAAiB,KAAK,YAAY,kBAAkB,EAAE,GAClE,QAAQ,IAAI,sBAAsB,KAAK,YAAY,cAAc,EAAE,IAGrE8P,EAAS,gBAAgB;AAAA,EAC3B;AAAA;AAAA,EAGQ,YAAYvF,GAAwBwJ,GAAoD;AAC9F,UAAMpC,IAASpH,EAAK,IAAI,OAAK,IAAIqE,EAAM,QAAQ7C,EAAE,SAAS,CAAC,GAAGA,EAAE,SAAS,CAAC,GAAGA,EAAE,SAAS,CAAC,CAAC,CAAC,GACrFQ,IAASD,GAAkB/B,CAAI,GAC/B0J,IAAczH,GAAmBjC,GAAM,KAAK,CAAC,GAC7C4B,IAAQO,GAAuBnC,CAAI,GACnC2J,IAAa3J,EAAK,IAAI,CAAAwB,MAAKA,EAAE,SAAS;AAI5C,QAAIoI;AACJ,IAAIxC,EAAO,UAAU,IACnBwC,IAAmB,IAAIvF,EAAM,QAAA,EAC1B,WAAW+C,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC,EAC/B,UAAA,EACA,OAAA,IAGHwC,IAAmB,IAAIvF,EAAM,QAAQ,GAAG,GAAG,CAAC;AAI9C,UAAMzB,IAAc4G,GAAU,YAAY,IAAI,CAAAK,OAAM;AAAA,MAClD,WAAWA,EAAE;AAAA,MACb,UAAU,IAAIxF,EAAM,QAAQwF,EAAE,SAAS,CAAC,GAAGA,EAAE,SAAS,CAAC,GAAGA,EAAE,SAAS,CAAC,CAAC;AAAA,MACvE,gBAAgBA,EAAE;AAAA,MAClB,eAAe,IAAIxF,EAAM,QAAQwF,EAAE,cAAc,CAAC,GAAGA,EAAE,cAAc,CAAC,GAAGA,EAAE,cAAc,CAAC,CAAC;AAAA,MAC3F,WAAWA,EAAE;AAAA,IAAA,EACb;AAEF,WAAO,EAAE,QAAAzC,GAAQ,OAAAxF,GAAO,QAAAI,GAAQ,aAAA0H,GAAa,YAAAC,GAAY,kBAAAC,GAAkB,aAAAhH,EAAA;AAAA,EAC7E;AAAA;AAAA,EAGA,eAAe;AACb,QAAI,KAAK,WAAW,WAAW,EAAG;AAGlC,UAAMkH,IAAc,CAAC,GAAG,KAAK,UAAU,EAAE,KAAK,CAACtU,GAAGC,MAAMD,EAAE,cAAcC,EAAE,WAAW,GAG/EsU,IAAuB,EAAE,GAAGC,EAAU,WAAW,QAAQ,KAAK,oBAAoB,EAAA;AACxF,IAAAD,EAAqB,OAAO,CAAA,GAC5BA,EAAqB,OAAO;AAAA,MAC1B,GAAGA,EAAqB;AAAA,MACxB,UAAU,KAAK;AAAA,MACf,WAAW,CAAC,KAAK,cAAc;AAAA,IAAA;AAIjC,UAAME,IAAY,KAAK,YAAY,SAAS,IACxCzD,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC,IACtD;AAEJ,aAAStO,IAAI,GAAGA,IAAI4R,EAAY,QAAQ5R,KAAK;AAC3C,YAAM8H,IAAO8J,EAAY5R,CAAC,GACpBgI,IAAMF,EAAK,kBACXkK,IAAUD,IAAYA,EAAU,QAAQ,CAAC/J,EAAI,GAAGA,EAAI,GAAGA,EAAI,CAAC,CAAC,IAAI,GACjEiK,IAAW,KAAK,yBAAyBJ,EAAqB,KAAK,YAAY/J,GAAMkK,CAAO,GAC5FE,IAAaC,EAAQF,CAAQ;AAEnC,MAAAJ,EAAqB,KAAK,KAAK;AAAA,QAC7B,MAAM/J,EAAK;AAAA,QACX,UAAUoK;AAAA,QACV,SAASlS,IAAI;AAAA,QACb,OAAO8H,EAAK;AAAA,QACZ,MAAM,GAAG,KAAK,IAAI,SAAS9H,CAAC;AAAA,MAAA,CAC7B;AAAA,IACH;AAEA,IAAAmN,EAAK,iBAAiB,EAAE,MAAM,KAAK,sBAAsB,QAAQ0E,GAAsB;AAAA,EACzF;AAAA;AAAA,EAGA,gCAAgC;AAC9B,UAAMA,IAAuB,EAAE,GAAGC,EAAU,WAAW,QAAQ,KAAK,oBAAoB,EAAA;AACxF,IAAAD,EAAqB,OAAO,CAAA,GAC5B1E,EAAK,iBAAiB,EAAE,MAAM,KAAK,sBAAsB,QAAQ0E,GAAsB;AAAA,EACzF;AAAA;AAAA,EAGA,IAAI,cAAcO,GAAW;AAC3B,SAAK,iBAAiBA,GACtB,KAAK,aAAA;AAAA,EACP;AAAA,EAEA,IAAI,gBAAwB;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAGA,IAAI,aAAuB;AACzB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,WAAWC,GAAkB;AAC/B,SAAK,cAAcA;AAAA,EAGrB;AAAA;AAAA;AAAA,EAIA,uBAAuBC,GAAkB;AAEvC,UAAMC,IAAQD,EAAS,MAAM,cAAc;AAC3C,QAAI,CAACC,GAAO;AACV,cAAQ,KAAK,8CAA8CD,CAAQ;AACnE;AAAA,IACF;AAEA,UAAMrD,IAAY,SAASsD,EAAM,CAAC,GAAG,EAAE;AACvC,SAAK,qBAAqBtD,CAAS;AAAA,EACrC;AAAA;AAAA,EAGQ,qBAAqB;AAE3B,IAAA5B,EAAS,OAAO,WAAA,GAChBA,EAAS,OAAO,YAAA,GAEhB,KAAK,oBAAA,GACL,KAAK,iBAAiB,MAAA,GACtB,KAAK,wBAAwB;AAAA,EAC/B;AAAA,EAEQ,YAAY;AAIlB,UAAMmF,IAAgB,KAAK,WAAW,OAAO,CAAA1K,MAAQ,KAAK,eAAe,SAASA,EAAK,KAAK,CAAC;AAE7F,IAAA0K,EAAc,QAAQ,CAAA1K,MAAQ;AAC5B,YAAMqG,IAAW7B,EAAcxE,EAAK,OAAO,KAAK,kBAAkB,GAE5D6J,KAAMxD,KAAY,KAAM,OAAQ,KAChCsE,KAAMtE,KAAY,IAAK,OAAQ,KAC/B5Q,KAAK4Q,IAAW,OAAQ,KACxBzB,IAAkC,CAACiF,GAAGc,GAAGlV,CAAC;AAGhD,eAASyC,IAAI,GAAGA,IAAI8H,EAAK,OAAO,SAAS,GAAG9H,KAAK;AAC/C,cAAM7B,IAAK2J,EAAK,OAAO9H,CAAC,GAClB5B,IAAK0J,EAAK,OAAO9H,IAAI,CAAC;AAC5B,QAAAqN,EAAS,OAAO;AAAA,UACd,CAAClP,EAAG,GAAGA,EAAG,GAAGA,EAAG,CAAC;AAAA,UACjB,CAACC,EAAG,GAAGA,EAAG,GAAGA,EAAG,CAAC;AAAA,UACjBsO;AAAA,UACAA;AAAA,QAAA;AAAA,MAEJ;AAAA,IACF,CAAC,GAGD8F,EAAc,QAAQ,CAAA1K,MAAQ;AAC5B,UAAIA,EAAK,cAAcA,EAAK,OAAO,WAAW,GAAG;AAC/C,cAAM4K,IAAS5K,EAAK,OAAO,CAAC,GACtBqG,IAAW7B,EAAcxE,EAAK,OAAO,KAAK,kBAAkB,GAC5D6K,IAAO,IAAIxG,EAAM,eAAe,MAAM,GAAG,CAAC,GAC1CyG,IAAM,IAAIzG,EAAM,kBAAkB,EAAE,OAAOgC,GAAU,GACrD0E,IAAS,IAAI1G,EAAM,KAAKwG,GAAMC,CAAG;AACvC,QAAAC,EAAO,SAAS,KAAKH,CAAM,GAC3B,KAAK,oBAAoB,IAAIG,CAAM;AAAA,MACrC;AAAA,IACF,CAAC;AAGD,UAAMC,IAAazF,EAAS,OAAO,cAAA;AACnC,IAAI,KAAK,gBACP,KAAK,YAAY,cAAcyF,IAI7BA,EAAW,kBACb,QAAQ,MAAM,mCAAmCA,EAAW,SAAS,IAAIA,EAAW,aAAa,4BAA4B,IACpHA,EAAW,eAAe,MACnC,QAAQ,KAAK,4BAA4BA,EAAW,aAAa,QAAQ,CAAC,CAAC,GAAG;AAAA,EAElF;AAAA,EAEQ,YAAY;AAClB,QAAI,CAAC,KAAK,SAAU;AAGpB,SAAK,oBAAA,GACL,KAAK,iBAAiB,MAAA,GACtB,KAAK,wBAAwB;AAG7B,UAAM7K,IAAQ,KAAK,YAGb8K,wBAAkC,IAAA;AACxC,IAAA9K,EAAM,QAAQ,CAAAH,MAAQ;AAEpB,YAAMkL,IAAkBlL,EAAK,WAAW,OAAO,OAAMmL,MAAO,IAAI,EAAE,KAAK,GAAG;AAC1E,MAAID,KACFD,EAA4B,IAAIC,GAAiBlL,CAAI;AAAA,IAEzD,CAAC,GAEgB,KAAK,SAAS,yBAAyB,KAAK,kBAAkB,EAEtE,QAAQ,CAACoG,MAAgC;AAEhD,UAAI,CAAC,KAAK,eAAe,SAASA,EAAK,eAAe;AACpD;AAIF,YAAMgF,IAAe,KAAK,iBAAiBhF,GAAMjG,CAAK;AAGtD,UAAI,CAACiL,KAAgB,CAAC,KAAK;AACzB;AAIF,YAAMC,IAAS,KAAK,IAAI,MAAM,MAAOjF,EAAK,kBAAkB,IAAI,GAG1DC,IAAW7B,EAAc4B,EAAK,iBAAiB,KAAK,kBAAkB;AAG5E,UAAIkF,IAAajF;AACjB,UAAI,CAAC+E,GAAc;AAEjB,cAAMvB,KAAMxD,KAAY,KAAM,OAAQ,MAAM,MACtCsE,KAAMtE,KAAY,IAAK,OAAQ,MAAM,MAAM,KAC3C5Q,KAAK4Q,IAAW,OAAQ,MAAM,MAAM;AAC1C,QAAAiF,IAAc,KAAK,MAAMzB,CAAC,KAAK,KAAO,KAAK,MAAMc,CAAC,KAAK,IAAK,KAAK,MAAMlV,CAAC;AAAA,MAC1E;AAEA,YAAM6Q,IAAK,IAAIjC,EAAM,QAAQ+B,EAAK,cAAc,CAAC,GAAGA,EAAK,cAAc,CAAC,GAAGA,EAAK,cAAc,CAAC,CAAC,GAG1FmF,IAAS,IAAIlH,EAAM,eAAegH,GAAQ,IAAI,EAAE,GAChDG,IAAQ,IAAInH,EAAM,qBAAqB;AAAA,QAC3C,OAAOiH;AAAA,QACP,aAAa,CAACF;AAAA,QACd,SAASA,IAAe,IAAM;AAAA,QAC9B,WAAW;AAAA,QACX,WAAW;AAAA,MAAA,CACZ,GACKK,IAAS,IAAIpH,EAAM,KAAKkH,GAAQC,CAAK;AAC3C,MAAAC,EAAO,SAAS,KAAKnF,CAAE,GACvB,KAAK,oBAAoB,IAAImF,CAAM,GAG/BL,KACF,KAAK,iBAAiB,IAAIK,GAAQ;AAAA,QAChC,GAAGrF;AAAA,QACH,aAAaA,EAAK,eAAe,CAAA;AAAA,MAAC,CACnC;AAIH,YAAMsF,IAAgBtF,EAAK;AAC3B,UAAIsF,KAAiBA,EAAc,UAAU,GAAG;AAC9C,cAAMC,IAAiBD,EAAc;AAAA,UACnC,CAAAnW,MAAK,IAAI8O,EAAM,QAAQ9O,EAAE,CAAC,GAAGA,EAAE,CAAC,GAAGA,EAAE,CAAC,CAAC;AAAA,QAAA,GAInCqW,IAAW,IAAIvH,EAAM,eAAA,GACrBwE,IAAY,IAAI,aAAa8C,EAAe,SAAS,CAAC;AAC5D,iBAASzT,IAAI,GAAGA,IAAIyT,EAAe,QAAQzT;AACzC,UAAA2Q,EAAU3Q,IAAI,CAAC,IAAIyT,EAAezT,CAAC,EAAE,GACrC2Q,EAAU3Q,IAAI,IAAI,CAAC,IAAIyT,EAAezT,CAAC,EAAE,GACzC2Q,EAAU3Q,IAAI,IAAI,CAAC,IAAIyT,EAAezT,CAAC,EAAE;AAE3C,QAAA0T,EAAS,aAAa,YAAY,IAAIvH,EAAM,gBAAgBwE,GAAW,CAAC,CAAC;AAGzE,cAAMD,IAAoB,CAAA;AAC1B,iBAAS1Q,IAAI,GAAGA,IAAIyT,EAAe,SAAS,GAAGzT;AAC7C,UAAA0Q,EAAQ,KAAK,GAAG1Q,GAAGA,IAAI,CAAC;AAE1B,QAAA0T,EAAS,SAAShD,CAAO,GACzBgD,EAAS,qBAAA;AAET,cAAMC,IAAU,IAAIxH,EAAM,kBAAkB;AAAA,UAC1C,OAAOiH;AAAA,UACP,MAAMjH,EAAM;AAAA,UACZ,aAAa;AAAA,UACb,SAAS+G,IAAe,MAAO;AAAA,UAC/B,YAAY;AAAA,QAAA,CACb,GACKU,IAAW,IAAIzH,EAAM,KAAKuH,GAAUC,CAAO;AACjD,aAAK,oBAAoB,IAAIC,CAAQ;AAGrC,cAAMC,IAAc,IAAI1H,EAAM,eAAA,EAAiB,cAAcsH,CAAc,GACrEK,IAAa,IAAI3H,EAAM,kBAAkB;AAAA,UAC7C,OAAOiH;AAAA,UACP,aAAa;AAAA,UACb,SAASF,IAAe,MAAO;AAAA,QAAA,CAChC,GACKa,IAAc,IAAI5H,EAAM,SAAS0H,GAAaC,CAAU;AAC9D,aAAK,oBAAoB,IAAIC,CAAW;AAGxC,cAAMC,IAAiC,CAAA;AACvC,mBAAWC,KAAMR;AACf,UAAAO,EAAc,KAAK5F,EAAG,MAAA,GAAS6F,CAAE;AAEnC,cAAMC,IAAW,IAAI/H,EAAM,eAAA,EAAiB,cAAc6H,CAAa,GACjEG,IAAU,IAAIhI,EAAM,kBAAkB;AAAA,UAC1C,OAAOiH;AAAA,UACP,aAAa;AAAA,UACb,SAASF,IAAe,OAAO;AAAA,QAAA,CAChC,GACKkB,IAAY,IAAIjI,EAAM,aAAa+H,GAAUC,CAAO;AAC1D,aAAK,oBAAoB,IAAIC,CAAS;AAAA,MACxC;AAAA,IACF,CAAC,GAGD,KAAK,kBAAA,GAEL/G,EAAS,gBAAgB;AAAA,EAC3B;AAAA;AAAA,EAGQ,iBAAiBa,GAA6BjG,GAAiC;AACrF,UAAMG,IAAc8F,EAAK;AACzB,QAAI,CAAC9F,KAAeA,EAAY,WAAW,EAAG,QAAO;AAErD,UAAM0G,IAAcZ,EAAK;AAEzB,eAAWpG,KAAQG,GAAO;AACxB,UAAIH,EAAK,UAAUgH,EAAa;AAKhC,UAAIE,IAAU;AACd,eAAShP,IAAI,GAAGA,IAAIoI,EAAY,QAAQpI,KAAK;AAC3C,cAAMiP,IAAYH,IAAc9O;AAEhC,YADsB8H,EAAK,WAAWmH,CAAS,MACzB7G,EAAYpI,CAAC,GAAG;AACpC,UAAAgP,IAAU;AACV;AAAA,QACF;AAAA,MACF;AAEA,UAAIA,EAAS,QAAO;AAAA,IACtB;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGQ,sBAAsB;AAC5B,WAAO,KAAK,oBAAoB,SAAS,SAAS,KAAG;AACnD,YAAMpJ,IAAQ,KAAK,oBAAoB,SAAS,CAAC;AAEjD,UADA,KAAK,oBAAoB,OAAOA,CAAK,GACjCA,aAAiBuG,EAAM,QAAQvG,aAAiBuG,EAAM,MAAM;AAC9D,QAAAvG,EAAM,UAAU,QAAA;AAChB,cAAMqG,IAAWrG,EAAM;AACvB,YAAI,MAAM,QAAQqG,CAAQ;AACxB,qBAAW2G,KAAO3G;AAChB,YAAI2G,aAAezG,EAAM,YACvByG,EAAI,QAAA;AAAA,YAGV,CAAW3G,aAAoBE,EAAM,YACnCF,EAAS,QAAA;AAAA,MAEb;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,2BAA2B;AACjC,QAAI,CAAC,KAAK,KAAM;AAEhB,UAAMoI,IAAa/F,EAAa,SAAA,EAAW;AAI3C,QADA,KAAK,aAAagG,GAAe,KAAK,KAAK,WAAW,GAClD,KAAK,WAAW,MAAM,WAAW,EAAG;AAGxC,UAAMC,wBAAsB,IAAA,GACtBC,wBAAwB,IAAA;AAC9B,eAAWvB,KAAM,KAAK,WAAW;AAC/B,YAAMwB,IAAMJ,EAAWpB,CAAE;AACzB,UAAIwB,GAAK;AACP,QAAAF,EAAgB,IAAItB,GAAI,CAACwB,EAAI,SAAS,GAAGA,EAAI,SAAS,GAAGA,EAAI,SAAS,CAAC,CAAC;AACxE,cAAMC,IAAKD,EAAI;AACf,YAAIC,GAAI;AACN,gBAAMC,IAAe,IAAI,MAAM,KAAK,YAAY,MAAM;AACtD,mBAASvC,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,YAAAuC,EAAavC,CAAC,IAAIsC,EAAG,sBAAsB,GAAG,KAAK,YAAYtC,CAAC,GAAG,GAAG,CAAC;AAEzE,UAAAoC,EAAkB,IAAIvB,GAAI,EAAE,SAASyB,GAAI,cAAAC,GAAc;AAAA,QACzD;AAAA,MACF;AAAA,IACF;AAGA,UAAMC,wBAAwB,IAAA;AAC9B,eAAW3B,KAAM,KAAK,aAAa;AACjC,YAAM4B,IAAMR,EAAWpB,CAAE;AACzB,MAAI4B,KACFD,EAAkB,IAAI3B,GAAI,CAAC4B,EAAI,SAAS,GAAGA,EAAI,SAAS,GAAGA,EAAI,SAAS,CAAC,CAAC;AAAA,IAE9E;AAGA,UAAMC,IAAyB,CAAA;AAC/B,SAAK,KAAK,SAAS,SAAS,CAACC,MAAc;AACzC,MAAIA,EAAU,QAAWA,EAAU,SAAY,aAC7CD,EAAS,KAAMC,EAAsB,IAAI;AAAA,IAE7C,CAAC;AAED,UAAMC,IAAmBC;AAAA,MACvB,KAAK;AAAA,MACLV;AAAA,MACAK;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACLE;AAAA,IAAA;AAIF,eAAWI,KAAMF,GAAkB;AAEjC,YAAMG,IAASX,EAAkB,IAAIU,EAAG,QAAQ;AAChD,UAAIC,GAAQ;AACV,cAAMC,IAASb,EAAgB,IAAIW,EAAG,QAAQ,GACxCG,IAAKH,EAAG,iBAAiB,CAAC,IAAIE,EAAO,CAAC,GACtCE,IAAKJ,EAAG,iBAAiB,CAAC,IAAIE,EAAO,CAAC,GACtCG,IAAKL,EAAG,iBAAiB,CAAC,IAAIE,EAAO,CAAC,GACtC1W,IAAO,KAAK,KAAK2W,IAAKA,IAAKC,IAAKA,IAAKC,IAAKA,CAAE;AAClD,YAAI7W,IAAO,OAAO;AAChB,gBAAM8W,IAAQ,KAAK,KAAK,KAAK,IAAI,IAAI,KAAK,IAAI,GAAGF,IAAK5W,CAAI,CAAC,CAAC,KAAK,MAAM,KAAK,KACtE+W,IAAM,KAAK,MAAMF,GAAIF,CAAE,KAAK,MAAM,KAAK;AAC7C,mBAASjD,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,gBAAI;AACF,oBAAMsD,IAAOP,EAAO,QAAQ,sBAAsB,GAAG,KAAK,YAAY/C,CAAC,GAAG,KAAK,IAAIqD,CAAG,GAAGD,CAAK,GACxFG,IAAOR,EAAO,aAAa/C,CAAC;AAClC,cAAI,OAAOsD,KAAS,YAAY,OAAOC,KAAS,YAAYA,IAAO,MACjET,EAAG,WAAW9C,CAAC,MAAMsD,IAAOC,MAAS;AAAA,YAEzC,QAAY;AAAA,YAEZ;AAAA,QAEJ;AAAA,MACF;AAGA,YAAMC,IAAShB,EAAkB,IAAIM,EAAG,UAAU,GAC5CW,IAAMD,EAAO,CAAC,IAAIV,EAAG,iBAAiB,CAAC,GACvCY,IAAMF,EAAO,CAAC,IAAIV,EAAG,iBAAiB,CAAC,GACvCa,IAAMH,EAAO,CAAC,IAAIV,EAAG,iBAAiB,CAAC,GACvCc,IAAQ,KAAK,KAAKH,IAAMA,IAAMC,IAAMA,IAAMC,IAAMA,CAAG,GACnDE,IAAaD,IAAQ,QACvB,IAAI7J,EAAM,QAAQ0J,IAAMG,GAAOF,IAAME,GAAOD,IAAMC,CAAK,IACvD,IAAI7J,EAAM,QAAQ,GAAG,GAAG,CAAC,GAEvBiJ,IAASb,EAAgB,IAAIW,EAAG,QAAQ,GACxCgB,IAAc,IAAI/J,EAAM,QAAQyJ,EAAO,CAAC,GAAGA,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC,GAC/DO,IAAY,IAAIhK,EAAM,QAAQ+I,EAAG,iBAAiB,CAAC,GAAGA,EAAG,iBAAiB,CAAC,GAAGA,EAAG,iBAAiB,CAAC,CAAC,GACpGkB,IAAY,IAAIjK,EAAM,QAAQiJ,EAAO,CAAC,GAAGA,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC,GAE7DiB,IAA0B;AAAA,QAC9B,QAAQ,CAACH,GAAaC,GAAWC,CAAS;AAAA,QAC1C,OAAO;AAAA;AAAA,QACP,QAAQlB,EAAG;AAAA,QACX,aAAaA,EAAG;AAAA,QAChB,YAAY,CAAC,MAAM,MAAM,IAAI;AAAA,QAC7B,kBAAkBe;AAAA,QAClB,aAAa,CAAA;AAAA,QACb,YAAYf,EAAG;AAAA,MAAA;AAGjB,WAAK,WAAW,KAAKmB,CAAQ;AAAA,IAC/B;AAEA,IAAIrB,EAAiB,SAAS,KAC5B,QAAQ,IAAI,0BAA0BA,EAAiB,MAAM,oBAAoB;AAAA,EAErF;AAAA;AAAA;AAAA;AAAA,EAKQ,wBAAwB;AAC9B,UAAMsB,IAAW,KAAK,YAAY;AAClC,SAAK,mBAAmB,CAAA;AACxB,aAASlE,IAAI,GAAGA,IAAIkE,GAAUlE;AAC5B,WAAK,iBAAiB,KAAK,IAAI,aAAamE,EAAkB,CAAC;AAIjE,UAAMC,IAAO,MAAMF,CAAQ,EAAE,KADV,GACyB,GAEtCG,IAAa,KAAK,YAAY,SAAS,IACzCnI,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC,IACtD;AAEJ,eAAWxG,KAAQ,KAAK,YAAY;AAClC,YAAM4O,IAAM,KAAK,MAAM5O,EAAK,cAAc6O,CAAmB;AAC7D,UAAID,IAAM,KAAKA,KAAOH,GAAoB;AAE1C,YAAMvO,IAAMF,EAAK,kBACXkK,IAAUyE,IAAaA,EAAW,QAAQ,CAACzO,EAAI,GAAGA,EAAI,GAAGA,EAAI,CAAC,CAAC,IAAI,GACnEiK,IAAW,KAAK,yBAAyBuE,GAAM1O,GAAMkK,CAAO;AAElE,eAASI,IAAI,GAAGA,IAAIkE,GAAUlE;AAE5B,aAAK,iBAAkBA,CAAC,EAAEsE,CAAG,KAAKzE,EAASG,CAAC,IAAIH,EAASG,CAAC;AAAA,IAE9D;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,2BAAiD;AACrD,QAAI,KAAK,WAAW,WAAW;AAC7B,YAAM,IAAI,MAAM,iDAAiD;AAGnE,UAAMwE,IAAaC,EAAY,YAEzBL,IAAO,MAAM,KAAK,YAAY,MAAM,EAAE,KADzB,GACwC,GAErDM,IAAY,KAAK,WAAW,KAAK,WAAW,SAAS,CAAC,EAAE,cAAc,MACtEC,IAAkB,KAAK,MAAMH,IAAaE,CAAS,IAAI,GAEvDE,IAA0B,CAAA;AAChC,aAAS5E,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,MAAA4E,EAAQ,KAAK,IAAI,aAAaD,CAAe,CAAC;AAIhD,UAAME,IAAW,KAAK,YAAY,SAAS,IACvC3I,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC,IACtD;AAEJ,eAAWxG,KAAQ,KAAK,YAAY;AAClC,YAAMoP,IAAc,KAAK,OAAA,IAAW,MAAM,IAAI,IACxClP,IAAMF,EAAK,kBACXkK,IAAUiF,IAAWA,EAAS,QAAQ,CAACjP,EAAI,GAAGA,EAAI,GAAGA,EAAI,CAAC,CAAC,IAAI,GAC/DiK,IAAW,KAAK,yBAAyBuE,GAAM1O,GAAMkK,CAAO,GAC5DmF,IAAgB,KAAK,MAAMrP,EAAK,cAAc8O,CAAU;AAE9D,eAASxE,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,QAAI+E,IAAgBH,EAAQ5E,CAAC,EAAE,WAC7B4E,EAAQ5E,CAAC,EAAE+E,CAAa,KAAKlF,EAASG,CAAC,IAAI8E;AAAA,IAGjD;AAGA,QAAIE,IAAeJ;AACnB,QAAI,KAAK,yBAAyB,KAAK,kBAAkB;AACvD,YAAMK,IAAcC;AAAA,QAClB,KAAK;AAAA,QAAkB,KAAK;AAAA,QAC5B,KAAK;AAAA,QAAmBX;AAAA,MAAA,GAEpB,EAAE,aAAAY,GAAa,iBAAAC,EAAA,IAAoBC,GAAeJ,GAAaT,CAAU,GACzEc,IAA2B,KAAK,MAAM,KAAK,wBAAwBd,CAAU;AACnF,MAAAQ,IAAeO,GAAgBX,GAASO,GAAaC,GAAiBE,CAAwB;AAAA,IAChG;AAIA,UAAME,IADqB,IAAI,OAAO;;;;KAA+D;AAGrG,WAAO,IAAI,QAAQ,CAACC,GAASC,MAAW;AACtC,MAAAF,EAAO,YAAY,EAAE,SAASR,EAAA,CAAc,GAE5CQ,EAAO,YAAY,CAACjK,MAAU;AAC5B,cAAMoK,IAAkBpK,EAAM,KAAK,SAC7BqK,IAAS,IAAI,aAAaD,EAAgB,CAAC,EAAE,UAAU,CAAC;AAE9D,YAAIrX,IAAM;AACV,iBAASV,IAAI,GAAGA,IAAI+X,EAAgB,QAAQ/X;AAC1C,mBAASiD,IAAI,GAAGA,IAAI+U,EAAO,QAAQ/U;AACjC,YAAA+U,EAAO/U,CAAC,KAAK8U,EAAgB/X,CAAC,EAAEiD,CAAC,GAC7B,KAAK,IAAI+U,EAAO/U,CAAC,CAAC,IAAIvC,MACxBA,IAAM,KAAK,IAAIsX,EAAO/U,CAAC,CAAC;AAK9B,cAAMgV,IAAmBC,EAAUF,CAAM,GACnCG,IAAiBtB,EAAY,qBAAqB,GAAGmB,EAAO,QAAQpB,CAAU,GAC9EjL,IAASkL,EAAY,mBAAmBoB,GAAkBE,CAAc;AAE9E,QAAAxM,EAAO,QAAQwM,EAAe,WAAW,GACzCxM,EAAO,MAAA,GAEPkL,EAAY,mBAAmBsB,CAAc,EAC1C,KAAK,CAAAC,MAAM;AACV,eAAK,kBAAkBA,GACvB,KAAK,4BAA4BA,GAAIxB,CAAU,GAC/CiB,EAAQO,CAAE;AAAA,QACZ,CAAC,EACA,MAAMN,CAAM,EACZ,QAAQ,MAAMF,EAAO,WAAW;AAAA,MACrC,GAEAA,EAAO,UAAU,CAACS,MAAU;AAC1B,QAAAT,EAAO,UAAA,GACPE,EAAOO,CAAK;AAAA,MACd;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA,EAGQ,yBAAyBC,GAAsBxQ,GAAqByQ,IAAuB,GAAe;AAEhH,QAAIzQ,EAAK,YAAY;AACnB,YAAM0Q,IAAqBC,EAAOC,EAAQJ,CAAU,CAAC,GAC/CK,IAAsB,IAAI,MAAM,KAAK,YAAY,MAAM;AAC7D,eAASvG,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA,KAAK;AAChD,cAAMwG,IAAmBJ,EAAmBpG,CAAC,IAAItK,EAAK,WAAWsK,CAAC;AAClEuG,QAAAA,EAAUvG,CAAC,IAAKyG,EAAO,CAACD,CAAgB,CAAC,EAAe,CAAC,IAAIL;AAAA,MAC/D;AACA,aAAOI;AAAAA,IACT;AAEA,UAAMG,IAAcL,EAAOC,EAAQJ,CAAU,CAAC,GAIxCS,IAAYjR,EAAK,OAAO,SAAS;AACvC,QAAIiR,KAAa,KAAK,KAAK,UAAU,SAAS,GAAG;AAC/C,YAAMpN,IAAS2C,EAAa,SAAA,EAAW,WAAW,KAAK,UAAU,CAAC,CAAC;AACnE,UAAI3C,GAAQ,oBAAoB;AAC9B,cAAMuF,IAAYpJ,EAAK,OAAOiR,CAAS,GACjC5N,IAAYrD,EAAK,OAAOiR,IAAY,CAAC,GAIrCC,IAHW,IAAI7M,EAAM,QAAA,EAAU,WAAWhB,GAAW+F,CAAS,EAAE,UAAA,EAG5C,MAAA,EAAQ;AAAA,UAChC,IAAI/E,EAAM,MAAM,CAACR,EAAO,SAAS,GAAG,CAACA,EAAO,SAAS,GAAG,CAACA,EAAO,SAAS,GAAGA,EAAO,SAAS,KAAK;AAAA,QAAA,GAE7FgG,IAAIqH,EAAS,OAAA;AACnB,YAAIrH,IAAI,OAAO;AACb,gBAAM6D,IAAQ,KAAK,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,IAAIwD,EAAS,IAAIrH,CAAC,CAAC,CAAC,GAE3DsH,KADM,KAAK,MAAMD,EAAS,GAAGA,EAAS,CAAC,IACtB,MAAM,KAAK,KAAM,MAAM,OAAO,KAC/CE,IAAW1D,IAAQ,MAAM,KAAK;AAEpC,mBAASpD,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA,KAAK;AAChD,kBAAM+G,IAAcxN,EAAO,mBAAmB,sBAAsB,GAAG,KAAK,YAAYyG,CAAC,GAAG6G,GAAQC,CAAQ,GACtGE,IAAczN,EAAO,mBAAmB,sBAAsB,GAAG,KAAK,YAAYyG,CAAC,GAAG,GAAG,CAAC;AAChG,YAAI,OAAO+G,KAAgB,YAAY,OAAOC,KAAgB,YAAYA,IAAc,MACtFN,EAAY1G,CAAC,MAAM+G,IAAcC,MAAgB;AAAA,UAErD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAKA,QAAIC,IAAgB;AAEpB,IAAAvR,EAAK,WAAW,QAAQ,CAACwR,GAAWC,MAAQ;AAC1C,UAAID,MAAc,KAAM;AAExB,YAAMlJ,IAAU,KAAK,iBAAiB,IAAIkJ,CAAS;AACnD,UAAI,CAAClJ,GAAS;AACZ,QAAAiJ;AACA;AAAA,MACF;AAGA,UAAIG,IAAQ;AACZ,UAAI1R,EAAK,eAAeuR,IAAgBvR,EAAK,YAAY;AACvD,QAAA0R,IAAQ1R,EAAK,YAAYuR,CAAa,EAAE;AAAA,eAC/BE,IAAM,KAAKA,IAAMzR,EAAK,OAAO,SAAS,GAAG;AAElD,cAAMjD,IAAW,IAAIsH,EAAM,QAAA,EAAU,WAAWrE,EAAK,OAAOyR,IAAM,CAAC,GAAGzR,EAAK,OAAOyR,CAAG,CAAC,EAAE,UAAA,GAClFE,IAAa,IAAItN,EAAM,QAAA,EAAU,WAAWrE,EAAK,OAAOyR,IAAM,CAAC,GAAGzR,EAAK,OAAOyR,CAAG,CAAC,EAAE,UAAA,GACpFjP,IAAW,KAAK,IAAI,GAAG,KAAK,IAAI,IAAIzF,EAAS,IAAI4U,CAAU,CAAC,CAAC;AACnE,QAAAD,IAAQ,KAAK,KAAKlP,CAAQ,IAAI;AAAA,MAChC;AACA,MAAA+O;AAEA,eAASjH,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA,KAAK;AAChD,cAAMsH,IAAI,KAAK,IAAItJ,EAAQ,mBAAmB,KAAK,YAAYgC,CAAC,GAAGoH,CAAK,CAAC;AACzE,QAAAV,EAAY1G,CAAC,KAAKsH;AAAA,MACpB;AAAA,IACF,CAAC;AAGD,UAAMC,IAAYxH,EAAQ0G,EAAOC,CAAW,CAAC,GACvCc,IAAmBC,GAAkB,KAAK,aAAa,KAAK,WAAW;AAE7E,aAASzH,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,MAAAuH,EAAUvH,CAAC,KAAKwH,EAAiBxH,CAAC,IAAItK,EAAK;AAI7C,UAAM6Q,IAAYD,EAAQiB,CAAS;AACnC,QAAIpB,MAAiB;AACnB,eAASnG,IAAI,GAAGA,IAAIuG,EAAU,QAAQvG;AACpC,QAAAuG,EAAUvG,CAAC,KAAKmG;AAGpB,WAAOI;AAAA,EACT;AAAA;AAAA,EAGQ,4BAA4BP,GAAiBxB,GAAoB;AACvE,UAAMvC,IAAa/F,EAAa,SAAA,EAAW,YACrCwL,IAAa,KAAK,UAAU,SAAS,KAAIzF,EAAW,KAAK,UAAU,CAAC,CAAC,GAAG,QAAQ,UAChF0F,IAAe,KAAK,YAAY,SAAS,KAAI1F,EAAW,KAAK,YAAY,CAAC,CAAC,GAAG,QAAQ,YAGtF2F,IAAc5B,EAAG,eAAe,CAAC,GACjC6B,IAA8C,CAAA,GAG9CC,IAAmB,KAAK,IAAI,GAAG,KAAK,MAAMF,EAAY,SAAS,GAAI,CAAC;AAC1E,aAASha,IAAI,GAAGA,IAAIga,EAAY,QAAQha,KAAKka;AAC3C,MAAAD,EAAK,KAAK;AAAA,QACR,MAAMja,IAAI4W;AAAA,QACV,WAAWoD,EAAYha,CAAC;AAAA,MAAA,CACzB;AAGH,YAAQ,IAAI,4CAA4Cia,EAAK,MAAM,wBAAwBD,EAAY,SAASpD,GAAY,QAAQ,CAAC,CAAC,GAAG;AAEzI,UAAM1W,IAA6C;AAAA,MACjD,MAAMkN,EAAW;AAAA,MACjB,MAAA6M;AAAA,MACA,MAAM;AAAA,QACJ,YAAArD;AAAA,QACA,YAAAkD;AAAA,QACA,cAAAC;AAAA,QACA,UAAU,KAAK,UAAU,CAAC,KAAK;AAAA,QAC/B,YAAY,KAAK,YAAY,CAAC,KAAK;AAAA,MAAA;AAAA,MAErC,MAAM,OAAOD,CAAU,MAAMC,CAAY;AAAA,MACzC,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,IAAA;AAGb,IAAA5M,EAAK,iBAAiB,EAAE,MAAM,KAAK,uBAAuB,QAAAjN,GAAQ;AAAA,EACpE;AAAA,EAEA,MAAM,sBAAsB;AAC1B,UAAMA,IAAS,MAAMia;AAAAA,MACnB,KAAK;AAAA,MAAiB,MAAM,KAAK,yBAAA;AAAA,MAA4B,KAAK;AAAA,MAAM;AAAA,IAAA;AAE1E,SAAK,kBAAkBja,EAAO;AAAA,EAChC;AAAA,EAEA,MAAM,wBAAwBka,GAAkBxD,IAAaC,EAAY,YAAY;AACnF,UAAM3W,IAAS,MAAMma;AAAAA,MACnB,KAAK;AAAA,MAAiB,MAAM,KAAK,yBAAA;AAAA,MAA4BD;AAAA,MAAUxD;AAAA,IAAA;AAEzE,SAAK,kBAAkB1W,EAAO;AAAA,EAChC;AAAA;AAAA,EAGA;AAAA,EACA,iBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASzB,MAAM,kCAAkCwJ,IAAgB,GAAyB;AAC/E,QAAI,KAAK,WAAW,WAAW;AAC7B,YAAM,IAAI,MAAM,iDAAiD;AAGnE,UAAMkN,IAAaC,EAAY,YAEzBL,IAAO,MAAM,KAAK,YAAY,MAAM,EAAE,KADzB,GACwC,GAErDM,IAAY,KAAK,WAAW,KAAK,WAAW,SAAS,CAAC,EAAE,cAAc;AAC5E,QAAIA,KAAa,EAAG,OAAM,IAAI,MAAM,mCAAmC;AACvE,UAAMC,IAAkB,KAAK,MAAMH,IAAaE,CAAS,IAAI;AAC7D,QAAIC,IAAkB,EAAG,OAAM,IAAI,MAAM,uCAAuC;AAChF,UAAMuD,IAAMC,GAAyB7Q,CAAK,GAGpCsN,IAA4B,CAAA;AAClC,aAAS5E,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA,KAAK;AAChD,MAAA4E,EAAQ,KAAK,EAAE;AACf,eAASwD,IAAK,GAAGA,IAAKF,GAAKE;AACzB,QAAAxD,EAAQ5E,CAAC,EAAE,KAAK,IAAI,aAAa2E,CAAe,CAAC;AAAA,IAErD;AAGA,UAAM0D,IAAa,KAAK,YAAY,SAAS,IACzCnM,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC,IACtD;AAEJ,eAAWxG,KAAQ,KAAK,YAAY;AAClC,YAAMoP,IAAc,KAAK,OAAA,IAAW,MAAM,IAAI,IACxClP,IAAMF,EAAK,kBACXkK,IAAUyI,IAAaA,EAAW,QAAQ,CAACzS,EAAI,GAAGA,EAAI,GAAGA,EAAI,CAAC,CAAC,IAAI,GACnEiK,IAAW,KAAK,yBAAyBuE,GAAM1O,GAAMkK,CAAO,GAC5DmF,IAAgB,KAAK,MAAMrP,EAAK,cAAc8O,CAAU;AAE9D,UAAIO,KAAiBJ,EAAiB;AAGtC,YAAM2D,IAAU,IAAI,aAAa,CAAC;AAGlC,eAAStI,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA,KAAK;AAChD,QAAAsI,EAAQ,CAAC,IAAIzI,EAASG,CAAC,IAAI8E;AAG3B,cAAMyD,IAAUC,GAA0BF,GAAS1S,EAAI,GAAGA,EAAI,GAAGA,EAAI,GAAG0B,GAAO,SAAS;AAGxF,iBAAS8Q,IAAK,GAAGA,IAAKF,GAAKE;AACzB,UAAAxD,EAAQ5E,CAAC,EAAEoI,CAAE,EAAErD,CAAa,KAAKwD,EAAQH,CAAE,EAAE,CAAC;AAAA,MAElD;AAAA,IACF;AAGA,QAAI,KAAK,yBAAyB,KAAK,kBAAkB;AACvD,YAAMnD,IAAcC;AAAA,QAClB,KAAK;AAAA,QAAkB,KAAK;AAAA,QAC5B,KAAK;AAAA,QAAmBX;AAAA,MAAA,GAEpB,EAAE,aAAAY,GAAa,iBAAAC,EAAA,IAAoBC,GAAeJ,GAAaT,CAAU,GACzEc,IAA2B,KAAK,MAAM,KAAK,wBAAwBd,CAAU,GAE7EiE,IAAkC,CAAA;AACxC,eAASzI,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,QAAAyI,EAAgB,KAAK7D,EAAQ5E,CAAC,EAAE,CAAC,CAAC;AAEpC,YAAM0I,IAAYnD,GAAgBkD,GAAiBtD,GAAaC,GAAiBE,CAAwB;AAEzG,eAAStF,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,QAAA4E,EAAQ5E,CAAC,EAAE,CAAC,IAAI0I,EAAU1I,CAAC;AAAA,IAE/B;AAGA,UAAM2I,IAAe,MAAM,IAAI,OAAO;;;;KAA+D;AAErG,WAAO,IAAI,QAAQ,CAAClD,GAASC,MAAW;AAEtC,YAAMkD,IAAiB,OAAOC,MACrB,IAAI,QAAQ,CAACC,MAAmB;AACrC,cAAMC,IAAqC,CAAA;AAC3C,iBAAS/I,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,UAAA+I,EAAmB,KAAKnE,EAAQ5E,CAAC,EAAE6I,CAAO,CAAC;AAG7C,cAAMG,IAAgBL,EAAA;AACtB,QAAAK,EAAc,YAAY,EAAE,SAASD,EAAA,CAAoB,GACzDC,EAAc,YAAY,CAACzN,MAAU;AACnC,gBAAMoK,IAAkBpK,EAAM,KAAK,SAC7BqK,IAAS,IAAI,aAAaD,EAAgB,CAAC,EAAE,UAAU,CAAC;AAE9D,mBAAS3F,IAAI,GAAGA,IAAI2F,EAAgB,QAAQ3F;AAC1C,qBAASnP,IAAI,GAAGA,IAAI+U,EAAO,QAAQ/U;AACjC,cAAA+U,EAAO/U,CAAC,KAAK8U,EAAgB3F,CAAC,EAAEnP,CAAC;AAIrC,UAAAmY,EAAc,UAAA,GACdF,EAAelD,CAAM;AAAA,QACvB;AAAA,MACF,CAAC;AAIH,cAAQ;AAAA,QACN,MAAM,KAAK,EAAE,QAAQsC,EAAA,GAAO,CAACtN,GAAGwN,MAAOQ,EAAeR,CAAE,CAAC;AAAA,MAAA,EACzD,KAAK,CAACa,MAAmB;AAEzB,YAAI3a,IAAM;AACV,mBAAWsX,KAAUqD;AACnB,mBAASpY,IAAI,GAAGA,IAAI+U,EAAO,QAAQ/U;AACjC,YAAI,KAAK,IAAI+U,EAAO/U,CAAC,CAAC,IAAIvC,MACxBA,IAAM,KAAK,IAAIsX,EAAO/U,CAAC,CAAC;AAM9B,YAAIvC,IAAM;AACR,qBAAWsX,KAAUqD;AACnB,qBAASpY,IAAI,GAAGA,IAAI+U,EAAO,QAAQ/U;AACjC,cAAA+U,EAAO/U,CAAC,KAAKvC;AAMnB,cAAM4a,IAAeD,EAAe,CAAC,EAAE;AACvC,YAAIC,MAAiB,GAAG;AACtB,UAAAxD,EAAO,IAAI,MAAM,iCAAiC,CAAC;AACnD;AAAA,QACF;AAEA,cAAMyD,IADiB1E,EAAY,qBAAqByD,GAAKgB,GAAc1E,CAAU,EACvD,aAAa0D,GAAKgB,GAAc1E,CAAU;AAExE,iBAAS4D,IAAK,GAAGA,IAAKF,GAAKE;AACzB,UAAAe,EAAO,cAAc,IAAI,aAAaF,EAAeb,CAAE,CAAC,GAAGA,CAAE;AAG/D,aAAK,2BAA2Be,GAChC,KAAK,iBAAiB7R,GACtBmO,EAAQ0D,CAAM;AAAA,MAChB,CAAC,EAAE,MAAMzD,CAAM;AAAA,IACjB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,iCACJsC,GACA1Q,IAAgB,GAChB;AACA,UAAMxJ,IAAS,MAAMsb;AAAAA,MACnB,KAAK;AAAA,MACL,CAACC,MAAc,KAAK,kCAAkCA,CAAC;AAAA,MACvD,KAAK;AAAA,MAAgB/R;AAAA,MAAO0Q;AAAA,IAAA;AAE9B,SAAK,2BAA2Bla,EAAO,0BACvC,KAAK,iBAAiBA,EAAO;AAAA,EAC/B;AAAA,EAEA,MAAM,iCAAiCwJ,IAAgB,GAAyB;AAE9E,YAAI,CAAC,KAAK,4BAA4B,KAAK,mBAAmBA,OAC5D,KAAK,2BAA2B,MAAM,KAAK,kCAAkCA,CAAK,GAClF,KAAK,iBAAiBA,IAGxB,KAAK,0BAA0B,MAAMgS,GAA+B;AAAA,MAClE,0BAA0B,KAAK;AAAA,MAC/B,OAAAhS;AAAA,MACA,eAAe,KAAK;AAAA,MACpB,SAAS,KAAK;AAAA,MACd,WAAW,KAAK;AAAA,MAChB,UAAU,KAAK;AAAA,IAAA,CAChB,GACM,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,4BAA4BA,IAAgB,GAAG;AACnD,UAAMxJ,IAAS,MAAMyb;AAAAA,MACnB,KAAK;AAAA,MACL,MAAM,KAAK,iCAAiCjS,CAAK;AAAA,MACjD,KAAK;AAAA,MAAM;AAAA,IAAA;AAEb,SAAK,0BAA0BxJ,EAAO;AAAA,EACxC;AAAA,EAEA,MAAM,gCAAgCka,GAAkB1Q,IAAgB,GAAG;AACzE,UAAMxJ,IAAS,MAAM0b;AAAAA,MACnB,KAAK;AAAA,MACL,MAAM,KAAK,iCAAiClS,CAAK;AAAA,MACjD0Q;AAAA,IAAA;AAEF,SAAK,0BAA0Bla,EAAO;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,+BAA+B;AAE7B,QADI,KAAK,WAAW,WAAW,KAC3B,KAAK,YAAY,WAAW,KAAK,KAAK,UAAU,WAAW,EAAG;AAElE,UAAM2b,IAAQ,KAAK,YAAY,CAAC,GAC1BC,IAAQ,KAAK,UAAU,CAAC,GAExBtF,IAAO,MAAM,KAAK,YAAY,MAAM,EAAE,KADzB,GACwC,GAErDuF,IAAkBzN,EAAa,SAAA,EAAW,WAAWuN,CAAK,GAE1DjK,IAAc,CAAC,GAAG,KAAK,UAAU,EAAE,KAAK,CAACtU,GAAGC,MAAMD,EAAE,cAAcC,EAAE,WAAW,GAE/Eye,IAA4B,CAAA;AAElC,eAAWlU,KAAQ8J,GAAa;AAC9B,YAAM5J,IAAMF,EAAK,kBACXkK,IAAU+J,IAAkBA,EAAgB,QAAQ,CAAC/T,EAAI,GAAGA,EAAI,GAAGA,EAAI,CAAC,CAAC,IAAI,GAC7EiK,IAAW,KAAK,yBAAyBuE,GAAM1O,GAAMkK,CAAO,GAC5DiK,IAAQ9J,EAAQF,CAAQ;AAE9B,MAAA+J,EAAS,KAAK;AAAA,QACZ,MAAMlU,EAAK;AAAA,QACX,SAASA,EAAK;AAAA,QACd,OAAAmU;AAAA,MAAA,CACD;AAAA,IACH;AAEA,UAAMC,IAAqC;AAAA,MACzC,CAACL,CAAK,GAAG;AAAA,QACP,CAACC,CAAK,GAAG;AAAA,UACP,OAAO,KAAK;AAAA,UACZ,UAAAE;AAAA,QAAA;AAAA,MACF;AAAA,IACF;AAGF,SAAK,sBAAsBG,GAA4BD,GAAKE,EAA6B;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,qBAAqBhC,GAAkBxD,IAAaC,EAAY,YAAY;AAC1E,QAAI,KAAK,WAAW,WAAW;AAC7B,YAAM,IAAI,MAAM,iDAAiD;AAInE,UAAML,IAAO,MAAM,KAAK,YAAY,MAAM,EAAE,KADzB,GACwC,GACrD5E,IAAc,CAAC,GAAG,KAAK,UAAU,EAAE,KAAK,CAAC,GAAGrU,MAAM,EAAE,cAAcA,EAAE,WAAW,GAE/EuZ,IAAYlF,EAAYA,EAAY,SAAS,CAAC,EAAE,cAAc,MAC9DmF,IAAkB,KAAK,MAAMH,IAAaE,CAAS,GAEnDE,IAA0B,CAAA;AAChC,aAAS5E,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,MAAA4E,EAAQ,KAAK,IAAI,aAAaD,CAAe,CAAC;AAGhD,UAAMsF,IAAiB,KAAK,YAAY,SAAS,IAC7C/N,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC,IACtD;AAEJ,eAAWxG,KAAQ8J,GAAa;AAC9B,YAAMsF,IAAc,KAAK,OAAA,IAAW,MAAM,IAAI,IACxClP,IAAMF,EAAK,kBACXkK,IAAUqK,IAAiBA,EAAe,QAAQ,CAACrU,EAAI,GAAGA,EAAI,GAAGA,EAAI,CAAC,CAAC,IAAI,GAC3EiK,IAAW,KAAK,yBAAyBuE,GAAM1O,GAAMkK,CAAO,GAC5DmF,IAAgB,KAAK,MAAMrP,EAAK,cAAc8O,CAAU;AAE9D,eAASxE,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA;AAC3C,QAAI+E,IAAgBH,EAAQ5E,CAAC,EAAE,WAC7B4E,EAAQ5E,CAAC,EAAE+E,CAAa,KAAKlF,EAASG,CAAC,IAAI8E;AAAA,IAGjD;AAEA,aAAS9E,IAAI,GAAGA,IAAI,KAAK,YAAY,QAAQA,KAAK;AAChD,YAAMkK,IAAOC,GAAa,CAACrE,EAAUlB,EAAQ5E,CAAC,CAAC,CAAC,GAAG,EAAE,YAAAwE,GAAY,UAAU,IAAI;AAC/E4F,MAAAA,GAAU,OAAOF,GAAM,GAAG,KAAK,YAAYlK,CAAC,CAAC,IAAIgI,CAAQ,MAAM;AAAA,IACjE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,mBAAmBqC,IAAkB,KAAK;AAOxC,QALI,KAAK,2BAA2B,SAClC,OAAO,cAAc,KAAK,sBAAsB,GAChD,KAAK,yBAAyB,OAG5B,KAAK,UAAU,WAAW,EAAG;AACjC,UAAM9Q,IAAS2C,EAAa,SAAA,EAAW,WAAW,KAAK,UAAU,CAAC,CAAC;AACnE,QAAI,CAAC3C,EAAQ;AAGb,UAAMwE,IAAO,KAAK;AAClB,QAAI,CAACA,EAAM;AAEX,UAAMuM,IAAkC,CAAA;AAMxC,QALAvM,EAAK,SAAS,SAAS,CAACvK,MAA0B;AAChD,MAAKA,EAAqB,UACxB8W,EAAc,KAAK9W,CAAK;AAAA,IAE5B,CAAC,GACG8W,EAAc,WAAW,EAAG;AAEhC,SAAK,uBAAuB,CAAA,GAC5B,KAAK,eAAe;AACpB,QAAIC,IAAQ;AACZ,UAAMC,IAAY;AAElB,SAAK,yBAAyB,OAAO,YAAY,MAAM;AACrD,eAAS5c,IAAI,GAAGA,IAAI4c,KAAaD,IAAQF,GAASzc,KAAK2c,KAAS;AAC9D,cAAMzc,IAAS2c;AAAAA,UACb,KAAK;AAAA,UAAYH;AAAA,UACjB/Q,EAAO;AAAA,UAAUA,EAAO;AAAA,UACxB,KAAK;AAAA,UAAa,KAAK;AAAA,QAAA;AAEzB,aAAK,qBAAqB,KAAKzL,CAAM;AAAA,MACvC;AAEA,UAAIyc,KAASF,GAAS;AACpB,eAAO,cAAc,KAAK,sBAAuB,GACjD,KAAK,yBAAyB;AAG9B,cAAMnG,IAAW,KAAK,YAAY,QAC5BwG,IAAW,MAAMxG,CAAQ,EAAE,KAAK,CAAC;AACvC,YAAIyG,IAAc,MAAMzG,CAAQ,EAAE,KAAK,CAAC;AAExC,mBAAW3E,KAAK,KAAK;AACnB,mBAASS,IAAI,GAAGA,IAAIkE,GAAUlE;AAC5B,YAAIT,EAAE,MAAMS,CAAC,IAAI,MACf0K,EAAS1K,CAAC,KAAKT,EAAE,MAAMS,CAAC,GACxB2K,EAAY3K,CAAC;AAKnB,iBAASA,IAAI,GAAGA,IAAIkE,GAAUlE;AAC5B,UAAA0K,EAAS1K,CAAC,IAAI2K,EAAY3K,CAAC,IAAI,IAAI0K,EAAS1K,CAAC,IAAI2K,EAAY3K,CAAC,IAAI;AAGpE,aAAK,eAAe0K,GACpB3P,EAAK,qCAAqC,KAAK,IAAI;AAAA,MACrD;AAAA,IACF,GAAG,CAAC;AAAA,EACN;AAAA;AAAA,EAGA,QAAQ;AACN,SAAK,aAAa,CAAA,GAClB,KAAK,mBAAA,GACL,KAAK,WAAW,MAChB,KAAK,cAAc,MAGnB,KAAK,sBAAsB,QAGvB,KAAK,2BAA2B,SAClC,OAAO,cAAc,KAAK,sBAAsB,GAChD,KAAK,yBAAyB,OAEhC,KAAK,uBAAuB,CAAA,GAC5B,KAAK,eAAe,MAGpB,KAAK,8BAAA,GAGJ,KAAK,aAAa,SAAsB,UAAU,CAAA,CAAE,GACrD,KAAK,mBAAA,GAELE,EAAS,gBAAgB;AAAA,EAC3B;AAAA;AAAA,EAGQ,qBAAqB;AAC3B,WAAO,KAAK,mBAAmB,SAAS,SAAS,KAAG;AAClD,YAAMzH,IAAQ,KAAK,mBAAmB,SAAS,CAAC;AAChD,WAAK,mBAAmB,OAAOA,CAAK,IAChCA,aAAiBuG,EAAM,QAAQvG,aAAiBuG,EAAM,UACxDvG,EAAM,UAAU,QAAA,GACZA,EAAM,oBAAoBuG,EAAM,YAClCvG,EAAM,SAAS,QAAA;AAAA,IAGrB;AAAA,EACF;AAAA;AAAA,EAGA,IAAI,OAAyB;AAC3B,WAAO0I,EAAa,SAAA,EAAW,WAAW,KAAK,MAAM;AAAA,EACvD;AAAA,EAEA,IAAI,UAAoB;AACtB,WAAO,KAAK,UACT,IAAI,CAAA2E,MAAM3E,EAAa,SAAA,EAAW,WAAW2E,CAAE,CAAW,EAC1D,OAAO,OAAO;AAAA,EACnB;AAAA,EAEA,IAAI,YAAwB;AAC1B,WAAO,KAAK,YACT,IAAI,CAAAA,MAAM3E,EAAa,SAAA,EAAW,WAAW2E,CAAE,CAAa,EAC5D,OAAO,OAAO;AAAA,EACnB;AAAA,EAEA,IAAI,gBAAwB;AAC1B,WAAO,KAAK,WAAW;AAAA,EACzB;AAAA,EAEA,IAAI,wBAAwBvJ,GAAe;AAEzC,SAAK,qBAAqB,KAAK,IAAI,GAAG,KAAK,MAAMA,CAAK,CAAC,GAEvD,KAAK,cAAc,MAAM,KAAK,EAAE,QAAQ,KAAK,qBAAqB,EAAA,GAAK,CAACsD,GAAGhN,MAAMA,CAAC,GAClF,KAAK,iBAAiB,MAAM,KAAK,EAAE,QAAQ,KAAK,qBAAqB,EAAA,GAAK,CAACgN,GAAGhN,MAAMA,CAAC,GAEjF,KAAK,UAAU,SAAS,KAAK,KAAK,YAAY,SAAS,KACzD,KAAK,UAAA,GACLmN,EAAK,gCAAgC,KAAK,IAAI,KAE9C,KAAK,MAAA;AAAA,EAET;AAAA,EAEA,IAAI,0BAAkC;AACpC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,oBAAuC;AACzC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,kBAAkB6P,GAAyB;AAM7C,YALA,KAAK,qBAAqBA,GAG1B,KAAK,mBAAA,GAEGA,GAAA;AAAA,MACN,KAAK;AACH,QAAI,KAAK,WAAW,SAAS,KAC3B,KAAK,UAAA;AAEP;AAAA,MACF,KAAK;AACH,QAAI,KAAK,YACP,KAAK,UAAA;AAEP;AAAA,MACF,KAAK;AACH,QAAI,KAAK,WAAW,SAAS,KAC3B,KAAK,UAAA,GAEH,KAAK,YACP,KAAK,UAAA;AAEP;AAAA,IAAA;AAGJ,IAAA3P,EAAS,gBAAgB;AAAA,EAC3B;AAAA;AAAA,EAGA,IAAI,eAAwB;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,aAAa4P,GAAgB;AAC/B,SAAK,gBAAgBA,IAEjB,KAAK,uBAAuB,WAAW,KAAK,uBAAuB,YACrE,KAAK,mBAAA,GACD,KAAK,uBAAuB,UAAU,KAAK,WAAW,SAAS,KACjE,KAAK,UAAA,GAEH,KAAK,YACP,KAAK,UAAA,GAEP5P,EAAS,gBAAgB;AAAA,EAE7B;AAAA;AAAA,EAGA,IAAI,gBAA0B;AAC5B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,cAAcgF,GAAkB;AAIlC,YAHA,KAAK,iBAAiBA,GAEtB,KAAK,mBAAA,GACG,KAAK,oBAAA;AAAA,MACX,KAAK;AACH,QAAI,KAAK,WAAW,SAAS,KAC3B,KAAK,UAAA;AAEP;AAAA,MACF,KAAK;AACH,QAAI,KAAK,YACP,KAAK,UAAA;AAEP;AAAA,MACF,KAAK;AACH,QAAI,KAAK,WAAW,SAAS,KAC3B,KAAK,UAAA,GAEH,KAAK,YACP,KAAK,UAAA;AAEP;AAAA,IAAA;AAEJ,IAAAhF,EAAS,gBAAgB;AAAA,EAC3B;AAAA;AAAA,EAGA,cAAcjF,GAAuB;AACnC,QAAI,CAAC,KAAK,UAAU;AAClB,cAAQ,KAAK,0DAA0D;AACvE;AAAA,IACF;AACA,QAAI,KAAK,YAAY,WAAW,GAAG;AACjC,cAAQ,KAAK,sDAAsD;AACnE;AAAA,IACF;AAEA,UAAMiG,IAAWC,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC;AACvE,QAAI,CAACD,GAAU;AACb,cAAQ,KAAK,sCAAsC;AACnD;AAAA,IACF;AAEA,UAAMpI,IAA0B;AAAA,MAC9BoI,EAAS,SAAS;AAAA,MAClBA,EAAS,SAAS;AAAA,MAClBA,EAAS,SAAS;AAAA,IAAA;AAGpB,YAAQ,MAAM,4BAA4BjG,EAAY,KAAK,KAAK,CAAC,GAAG,GACpE,KAAK,SAAS,cAAcnC,GAAamC,CAAW,GACpD,QAAQ,SAAA;AAAA,EACV;AAAA;AAAA,EAGA,YAAY8U,GAAkB;AAG5B,YAAQ,IAAI,8BAA8BA,IAAU,YAAY,UAAU,mEAAmE;AAAA,EAC/I;AAAA;AAAA,EAGA,mBAA+C;AAC7C,QAAI,CAAC,KAAK;AACR,qBAAQ,KAAK,0DAA0D,GAChE,CAAA;AAET,QAAI,KAAK,YAAY,WAAW;AAC9B,qBAAQ,KAAK,wCAAwC,GAC9C,CAAA;AAGT,UAAM7O,IAAWC,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC;AACvE,QAAI,CAACD;AACH,qBAAQ,KAAK,sCAAsC,GAC5C,CAAA;AAGT,UAAMpI,IAA0B;AAAA,MAC9BoI,EAAS,SAAS;AAAA,MAClBA,EAAS,SAAS;AAAA,MAClBA,EAAS,SAAS;AAAA,IAAA;AAGpB,WAAO,KAAK,SAAS,iBAAiBpI,CAAW;AAAA,EACnD;AAAA;AAAA,EAGA,qBAAqBgJ,GAAmB;AACtC,UAAM2C,IAAc,CAAC,GAAG,KAAK,UAAU,EAAE,KAAK,CAACtU,GAAGC,MAAMD,EAAE,cAAcC,EAAE,WAAW;AAErF,QAAI0R,IAAY,KAAKA,KAAa2C,EAAY,QAAQ;AACpD,cAAQ,KAAK,8CAA8C3C,CAAS;AACpE;AAAA,IACF;AAEA,UAAMnH,IAAO8J,EAAY3C,CAAS;AAGjC,SAAK,aAAa,SAAsB,UAAU,CAAA,CAAE,GACrD,KAAK,mBAAA;AAGL,UAAMkO,IAAe7Q,EAAcxE,EAAK,OAAO,KAAK,kBAAkB,GAGhEsV,IAAc,IAAIjR,EAAM,kBAAkB;AAAA,MAC9C,OAAOgR;AAAA,MACP,WAAW;AAAA,MACX,aAAa;AAAA,IAAA,CACd;AAGD,aAASnd,IAAI,GAAGA,IAAI8H,EAAK,OAAO,SAAS,GAAG9H,KAAK;AAC/C,YAAMqd,IAAc,IAAIlR,EAAM,eAAA,EAAiB,cAAc;AAAA,QAC3DrE,EAAK,OAAO9H,CAAC;AAAA,QACb8H,EAAK,OAAO9H,IAAI,CAAC;AAAA,MAAA,CAClB,GACKsd,IAAc,IAAInR,EAAM,KAAKkR,GAAaD,CAAW;AAC3D,WAAK,mBAAmB,IAAIE,CAAW;AAAA,IACzC;AAGA,QAAI,KAAK,YAAY,KAAK,YAAY,SAAS,GAAG;AAChD,YAAMjP,IAAWC,EAAa,SAAA,EAAW,WAAW,KAAK,YAAY,CAAC,CAAC;AACvE,UAAID,GAAU;AAEZ,cAAMkP,IAAW,KAAK,SAAS,yBAAyB,KAAK,kBAAkB,GACzEC,IAAgB1V,EAAK,WAAWA,EAAK,KAAK;AAEhD,YAAI0V,MAAkB,MAAM;AAC1B,gBAAMC,IAAeF,EAAS;AAAA,YAAK,CAACrP,MAClCA,EAAK,cAAcsP,KAAiBtP,EAAK,oBAAoBpG,EAAK;AAAA,UAAA;AAGpE,cAAI2V,GAAc;AAChB,kBAAMjP,IAAiB,IAAIrC,EAAM,mBAAmB;AAAA,cAClD,OAAOgR;AAAA,cACP,WAAW;AAAA,cACX,UAAU;AAAA,cACV,SAAS;AAAA,cACT,aAAa;AAAA,cACb,SAAS;AAAA,YAAA,CACV,GAEKO,IAAmB,IAAIvR,EAAM;AAAA,cACjCsR,EAAa,cAAc,CAAC;AAAA,cAC5BA,EAAa,cAAc,CAAC;AAAA,cAC5BA,EAAa,cAAc,CAAC;AAAA,YAAA,GAExBlP,IAAcF,EAAS,SAAS,MAAA,GAEhCsP,IAAiB,IAAIxR,EAAM,eAAA,EAAiB,cAAc,CAACuR,GAAkBnP,CAAW,CAAC,GACzFqP,IAAa,IAAIzR,EAAM,KAAKwR,GAAgBnP,CAAc;AAChE,YAAAoP,EAAW,qBAAA,GACX,KAAK,mBAAmB,IAAIA,CAAU;AAAA,UACxC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,IAAI,sCAAsC3O,CAAS,eAAenH,EAAK,KAAK,kBAAkBA,EAAK,YAAY,QAAQ,CAAC,CAAC,GAAG,GAEpIuF,EAAS,gBAAgB;AAAA,EAC3B;AAAA;AAAA,EAGA,qBAAqB;AAClB,SAAK,aAAa,SAAsB,UAAU,CAAA,CAAE,GACrD,KAAK,mBAAA,GACLA,EAAS,gBAAgB;AAAA,EAC3B;AACF;AA0BAwQ,EAAG,0BAA0BC,EAAiB;AAC9CD,EAAG,oBAAoBE,EAAY;AACnCF,EAAG,iBAAiBG,GAAUpR,EAAe,CAAC;AAE9CiR,EAAG,uBAAuB,CAACI,MAAiB;AAE1C,EADeC,EAAU,SAAA,EAAW,QAAQD,CAAI,EACzC,UAAA,GAGP,WAAW,MAAM9Q,EAAK,gCAAgC8Q,CAAI,GAAG,CAAC;AAChE,CAAC;AAEDJ,EAAG,mBAAmB,CAACI,MAAiB;AAEtC,EADeC,EAAU,SAAA,EAAW,QAAQD,CAAI,EACzC,MAAA;AACT,CAAC;AAEDJ,EAAG,qBAAqB,CAACI,MAAiB;AAExC,EADeC,EAAU,SAAA,EAAW,QAAQD,CAAI,EACzC,oBAAA,EAAsB,MAAM,CAACE,MAAe;AACjD,WAAO,MAAMA,EAAI,WAAW,iCAAiC;AAAA,EAC/D,CAAC;AACH,CAAC;AAEDN,EAAG,yBAAyB,CAACI,MAAiB;AAC5C,QAAMG,IAASF,EAAU,SAAA,EAAW,QAAQD,CAAI,GAC1C5J,IAAa/F,EAAa,SAAA,EAAW,YACrCwL,IAAasE,EAAO,UAAU,SAAS,KAAI/J,EAAW+J,EAAO,UAAU,CAAC,CAAC,GAAG,QAAQ,UACpFrE,IAAeqE,EAAO,YAAY,SAAS,KAAI/J,EAAW+J,EAAO,YAAY,CAAC,CAAC,GAAG,QAAQ,YAC1FhE,IAAW,gBAAgBN,CAAU,IAAIC,CAAY,GAAG,QAAQ,mBAAmB,GAAG;AAC5F,EAAAqE,EAAO,wBAAwBhE,CAAQ,EAAE,MAAM,CAAC+D,MAAe;AAC7D,WAAO,MAAMA,EAAI,WAAW,qCAAqC;AAAA,EACnE,CAAC;AACH,CAAC;AAEDN,EAAG,mCAAmC,CAAC,EAAE,MAAAI,GAAM,OAAAvU,QAA6C;AAC1F,QAAM0U,IAASF,EAAU,SAAA,EAAW,QAAQD,CAAI,GAC1C5J,IAAa/F,EAAa,SAAA,EAAW,YACrCwL,IAAasE,EAAO,UAAU,SAAS,KAAI/J,EAAW+J,EAAO,UAAU,CAAC,CAAC,GAAG,QAAQ,UACpFrE,IAAeqE,EAAO,YAAY,SAAS,KAAI/J,EAAW+J,EAAO,YAAY,CAAC,CAAC,GAAG,QAAQ,YAC1FhE,IAAW,qBAAqBN,CAAU,IAAIC,CAAY,GAAG,QAAQ,mBAAmB,GAAG;AACjG,EAAAqE,EAAO,iCAAiChE,GAAU1Q,CAAK,EAAE,MAAM,CAACyU,MAAe;AAC7E,WAAO,MAAMA,EAAI,WAAW,+CAA+C;AAAA,EAC7E,CAAC;AACH,CAAC;AAEDN,EAAG,8BAA8B,CAAC,EAAE,MAAAI,GAAM,OAAAvU,QAA6C;AAErF,EADewU,EAAU,SAAA,EAAW,QAAQD,CAAI,EACzC,4BAA4BvU,CAAK,EAAE,MAAM,CAACyU,MAAe;AAC9D,WAAO,MAAMA,EAAI,WAAW,0CAA0C;AAAA,EACxE,CAAC;AACH,CAAC;AAEDN,EAAG,kCAAkC,CAAC,EAAE,MAAAI,GAAM,OAAAvU,QAA6C;AACzF,QAAM0U,IAASF,EAAU,SAAA,EAAW,QAAQD,CAAI,GAC1C5J,IAAa/F,EAAa,SAAA,EAAW,YACrCwL,IAAasE,EAAO,UAAU,SAAS,KAAI/J,EAAW+J,EAAO,UAAU,CAAC,CAAC,GAAG,QAAQ,UACpFrE,IAAeqE,EAAO,YAAY,SAAS,KAAI/J,EAAW+J,EAAO,YAAY,CAAC,CAAC,GAAG,QAAQ,YAC1FhE,IAAW,gBAAgBN,CAAU,IAAIC,CAAY,GAAG,QAAQ,mBAAmB,GAAG;AAC5F,EAAAqE,EAAO,gCAAgChE,GAAU1Q,CAAK,EAAE,MAAM,CAACyU,MAAe;AAC5E,WAAO,MAAMA,EAAI,WAAW,8CAA8C;AAAA,EAC5E,CAAC;AACH,CAAC;AAEDN,EAAG,gCAAgC,CAACI,MAAiB;AACnD,QAAMG,IAASF,EAAU,SAAA,EAAW,QAAQD,CAAI,GAC1C5J,IAAa/F,EAAa,SAAA,EAAW,YACrCwL,IAAasE,EAAO,UAAU,SAAS,KAAI/J,EAAW+J,EAAO,UAAU,CAAC,CAAC,GAAG,QAAQ,UACpFrE,IAAeqE,EAAO,YAAY,SAAS,KAAI/J,EAAW+J,EAAO,YAAY,CAAC,CAAC,GAAG,QAAQ,YAC1FhE,IAAW,gBAAgBN,CAAU,IAAIC,CAAY,GAAG,QAAQ,mBAAmB,GAAG;AAC5F,MAAI;AACF,IAAAqE,EAAO,qBAAqBhE,CAAQ;AAAA,EACtC,SAAS+D,GAAU;AACjB,WAAO,MAAMA,EAAI,WAAW,kDAAkD;AAAA,EAChF;AACF,CAAC;AAEDN,EAAG,4BAA4B,CAACI,MAAiB;AAE/C,EADeC,EAAU,SAAA,EAAW,QAAQD,CAAI,EACzC,mBAAA;AACT,CAAC;AAEDJ,EAAG,wBAAwB,MAAM;AAC/B,EAAA1Q,EAAK,iBAAiB,MAAS;AACjC,CAAC;","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}