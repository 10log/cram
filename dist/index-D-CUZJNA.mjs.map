{"version":3,"file":"index-D-CUZJNA.mjs","sources":["../node_modules/beam-trace/dist/core/vector3.js","../node_modules/beam-trace/dist/core/plane3d.js","../node_modules/beam-trace/dist/geometry/polygon3d.js","../node_modules/beam-trace/dist/geometry/polygon-split.js","../node_modules/beam-trace/dist/geometry/clipping3d.js","../node_modules/beam-trace/dist/structures/bsp3d.js","../node_modules/beam-trace/dist/structures/beam3d.js","../node_modules/beam-trace/dist/structures/beamtree3d.js","../node_modules/beam-trace/dist/optimization/failplane3d.js","../node_modules/beam-trace/dist/optimization/skipsphere3d.js","../node_modules/beam-trace/dist/solver/solver3d.js","../node_modules/beam-trace/dist/beamtrace3d.js","../src/compute/beam-trace/index.ts"],"sourcesContent":["/**\n * 3D Vector operations for BeamTrace3D\n *\n * Vectors are represented as [x, y, z] tuples for performance.\n */\nexport const Vector3 = {\n    /**\n     * Create a new Vector3\n     */\n    create(x, y, z) {\n        return [x, y, z];\n    },\n    /**\n     * Create a zero vector\n     */\n    zero() {\n        return [0, 0, 0];\n    },\n    /**\n     * Clone a vector\n     */\n    clone(v) {\n        return [v[0], v[1], v[2]];\n    },\n    /**\n     * Add two vectors\n     */\n    add(a, b) {\n        return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\n    },\n    /**\n     * Subtract vector b from vector a\n     */\n    subtract(a, b) {\n        return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n    },\n    /**\n     * Scale a vector by a scalar\n     */\n    scale(v, s) {\n        return [v[0] * s, v[1] * s, v[2] * s];\n    },\n    /**\n     * Negate a vector\n     */\n    negate(v) {\n        return [-v[0], -v[1], -v[2]];\n    },\n    /**\n     * Dot product of two vectors\n     */\n    dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    },\n    /**\n     * Cross product of two vectors (a × b)\n     */\n    cross(a, b) {\n        return [\n            a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0]\n        ];\n    },\n    /**\n     * Squared length of a vector\n     */\n    lengthSquared(v) {\n        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n    },\n    /**\n     * Length (magnitude) of a vector\n     */\n    length(v) {\n        return Math.sqrt(Vector3.lengthSquared(v));\n    },\n    /**\n     * Normalize a vector to unit length\n     * Returns zero vector if input has zero length\n     */\n    normalize(v) {\n        const len = Vector3.length(v);\n        if (len < 1e-10)\n            return [0, 0, 0];\n        return [v[0] / len, v[1] / len, v[2] / len];\n    },\n    /**\n     * Linear interpolation between two vectors\n     */\n    lerp(a, b, t) {\n        return [\n            a[0] + t * (b[0] - a[0]),\n            a[1] + t * (b[1] - a[1]),\n            a[2] + t * (b[2] - a[2])\n        ];\n    },\n    /**\n     * Distance between two points\n     */\n    distance(a, b) {\n        return Vector3.length(Vector3.subtract(a, b));\n    },\n    /**\n     * Squared distance between two points (faster than distance)\n     */\n    distanceSquared(a, b) {\n        return Vector3.lengthSquared(Vector3.subtract(a, b));\n    },\n    /**\n     * Check if two vectors are approximately equal\n     */\n    equals(a, b, epsilon = 1e-10) {\n        return Math.abs(a[0] - b[0]) < epsilon &&\n            Math.abs(a[1] - b[1]) < epsilon &&\n            Math.abs(a[2] - b[2]) < epsilon;\n    },\n    /**\n     * Component-wise minimum\n     */\n    min(a, b) {\n        return [\n            Math.min(a[0], b[0]),\n            Math.min(a[1], b[1]),\n            Math.min(a[2], b[2])\n        ];\n    },\n    /**\n     * Component-wise maximum\n     */\n    max(a, b) {\n        return [\n            Math.max(a[0], b[0]),\n            Math.max(a[1], b[1]),\n            Math.max(a[2], b[2])\n        ];\n    },\n    /**\n     * Reflect vector v across a plane with given normal\n     * v' = v - 2(v·n)n\n     */\n    reflect(v, normal) {\n        const d = 2 * Vector3.dot(v, normal);\n        return Vector3.subtract(v, Vector3.scale(normal, d));\n    },\n    /**\n     * Project vector a onto vector b\n     */\n    project(a, b) {\n        const bLenSq = Vector3.lengthSquared(b);\n        if (bLenSq < 1e-10)\n            return [0, 0, 0];\n        const scale = Vector3.dot(a, b) / bLenSq;\n        return Vector3.scale(b, scale);\n    },\n    /**\n     * Get the component of a perpendicular to b\n     */\n    reject(a, b) {\n        return Vector3.subtract(a, Vector3.project(a, b));\n    },\n    /**\n     * Convert to string for debugging\n     */\n    toString(v, precision = 4) {\n        return `[${v[0].toFixed(precision)}, ${v[1].toFixed(precision)}, ${v[2].toFixed(precision)}]`;\n    }\n};\n//# sourceMappingURL=vector3.js.map","/**\n * 3D Plane representation and operations for BeamTrace3D\n *\n * Plane is represented in implicit form: ax + by + cz + d = 0\n * where [a, b, c] is the normalized normal vector and d is the distance term.\n *\n * Points in front of the plane (positive side) satisfy ax + by + cz + d > 0\n */\nimport { Vector3 } from './vector3';\nexport const Plane3D = {\n    /**\n     * Create a plane from a normal vector and a point on the plane\n     */\n    fromNormalAndPoint(normal, point) {\n        const n = Vector3.normalize(normal);\n        const d = -Vector3.dot(n, point);\n        return { a: n[0], b: n[1], c: n[2], d };\n    },\n    /**\n     * Create a plane from three non-collinear points\n     * Uses counter-clockwise winding order: normal points toward viewer when\n     * p1 → p2 → p3 appears counter-clockwise\n     */\n    fromPoints(p1, p2, p3) {\n        const v1 = Vector3.subtract(p2, p1);\n        const v2 = Vector3.subtract(p3, p1);\n        const normal = Vector3.normalize(Vector3.cross(v1, v2));\n        return Plane3D.fromNormalAndPoint(normal, p1);\n    },\n    /**\n     * Create a plane directly from coefficients\n     */\n    create(a, b, c, d) {\n        return { a, b, c, d };\n    },\n    /**\n     * Get the normal vector of the plane\n     */\n    normal(plane) {\n        return [plane.a, plane.b, plane.c];\n    },\n    /**\n     * Signed distance from a point to the plane\n     * Positive = point is in front (on normal side)\n     * Negative = point is behind\n     * Zero = point is on the plane\n     */\n    signedDistance(point, plane) {\n        return plane.a * point[0] + plane.b * point[1] + plane.c * point[2] + plane.d;\n    },\n    /**\n     * Absolute distance from a point to the plane\n     */\n    distance(point, plane) {\n        return Math.abs(Plane3D.signedDistance(point, plane));\n    },\n    /**\n     * Classify a point relative to the plane\n     */\n    classifyPoint(point, plane, epsilon = 1e-6) {\n        const dist = Plane3D.signedDistance(point, plane);\n        if (dist > epsilon)\n            return 'front';\n        if (dist < -epsilon)\n            return 'back';\n        return 'on';\n    },\n    /**\n     * Check if a point is in front of the plane\n     */\n    isPointInFront(point, plane, epsilon = 1e-6) {\n        return Plane3D.signedDistance(point, plane) > epsilon;\n    },\n    /**\n     * Check if a point is behind the plane\n     */\n    isPointBehind(point, plane, epsilon = 1e-6) {\n        return Plane3D.signedDistance(point, plane) < -epsilon;\n    },\n    /**\n     * Check if a point is on the plane\n     */\n    isPointOn(point, plane, epsilon = 1e-6) {\n        return Math.abs(Plane3D.signedDistance(point, plane)) <= epsilon;\n    },\n    /**\n     * Mirror a point across the plane\n     * p' = p - 2 * signedDistance(p) * normal\n     */\n    mirrorPoint(point, plane) {\n        const dist = Plane3D.signedDistance(point, plane);\n        const normal = Plane3D.normal(plane);\n        return Vector3.subtract(point, Vector3.scale(normal, 2 * dist));\n    },\n    /**\n     * Mirror a plane across another plane (for fail plane propagation)\n     * This mirrors two points on the source plane and reconstructs.\n     */\n    mirrorPlane(planeToMirror, mirrorPlane) {\n        const n = Plane3D.normal(planeToMirror);\n        // Find a point on planeToMirror\n        let p1;\n        if (Math.abs(n[2]) > 0.5) {\n            p1 = [0, 0, -planeToMirror.d / planeToMirror.c];\n        }\n        else if (Math.abs(n[1]) > 0.5) {\n            p1 = [0, -planeToMirror.d / planeToMirror.b, 0];\n        }\n        else {\n            p1 = [-planeToMirror.d / planeToMirror.a, 0, 0];\n        }\n        // Second point offset along a tangent\n        const offset = Math.abs(n[0]) < 0.9 ? [1, 0, 0] : [0, 1, 0];\n        const tangent = Vector3.normalize(Vector3.cross(n, offset));\n        const p2 = Vector3.add(p1, tangent);\n        // Third point along bitangent\n        const bitangent = Vector3.cross(n, tangent);\n        const p3 = Vector3.add(p1, bitangent);\n        // Mirror all three points\n        const p1m = Plane3D.mirrorPoint(p1, mirrorPlane);\n        const p2m = Plane3D.mirrorPoint(p2, mirrorPlane);\n        const p3m = Plane3D.mirrorPoint(p3, mirrorPlane);\n        return Plane3D.fromPoints(p1m, p2m, p3m);\n    },\n    /**\n     * Flip the plane orientation (negate normal and d)\n     */\n    flip(plane) {\n        return { a: -plane.a, b: -plane.b, c: -plane.c, d: -plane.d };\n    },\n    /**\n     * Ray-plane intersection\n     *\n     * Returns the t parameter along the ray where intersection occurs,\n     * or null if the ray is parallel to the plane.\n     *\n     * Point of intersection = rayOrigin + t * rayDirection\n     *\n     * @param rayOrigin - Starting point of the ray\n     * @param rayDirection - Direction of the ray (should be normalized for t to represent distance)\n     * @param plane - The plane to intersect with\n     */\n    rayIntersection(rayOrigin, rayDirection, plane) {\n        const normal = Plane3D.normal(plane);\n        const denom = Vector3.dot(normal, rayDirection);\n        if (Math.abs(denom) < 1e-10) {\n            return null; // Ray is parallel to plane\n        }\n        const t = -(Vector3.dot(normal, rayOrigin) + plane.d) / denom;\n        return t;\n    },\n    /**\n     * Get the point of intersection between a ray and plane\n     */\n    rayIntersectionPoint(rayOrigin, rayDirection, plane) {\n        const t = Plane3D.rayIntersection(rayOrigin, rayDirection, plane);\n        if (t === null)\n            return null;\n        return Vector3.add(rayOrigin, Vector3.scale(rayDirection, t));\n    },\n    /**\n     * Project a point onto the plane\n     */\n    projectPoint(point, plane) {\n        const dist = Plane3D.signedDistance(point, plane);\n        const normal = Plane3D.normal(plane);\n        return Vector3.subtract(point, Vector3.scale(normal, dist));\n    },\n    /**\n     * Check if two planes are approximately equal\n     */\n    equals(a, b, epsilon = 1e-6) {\n        // Planes are equal if normals are parallel and d values are equal (or negated)\n        const dotNormals = a.a * b.a + a.b * b.b + a.c * b.c;\n        if (Math.abs(dotNormals - 1) < epsilon) {\n            // Same orientation\n            return Math.abs(a.d - b.d) < epsilon;\n        }\n        if (Math.abs(dotNormals + 1) < epsilon) {\n            // Opposite orientation\n            return Math.abs(a.d + b.d) < epsilon;\n        }\n        return false;\n    },\n    /**\n     * Convert to string for debugging\n     */\n    toString(plane, precision = 4) {\n        return `Plane3D(${plane.a.toFixed(precision)}x + ${plane.b.toFixed(precision)}y + ${plane.c.toFixed(precision)}z + ${plane.d.toFixed(precision)} = 0)`;\n    }\n};\n//# sourceMappingURL=plane3d.js.map","/**\n * 3D Polygon representation and operations for BeamTrace3D\n *\n * Polygons are convex and stored with counter-clockwise vertex winding\n * when viewed from the front (normal) side.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nexport const Polygon3D = {\n    /**\n     * Create a polygon from vertices (computes plane automatically)\n     * Vertices must be in counter-clockwise order when viewed from front\n     */\n    create(vertices, materialId) {\n        if (vertices.length < 3) {\n            throw new Error('Polygon requires at least 3 vertices');\n        }\n        // Clone vertices to prevent external mutation\n        const verts = vertices.map(v => Vector3.clone(v));\n        const plane = Plane3D.fromPoints(verts[0], verts[1], verts[2]);\n        return { vertices: verts, plane, materialId };\n    },\n    /**\n     * Create a polygon with an explicit plane (for split polygons that may be degenerate)\n     */\n    createWithPlane(vertices, plane, materialId) {\n        if (vertices.length < 3) {\n            throw new Error('Polygon requires at least 3 vertices');\n        }\n        const verts = vertices.map(v => Vector3.clone(v));\n        return { vertices: verts, plane, materialId };\n    },\n    /**\n     * Get the number of vertices\n     */\n    vertexCount(poly) {\n        return poly.vertices.length;\n    },\n    /**\n     * Compute the centroid (geometric center) of the polygon\n     */\n    centroid(poly) {\n        const sum = [0, 0, 0];\n        for (const v of poly.vertices) {\n            sum[0] += v[0];\n            sum[1] += v[1];\n            sum[2] += v[2];\n        }\n        const n = poly.vertices.length;\n        return [sum[0] / n, sum[1] / n, sum[2] / n];\n    },\n    /**\n     * Compute the area of the polygon using cross product method\n     */\n    area(poly) {\n        if (poly.vertices.length < 3)\n            return 0;\n        let total = [0, 0, 0];\n        const v0 = poly.vertices[0];\n        for (let i = 1; i < poly.vertices.length - 1; i++) {\n            const v1 = poly.vertices[i];\n            const v2 = poly.vertices[i + 1];\n            const cross = Vector3.cross(Vector3.subtract(v1, v0), Vector3.subtract(v2, v0));\n            total = Vector3.add(total, cross);\n        }\n        return 0.5 * Vector3.length(total);\n    },\n    /**\n     * Get the normal vector of the polygon (from the plane)\n     */\n    normal(poly) {\n        return Plane3D.normal(poly.plane);\n    },\n    /**\n     * Get edges as pairs of vertices [start, end]\n     */\n    edges(poly) {\n        const result = [];\n        for (let i = 0; i < poly.vertices.length; i++) {\n            const next = (i + 1) % poly.vertices.length;\n            result.push([poly.vertices[i], poly.vertices[next]]);\n        }\n        return result;\n    },\n    /**\n     * Classify the polygon relative to a plane\n     */\n    classify(poly, plane, epsilon = 1e-6) {\n        let front = 0;\n        let back = 0;\n        for (const v of poly.vertices) {\n            const classification = Plane3D.classifyPoint(v, plane, epsilon);\n            if (classification === 'front')\n                front++;\n            else if (classification === 'back')\n                back++;\n        }\n        if (front > 0 && back > 0)\n            return 'spanning';\n        if (front > 0)\n            return 'front';\n        if (back > 0)\n            return 'back';\n        return 'coplanar';\n    },\n    /**\n     * Check if a point is inside the polygon\n     * Assumes the point is on (or very close to) the polygon's plane\n     */\n    containsPoint(poly, point, epsilon = 1e-6) {\n        const normal = Plane3D.normal(poly.plane);\n        const n = poly.vertices.length;\n        for (let i = 0; i < n; i++) {\n            const v1 = poly.vertices[i];\n            const v2 = poly.vertices[(i + 1) % n];\n            const edge = Vector3.subtract(v2, v1);\n            const toPoint = Vector3.subtract(point, v1);\n            const cross = Vector3.cross(edge, toPoint);\n            // If cross product points opposite to normal, point is outside this edge\n            if (Vector3.dot(cross, normal) < -epsilon) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\n     * Ray-polygon intersection\n     * Returns t parameter and intersection point, or null if no hit\n     */\n    rayIntersection(rayOrigin, rayDirection, poly) {\n        const t = Plane3D.rayIntersection(rayOrigin, rayDirection, poly.plane);\n        if (t === null || t < 0) {\n            return null;\n        }\n        const point = Vector3.add(rayOrigin, Vector3.scale(rayDirection, t));\n        if (!Polygon3D.containsPoint(poly, point)) {\n            return null;\n        }\n        return { t, point };\n    },\n    /**\n     * Create a bounding box for the polygon\n     */\n    boundingBox(poly) {\n        const min = [Infinity, Infinity, Infinity];\n        const max = [-Infinity, -Infinity, -Infinity];\n        for (const v of poly.vertices) {\n            min[0] = Math.min(min[0], v[0]);\n            min[1] = Math.min(min[1], v[1]);\n            min[2] = Math.min(min[2], v[2]);\n            max[0] = Math.max(max[0], v[0]);\n            max[1] = Math.max(max[1], v[1]);\n            max[2] = Math.max(max[2], v[2]);\n        }\n        return { min, max };\n    },\n    /**\n     * Check if polygon is degenerate (zero or near-zero area)\n     */\n    isDegenerate(poly, areaThreshold = 1e-10) {\n        return poly.vertices.length < 3 || Polygon3D.area(poly) < areaThreshold;\n    },\n    /**\n     * Flip the polygon winding (reverse vertex order and flip plane)\n     */\n    flip(poly) {\n        const reversedVerts = [...poly.vertices].reverse();\n        const flippedPlane = Plane3D.flip(poly.plane);\n        return {\n            vertices: reversedVerts,\n            plane: flippedPlane,\n            materialId: poly.materialId\n        };\n    },\n    /**\n     * Clone a polygon\n     */\n    clone(poly) {\n        return {\n            vertices: poly.vertices.map(v => Vector3.clone(v)),\n            plane: { ...poly.plane },\n            materialId: poly.materialId\n        };\n    },\n    /**\n     * Convert to string for debugging\n     */\n    toString(poly) {\n        const verts = poly.vertices.map(v => Vector3.toString(v, 2)).join(', ');\n        return `Polygon3D(${poly.vertices.length} vertices: [${verts}])`;\n    }\n};\n/**\n * Helper to create common room shapes\n */\nexport function createQuad(p1, p2, p3, p4, materialId) {\n    return Polygon3D.create([p1, p2, p3, p4], materialId);\n}\n/**\n * Create a shoebox room (6 walls as polygons)\n * Origin is at one corner, room extends in positive x, y, z\n */\nexport function createShoeboxRoom(width, // x dimension\ndepth, // y dimension\nheight, // z dimension\nfloorMaterial, ceilingMaterial, wallMaterial) {\n    // Corners\n    const v000 = [0, 0, 0];\n    const v100 = [width, 0, 0];\n    const v010 = [0, depth, 0];\n    const v110 = [width, depth, 0];\n    const v001 = [0, 0, height];\n    const v101 = [width, 0, height];\n    const v011 = [0, depth, height];\n    const v111 = [width, depth, height];\n    return [\n        // Floor (normal pointing up, CCW when viewed from above)\n        Polygon3D.create([v000, v100, v110, v010], floorMaterial),\n        // Ceiling (normal pointing down, CCW when viewed from below)\n        Polygon3D.create([v001, v011, v111, v101], ceilingMaterial),\n        // Front wall (y = 0, normal pointing +y)\n        Polygon3D.create([v000, v001, v101, v100], wallMaterial),\n        // Back wall (y = depth, normal pointing -y)\n        Polygon3D.create([v010, v110, v111, v011], wallMaterial),\n        // Left wall (x = 0, normal pointing +x)\n        Polygon3D.create([v000, v010, v011, v001], wallMaterial),\n        // Right wall (x = width, normal pointing -x)\n        Polygon3D.create([v100, v101, v111, v110], wallMaterial)\n    ];\n}\n//# sourceMappingURL=polygon3d.js.map","/**\n * Polygon splitting for BSP tree construction\n *\n * Splits a polygon by a plane into front and back pieces.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from './polygon3d';\n/**\n * Split a polygon by a plane\n *\n * Returns front and back pieces. Either may be null if the polygon\n * is entirely on one side of the plane.\n *\n * @param poly - The polygon to split\n * @param plane - The splitting plane\n * @param epsilon - Tolerance for point-on-plane classification\n */\nexport function splitPolygon(poly, plane, epsilon = 1e-6) {\n    const classification = Polygon3D.classify(poly, plane, epsilon);\n    // Fast path: polygon entirely on one side\n    if (classification === 'front' || classification === 'coplanar') {\n        return { front: poly, back: null };\n    }\n    if (classification === 'back') {\n        return { front: null, back: poly };\n    }\n    // Polygon spans the plane - need to split\n    const frontVerts = [];\n    const backVerts = [];\n    const n = poly.vertices.length;\n    for (let i = 0; i < n; i++) {\n        const v1 = poly.vertices[i];\n        const v2 = poly.vertices[(i + 1) % n];\n        const d1 = Plane3D.signedDistance(v1, plane);\n        const d2 = Plane3D.signedDistance(v2, plane);\n        const c1 = d1 > epsilon ? 'front' : d1 < -epsilon ? 'back' : 'on';\n        const c2 = d2 > epsilon ? 'front' : d2 < -epsilon ? 'back' : 'on';\n        // Add v1 to appropriate list(s)\n        if (c1 === 'front') {\n            frontVerts.push(v1);\n        }\n        else if (c1 === 'back') {\n            backVerts.push(v1);\n        }\n        else {\n            // On the plane - add to both sides\n            frontVerts.push(v1);\n            backVerts.push(v1);\n        }\n        // Check if edge crosses the plane\n        if ((c1 === 'front' && c2 === 'back') || (c1 === 'back' && c2 === 'front')) {\n            // Compute intersection point\n            const t = d1 / (d1 - d2);\n            const intersection = Vector3.lerp(v1, v2, t);\n            // Add intersection to both sides\n            frontVerts.push(intersection);\n            backVerts.push(intersection);\n        }\n    }\n    // Create result polygons if they have at least 3 vertices\n    const front = frontVerts.length >= 3\n        ? Polygon3D.createWithPlane(frontVerts, poly.plane, poly.materialId)\n        : null;\n    const back = backVerts.length >= 3\n        ? Polygon3D.createWithPlane(backVerts, poly.plane, poly.materialId)\n        : null;\n    return { front, back };\n}\n/**\n * Split multiple polygons by a plane\n *\n * Useful for BSP tree construction where multiple polygons need to be\n * partitioned by the same splitting plane.\n */\nexport function splitPolygons(polygons, plane, epsilon = 1e-6) {\n    const front = [];\n    const back = [];\n    const coplanar = [];\n    for (const poly of polygons) {\n        const classification = Polygon3D.classify(poly, plane, epsilon);\n        switch (classification) {\n            case 'coplanar':\n                coplanar.push(poly);\n                break;\n            case 'front':\n                front.push(poly);\n                break;\n            case 'back':\n                back.push(poly);\n                break;\n            case 'spanning': {\n                const { front: f, back: b } = splitPolygon(poly, plane, epsilon);\n                if (f)\n                    front.push(f);\n                if (b)\n                    back.push(b);\n                break;\n            }\n        }\n    }\n    return { front, back, coplanar };\n}\n//# sourceMappingURL=polygon-split.js.map","/**\n * 3D Polygon clipping using Sutherland-Hodgman algorithm\n *\n * This is the critical algorithm for clipping polygons against beam boundaries.\n * Clips a polygon against one or more planes, keeping the portion on the\n * front (positive) side of each plane.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from './polygon3d';\n/**\n * Clip a polygon against a single plane using Sutherland-Hodgman algorithm\n *\n * Keeps the portion on the FRONT side of the plane (where signedDistance > 0)\n *\n * @param poly - The polygon to clip\n * @param plane - The clipping plane (normal points toward kept region)\n * @param epsilon - Tolerance for point-on-plane classification\n * @returns The clipped polygon, or null if entirely clipped away\n */\nexport function clipPolygonByPlane(poly, plane, epsilon = 1e-6) {\n    const input = poly.vertices;\n    const output = [];\n    if (input.length < 3)\n        return null;\n    for (let i = 0; i < input.length; i++) {\n        const current = input[i];\n        const next = input[(i + 1) % input.length];\n        const dCurrent = Plane3D.signedDistance(current, plane);\n        const dNext = Plane3D.signedDistance(next, plane);\n        // Inside = on front side of plane (dCurrent >= -epsilon)\n        const currentInside = dCurrent >= -epsilon;\n        const nextInside = dNext >= -epsilon;\n        if (currentInside) {\n            // Current vertex is inside - add it\n            output.push(current);\n        }\n        // Check for edge crossing\n        if ((currentInside && !nextInside) || (!currentInside && nextInside)) {\n            // Edge crosses the plane - compute intersection\n            const t = dCurrent / (dCurrent - dNext);\n            const intersection = Vector3.lerp(current, next, Math.max(0, Math.min(1, t)));\n            output.push(intersection);\n        }\n    }\n    if (output.length < 3)\n        return null;\n    return Polygon3D.createWithPlane(output, poly.plane, poly.materialId);\n}\n/**\n * Clip a polygon against multiple planes (e.g., beam boundaries)\n *\n * The polygon must be on the front side of ALL planes to survive.\n * This is iterative Sutherland-Hodgman clipping.\n *\n * @param poly - The polygon to clip\n * @param planes - Array of clipping planes\n * @param epsilon - Tolerance for classification\n * @returns The clipped polygon, or null if entirely clipped away\n */\nexport function clipPolygonByPlanes(poly, planes, epsilon = 1e-6) {\n    let current = poly;\n    for (const plane of planes) {\n        if (!current)\n            return null;\n        current = clipPolygonByPlane(current, plane, epsilon);\n    }\n    return current;\n}\n/**\n * Quick rejection test - check if polygon is entirely outside any clipping plane\n *\n * This is faster than full clipping when we only need to know if the result\n * would be non-empty.\n *\n * @param poly - The polygon to test\n * @param planes - Array of clipping planes\n * @param epsilon - Tolerance for classification\n * @returns true if polygon is entirely outside at least one plane\n */\nexport function quickRejectPolygon(poly, planes, epsilon = 1e-6) {\n    for (const plane of planes) {\n        let allBehind = true;\n        for (const v of poly.vertices) {\n            if (Plane3D.signedDistance(v, plane) >= -epsilon) {\n                allBehind = false;\n                break;\n            }\n        }\n        if (allBehind) {\n            return true; // Polygon is entirely behind this plane\n        }\n    }\n    return false;\n}\n/**\n * Check if a polygon potentially intersects a convex volume defined by planes\n *\n * Returns false if the polygon is definitely outside the volume.\n * Returns true if it might be inside (requires full clipping to confirm).\n *\n * @param poly - The polygon to test\n * @param planes - Array of planes defining the convex volume (normals point inward)\n * @param epsilon - Tolerance for classification\n */\nexport function polygonMayIntersectVolume(poly, planes, epsilon = 1e-6) {\n    // Polygon is definitely outside if all vertices are behind any single plane\n    return !quickRejectPolygon(poly, planes, epsilon);\n}\n/**\n * Clip a polygon against a frustum (beam volume)\n *\n * A frustum is defined by multiple boundary planes. For beam tracing,\n * this is typically N edge planes + 1 aperture plane.\n *\n * @param poly - The polygon to clip\n * @param frustumPlanes - Array of planes defining the frustum (normals point inward)\n * @param epsilon - Tolerance for classification\n * @returns The clipped polygon, or null if entirely outside the frustum\n */\nexport function clipPolygonByFrustum(poly, frustumPlanes, epsilon = 1e-6) {\n    // Quick rejection first\n    if (quickRejectPolygon(poly, frustumPlanes, epsilon)) {\n        return null;\n    }\n    // Full clip\n    return clipPolygonByPlanes(poly, frustumPlanes, epsilon);\n}\n/**\n * Clip a ray segment against a convex volume defined by planes\n *\n * Returns the clipped segment [tMin, tMax] or null if ray misses the volume.\n *\n * @param rayOrigin - Start of the ray\n * @param rayDirection - Direction of the ray (normalized)\n * @param planes - Planes defining the convex volume (normals point inward)\n * @param tStart - Starting t value (default 0)\n * @param tEnd - Ending t value (default Infinity)\n */\nexport function clipRayByPlanes(rayOrigin, rayDirection, planes, tStart = 0, tEnd = Infinity) {\n    let tMin = tStart;\n    let tMax = tEnd;\n    for (const plane of planes) {\n        const normal = Plane3D.normal(plane);\n        const denom = Vector3.dot(normal, rayDirection);\n        const dist = Plane3D.signedDistance(rayOrigin, plane);\n        if (Math.abs(denom) < 1e-10) {\n            // Ray parallel to plane\n            if (dist < 0) {\n                // Ray origin is behind the plane - ray is outside\n                return null;\n            }\n            // Ray origin is in front - continue\n            continue;\n        }\n        const t = -dist / denom;\n        if (denom > 0) {\n            // Ray is going in the direction of the normal\n            if (dist >= 0) {\n                // Starting in front, ray goes further in front - no exit through this plane\n                // (t would be negative, meaning the plane is behind us)\n                // No constraint needed\n            }\n            else {\n                // Starting behind, ray will enter at t\n                tMin = Math.max(tMin, t);\n            }\n        }\n        else {\n            // Ray is going against the normal (denom < 0)\n            if (dist >= 0) {\n                // Starting in front, ray goes toward the plane and will exit at t\n                tMax = Math.min(tMax, t);\n            }\n            else {\n                // Starting behind, going further behind - ray never enters\n                return null;\n            }\n        }\n        if (tMin > tMax) {\n            return null; // Ray misses the volume\n        }\n    }\n    // Make sure tMax is positive (ray goes forward)\n    if (tMax < 0) {\n        return null;\n    }\n    // Clamp tMin to 0 if it's negative\n    tMin = Math.max(0, tMin);\n    if (tMin > tMax) {\n        return null;\n    }\n    return { tMin, tMax };\n}\n//# sourceMappingURL=clipping3d.js.map","/**\n * 3D Binary Space Partitioning (BSP) Tree\n *\n * Used for accelerated ray-polygon intersection queries.\n * Provides O(log n) ray tracing instead of O(n) brute force.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { splitPolygon } from '../geometry/polygon-split';\n/**\n * Build a BSP tree from an array of polygons\n *\n * @param polygons - Array of polygons to partition\n * @returns Root node of the BSP tree, or null if empty\n */\nexport function buildBSP(polygons) {\n    if (polygons.length === 0)\n        return null;\n    // Create indexed polygons to track original IDs through splits\n    const indexed = polygons.map((polygon, i) => ({\n        polygon,\n        originalId: i\n    }));\n    return buildBSPRecursive(indexed);\n}\n/**\n * Recursive BSP construction\n */\nfunction buildBSPRecursive(polygons) {\n    if (polygons.length === 0)\n        return null;\n    // Choose splitting polygon using heuristic\n    const splitterIndex = chooseSplitter(polygons);\n    const splitter = polygons[splitterIndex];\n    const plane = splitter.polygon.plane;\n    const frontPolys = [];\n    const backPolys = [];\n    // Partition remaining polygons\n    for (let i = 0; i < polygons.length; i++) {\n        if (i === splitterIndex)\n            continue;\n        const indexed = polygons[i];\n        const { front, back } = splitPolygon(indexed.polygon, plane);\n        // Preserve original ID through splits\n        if (front) {\n            frontPolys.push({ polygon: front, originalId: indexed.originalId });\n        }\n        if (back) {\n            backPolys.push({ polygon: back, originalId: indexed.originalId });\n        }\n    }\n    return {\n        plane,\n        polygon: splitter.polygon,\n        polygonId: splitter.originalId,\n        front: buildBSPRecursive(frontPolys),\n        back: buildBSPRecursive(backPolys)\n    };\n}\n/**\n * Choose the best splitting polygon using balance + split minimization heuristic\n *\n * The goal is to minimize:\n * 1. Number of polygon splits (expensive)\n * 2. Tree imbalance (affects query performance)\n */\nfunction chooseSplitter(polygons) {\n    if (polygons.length <= 3)\n        return 0;\n    let bestIndex = 0;\n    let bestScore = Infinity;\n    // Sample a subset for large polygon counts\n    const sampleSize = Math.min(polygons.length, 10);\n    const step = Math.max(1, Math.floor(polygons.length / sampleSize));\n    for (let i = 0; i < polygons.length; i += step) {\n        const plane = polygons[i].polygon.plane;\n        let front = 0;\n        let back = 0;\n        let splits = 0;\n        for (let j = 0; j < polygons.length; j++) {\n            if (i === j)\n                continue;\n            const classification = Polygon3D.classify(polygons[j].polygon, plane);\n            if (classification === 'front') {\n                front++;\n            }\n            else if (classification === 'back') {\n                back++;\n            }\n            else if (classification === 'spanning') {\n                front++;\n                back++;\n                splits++;\n            }\n            // coplanar polygons don't affect the score\n        }\n        // Score: heavily penalize splits, then minimize imbalance\n        const score = splits * 8 + Math.abs(front - back);\n        if (score < bestScore) {\n            bestScore = score;\n            bestIndex = i;\n        }\n    }\n    return bestIndex;\n}\n/**\n * Trace a ray through the BSP tree and find the first intersection\n *\n * @param origin - Ray origin point\n * @param direction - Ray direction (should be normalized for t to be distance)\n * @param node - BSP tree root node\n * @param tMin - Minimum t value to consider\n * @param tMax - Maximum t value to consider\n * @param ignoreId - Polygon ID to ignore (for avoiding self-intersection)\n * @returns First hit along the ray, or null if no hit\n */\nexport function rayTraceBSP(origin, direction, node, tMin = 0, tMax = Infinity, ignoreId = -1) {\n    if (!node)\n        return null;\n    // Classify ray origin relative to splitting plane\n    const dOrigin = Plane3D.signedDistance(origin, node.plane);\n    const normal = Plane3D.normal(node.plane);\n    const dDir = Vector3.dot(normal, direction);\n    // Determine near and far subtrees based on ray origin position\n    let near;\n    let far;\n    if (dOrigin >= 0) {\n        near = node.front;\n        far = node.back;\n    }\n    else {\n        near = node.back;\n        far = node.front;\n    }\n    // Calculate intersection with splitting plane\n    let tSplit = null;\n    if (Math.abs(dDir) > 1e-10) {\n        tSplit = -dOrigin / dDir;\n    }\n    let hit = null;\n    // IMPORTANT: BSP pruning optimization assumes polygons are coplanar with splitting planes.\n    // Since our polygons are finite and may not align with their node's splitting plane,\n    // we must check BOTH subtrees in all cases to ensure correctness.\n    if (tSplit === null || tSplit < tMin) {\n        // Check near side first\n        hit = rayTraceBSP(origin, direction, near, tMin, tMax, ignoreId);\n        // Check this node's polygon\n        if (!hit && node.polygonId !== ignoreId) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        // Also check far side\n        if (!hit) {\n            hit = rayTraceBSP(origin, direction, far, tMin, tMax, ignoreId);\n        }\n    }\n    else if (tSplit > tMax) {\n        // Check near side first\n        hit = rayTraceBSP(origin, direction, near, tMin, tMax, ignoreId);\n        // Check this node's polygon\n        if (!hit && node.polygonId !== ignoreId) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        // Also check far side\n        if (!hit) {\n            hit = rayTraceBSP(origin, direction, far, tMin, tMax, ignoreId);\n        }\n    }\n    else {\n        // Ray crosses the plane - check near side first\n        hit = rayTraceBSP(origin, direction, near, tMin, tSplit, ignoreId);\n        // If no hit in near subtree, check this node's polygon\n        if (!hit && node.polygonId !== ignoreId) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        // If still no hit, check far subtree\n        if (!hit) {\n            hit = rayTraceBSP(origin, direction, far, tSplit, tMax, ignoreId);\n        }\n    }\n    return hit;\n}\n// Debug flag - set to true to trace BSP traversal\nlet bspDebug = false;\nlet bspDebugDepth = 0;\nexport function setBSPDebug(enabled) {\n    bspDebug = enabled;\n    bspDebugDepth = 0;\n}\n/**\n * Trace a ray through the BSP tree, ignoring multiple polygon IDs\n *\n * @param origin - Ray origin point\n * @param direction - Ray direction (should be normalized for t to be distance)\n * @param node - BSP tree root node\n * @param tMin - Minimum t value to consider\n * @param tMax - Maximum t value to consider\n * @param ignoreIds - Set of polygon IDs to ignore\n * @returns First hit along the ray, or null if no hit\n */\nexport function rayTraceBSPMultiIgnore(origin, direction, node, tMin, tMax, ignoreIds) {\n    if (!node)\n        return null;\n    const indent = '  '.repeat(bspDebugDepth);\n    const dOrigin = Plane3D.signedDistance(origin, node.plane);\n    const normal = Plane3D.normal(node.plane);\n    const dDir = Vector3.dot(normal, direction);\n    let near;\n    let far;\n    if (dOrigin >= 0) {\n        near = node.front;\n        far = node.back;\n    }\n    else {\n        near = node.back;\n        far = node.front;\n    }\n    let tSplit = null;\n    if (Math.abs(dDir) > 1e-10) {\n        tSplit = -dOrigin / dDir;\n    }\n    if (bspDebug) {\n        console.log(`${indent}[BSP] Node ${node.polygonId}: dOrigin=${dOrigin.toFixed(3)}, dDir=${dDir.toFixed(3)}, tSplit=${tSplit?.toFixed(3) ?? 'null'}, tMin=${tMin.toFixed(3)}, tMax=${tMax.toFixed(3)}`);\n    }\n    let hit = null;\n    // IMPORTANT: BSP pruning optimization assumes polygons are coplanar with splitting planes.\n    // Since our polygons are finite and may not align with their node's splitting plane,\n    // we must check BOTH subtrees in all cases to ensure correctness.\n    // The tSplit value still helps us order the traversal (near first for early termination).\n    if (tSplit === null || tSplit < tMin) {\n        if (bspDebug) {\n            console.log(`${indent}  Case: tSplit null or < tMin, checking near then far`);\n        }\n        // Check near side first\n        bspDebugDepth++;\n        hit = rayTraceBSPMultiIgnore(origin, direction, near, tMin, tMax, ignoreIds);\n        bspDebugDepth--;\n        // Check this node's polygon\n        if (!hit && !ignoreIds.has(node.polygonId)) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (bspDebug) {\n                console.log(`${indent}  Checking node polygon ${node.polygonId}: ${polyHit ? `HIT t=${polyHit.t.toFixed(3)}` : 'NO HIT'}`);\n                if (polyHit) {\n                    console.log(`${indent}    In range [${tMin.toFixed(3)}, ${tMax.toFixed(3)}]? ${polyHit.t >= tMin && polyHit.t <= tMax}`);\n                }\n            }\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        else if (bspDebug && ignoreIds.has(node.polygonId)) {\n            console.log(`${indent}  Skipping node polygon ${node.polygonId} (in ignoreIds)`);\n        }\n        // Also check far side - polygons there might still intersect the ray\n        if (!hit) {\n            bspDebugDepth++;\n            hit = rayTraceBSPMultiIgnore(origin, direction, far, tMin, tMax, ignoreIds);\n            bspDebugDepth--;\n        }\n    }\n    else if (tSplit > tMax) {\n        if (bspDebug) {\n            console.log(`${indent}  Case: tSplit > tMax, checking near then far`);\n        }\n        // Check near side first\n        bspDebugDepth++;\n        hit = rayTraceBSPMultiIgnore(origin, direction, near, tMin, tMax, ignoreIds);\n        bspDebugDepth--;\n        // Check this node's polygon\n        if (!hit && !ignoreIds.has(node.polygonId)) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (bspDebug) {\n                console.log(`${indent}  Checking node polygon ${node.polygonId}: ${polyHit ? `HIT t=${polyHit.t.toFixed(3)}` : 'NO HIT'}`);\n                if (polyHit) {\n                    console.log(`${indent}    In range [${tMin.toFixed(3)}, ${tMax.toFixed(3)}]? ${polyHit.t >= tMin && polyHit.t <= tMax}`);\n                }\n            }\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        else if (bspDebug && ignoreIds.has(node.polygonId)) {\n            console.log(`${indent}  Skipping node polygon ${node.polygonId} (in ignoreIds)`);\n        }\n        // Also check far side - polygons there might still intersect the ray\n        if (!hit) {\n            bspDebugDepth++;\n            hit = rayTraceBSPMultiIgnore(origin, direction, far, tMin, tMax, ignoreIds);\n            bspDebugDepth--;\n        }\n    }\n    else {\n        if (bspDebug) {\n            console.log(`${indent}  Case: ray crosses plane at tSplit=${tSplit.toFixed(3)}`);\n        }\n        // Ray crosses the plane - check near side first, then node, then far side\n        bspDebugDepth++;\n        hit = rayTraceBSPMultiIgnore(origin, direction, near, tMin, tSplit, ignoreIds);\n        bspDebugDepth--;\n        if (!hit && !ignoreIds.has(node.polygonId)) {\n            const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n            if (bspDebug) {\n                console.log(`${indent}  Checking node polygon ${node.polygonId}: ${polyHit ? `HIT t=${polyHit.t.toFixed(3)}` : 'NO HIT'}`);\n                if (polyHit) {\n                    console.log(`${indent}    In range [${tMin.toFixed(3)}, ${tMax.toFixed(3)}]? ${polyHit.t >= tMin && polyHit.t <= tMax}`);\n                }\n            }\n            if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n                hit = {\n                    t: polyHit.t,\n                    point: polyHit.point,\n                    polygonId: node.polygonId,\n                    polygon: node.polygon\n                };\n            }\n        }\n        else if (bspDebug && ignoreIds.has(node.polygonId)) {\n            console.log(`${indent}  Skipping node polygon ${node.polygonId} (in ignoreIds)`);\n        }\n        if (!hit) {\n            bspDebugDepth++;\n            hit = rayTraceBSPMultiIgnore(origin, direction, far, tSplit, tMax, ignoreIds);\n            bspDebugDepth--;\n        }\n    }\n    if (bspDebug && hit) {\n        console.log(`${indent}  RETURNING HIT: polygon ${hit.polygonId} at t=${hit.t.toFixed(3)}`);\n    }\n    return hit;\n}\n/**\n * Check if a ray hits any polygon (occlusion test)\n *\n * Faster than rayTraceBSP when you only need to know if there's a hit,\n * not which polygon was hit.\n *\n * @param origin - Ray origin\n * @param direction - Ray direction\n * @param node - BSP tree root\n * @param tMin - Minimum t value\n * @param tMax - Maximum t value\n * @param ignoreId - Polygon ID to ignore\n * @returns true if ray hits something\n */\nexport function rayOccluded(origin, direction, node, tMin = 0, tMax = Infinity, ignoreId = -1) {\n    return rayTraceBSP(origin, direction, node, tMin, tMax, ignoreId) !== null;\n}\n/**\n * Find all polygons intersected by a ray (not just the first)\n *\n * Useful for debugging or special effects.\n */\nexport function rayTraceAll(origin, direction, node, tMin = 0, tMax = Infinity, ignoreId = -1) {\n    const hits = [];\n    rayTraceAllRecursive(origin, direction, node, tMin, tMax, ignoreId, hits);\n    // Sort by distance\n    hits.sort((a, b) => a.t - b.t);\n    return hits;\n}\nfunction rayTraceAllRecursive(origin, direction, node, tMin, tMax, ignoreId, hits) {\n    if (!node)\n        return;\n    const dOrigin = Plane3D.signedDistance(origin, node.plane);\n    const normal = Plane3D.normal(node.plane);\n    const dDir = Vector3.dot(normal, direction);\n    let near;\n    let far;\n    if (dOrigin >= 0) {\n        near = node.front;\n        far = node.back;\n    }\n    else {\n        near = node.back;\n        far = node.front;\n    }\n    let tSplit = null;\n    if (Math.abs(dDir) > 1e-10) {\n        tSplit = -dOrigin / dDir;\n    }\n    // Check this node's polygon\n    if (node.polygonId !== ignoreId) {\n        const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n        if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n            hits.push({\n                t: polyHit.t,\n                point: polyHit.point,\n                polygonId: node.polygonId,\n                polygon: node.polygon\n            });\n        }\n    }\n    // Recurse into both subtrees\n    if (tSplit === null || tSplit < tMin) {\n        rayTraceAllRecursive(origin, direction, near, tMin, tMax, ignoreId, hits);\n    }\n    else if (tSplit > tMax) {\n        rayTraceAllRecursive(origin, direction, near, tMin, tMax, ignoreId, hits);\n    }\n    else {\n        rayTraceAllRecursive(origin, direction, near, tMin, tSplit, ignoreId, hits);\n        rayTraceAllRecursive(origin, direction, far, tSplit, tMax, ignoreId, hits);\n    }\n}\n/**\n * Count the total number of nodes in the BSP tree\n */\nexport function countNodes(node) {\n    if (!node)\n        return 0;\n    return 1 + countNodes(node.front) + countNodes(node.back);\n}\n/**\n * Calculate the maximum depth of the BSP tree\n */\nexport function treeDepth(node) {\n    if (!node)\n        return 0;\n    return 1 + Math.max(treeDepth(node.front), treeDepth(node.back));\n}\n//# sourceMappingURL=bsp3d.js.map","/**\n * 3D Beam representation for BeamTrace3D\n *\n * A 3D beam is a polyhedral cone from a virtual source through an aperture polygon.\n * It is bounded by N+1 planes:\n * - N planes (one per aperture edge), with normals pointing INTO the beam\n * - 1 aperture plane, with normal pointing toward the source (INTO the beam)\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from '../geometry/polygon3d';\n/**\n * Construct boundary planes for a 3D beam\n *\n * All normals are oriented to point INTO the beam volume.\n * This means a point is inside the beam if it's on the front side\n * (positive signed distance) of all boundary planes.\n *\n * @param virtualSource - The virtual source position\n * @param aperture - The aperture polygon\n * @returns Array of boundary planes (N edge planes + 1 aperture plane)\n */\nexport function constructBeamBoundaryPlanes(virtualSource, aperture) {\n    const planes = [];\n    const edges = Polygon3D.edges(aperture);\n    const apertureCentroid = Polygon3D.centroid(aperture);\n    // Create a plane for each edge of the aperture\n    // Each plane passes through the virtual source and the edge vertices\n    for (const [v1, v2] of edges) {\n        // Create plane through virtualSource, v1, v2\n        // The winding order determines the normal direction\n        let edgePlane = Plane3D.fromPoints(virtualSource, v1, v2);\n        // Ensure normal points INTO the beam (toward aperture centroid)\n        if (Plane3D.signedDistance(apertureCentroid, edgePlane) < 0) {\n            edgePlane = Plane3D.flip(edgePlane);\n        }\n        planes.push(edgePlane);\n    }\n    // Aperture plane - normal should point AWAY from source (toward the \"open\" side of beam)\n    // This allows polygons beyond the aperture to be considered inside the beam\n    let aperturePlane = aperture.plane;\n    if (Plane3D.signedDistance(virtualSource, aperturePlane) > 0) {\n        aperturePlane = Plane3D.flip(aperturePlane);\n    }\n    planes.push(aperturePlane);\n    return planes;\n}\n/**\n * Create a Beam3D from virtual source and aperture\n */\nexport function createBeam3D(virtualSource, aperture, reflectingPolygonId) {\n    return {\n        virtualSource,\n        aperture,\n        boundaryPlanes: constructBeamBoundaryPlanes(virtualSource, aperture),\n        reflectingPolygonId\n    };\n}\n/**\n * Check if a point is inside the beam volume\n *\n * A point is inside if it's on the front (positive) side of all boundary planes.\n *\n * @param point - The point to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance for boundary tests\n */\nexport function isPointInBeam(point, beam, epsilon = 1e-6) {\n    for (const plane of beam.boundaryPlanes) {\n        if (Plane3D.signedDistance(point, plane) < -epsilon) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Find which boundary plane a point violates (if any)\n *\n * Returns null if the point is inside the beam.\n * Useful for fail plane detection - we want to know which boundary\n * caused the rejection.\n *\n * @param point - The point to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance for boundary tests\n */\nexport function findBeamViolation(point, beam, epsilon = 1e-6) {\n    const edgeCount = beam.boundaryPlanes.length - 1;\n    for (let i = 0; i < beam.boundaryPlanes.length; i++) {\n        const plane = beam.boundaryPlanes[i];\n        if (Plane3D.signedDistance(point, plane) < -epsilon) {\n            const type = i < edgeCount ? 'edge' : 'aperture';\n            return { plane, type, index: i };\n        }\n    }\n    return null;\n}\n/**\n * Get the minimum signed distance from a point to any beam boundary\n *\n * Positive means the point is inside by at least that distance.\n * Negative means the point is outside by that distance.\n */\nexport function distanceToBeamBoundary(point, beam) {\n    let minDist = Infinity;\n    for (const plane of beam.boundaryPlanes) {\n        const dist = Plane3D.signedDistance(point, plane);\n        minDist = Math.min(minDist, dist);\n    }\n    return minDist;\n}\n/**\n * Mirror a point across the reflecting polygon's plane\n * (Used to compute virtual sources)\n */\nexport function mirrorPointAcrossPolygon(point, polygon) {\n    return Plane3D.mirrorPoint(point, polygon.plane);\n}\n/**\n * Check if a polygon is potentially visible to the beam\n *\n * Quick rejection test: polygon must not be entirely behind any boundary plane.\n *\n * @param polygon - The polygon to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance\n */\nexport function polygonMayBeInBeam(polygon, beam, epsilon = 1e-6) {\n    for (const plane of beam.boundaryPlanes) {\n        let allBehind = true;\n        for (const v of polygon.vertices) {\n            if (Plane3D.signedDistance(v, plane) >= -epsilon) {\n                allBehind = false;\n                break;\n            }\n        }\n        if (allBehind) {\n            return false; // Polygon is entirely outside this boundary\n        }\n    }\n    return true;\n}\n/**\n * Check if the beam's virtual source can \"see\" a polygon\n * (Backface culling from virtual source's perspective)\n */\nexport function isPolygonFacingSource(polygon, virtualSource) {\n    const centroid = Polygon3D.centroid(polygon);\n    const toSource = Vector3.subtract(virtualSource, centroid);\n    const normal = Plane3D.normal(polygon.plane);\n    return Vector3.dot(normal, toSource) > 0;\n}\n/**\n * Compute the solid angle subtended by the aperture from the virtual source\n * (Useful for importance sampling and energy calculations)\n */\nexport function beamSolidAngle(beam) {\n    // Approximate solid angle using sum of triangular solid angles\n    const source = beam.virtualSource;\n    const verts = beam.aperture.vertices;\n    const n = verts.length;\n    let solidAngle = 0;\n    // Use first vertex as pivot for fan triangulation\n    for (let i = 1; i < n - 1; i++) {\n        const a = Vector3.normalize(Vector3.subtract(verts[0], source));\n        const b = Vector3.normalize(Vector3.subtract(verts[i], source));\n        const c = Vector3.normalize(Vector3.subtract(verts[i + 1], source));\n        // Compute solid angle of triangle using Oosterom-Strackee formula\n        const numerator = Math.abs(Vector3.dot(a, Vector3.cross(b, c)));\n        const denominator = 1 +\n            Vector3.dot(a, b) +\n            Vector3.dot(b, c) +\n            Vector3.dot(c, a);\n        solidAngle += 2 * Math.atan2(numerator, denominator);\n    }\n    return solidAngle;\n}\n//# sourceMappingURL=beam3d.js.map","/**\n * 3D Beam Tree for BeamTrace3D\n *\n * Hierarchical structure of beams representing all possible reflection paths\n * up to a maximum reflection order. Each node in the tree represents a\n * virtual source and aperture for a particular reflection sequence.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { clipPolygonByPlanes, quickRejectPolygon } from '../geometry/clipping3d';\nimport { constructBeamBoundaryPlanes, isPolygonFacingSource, mirrorPointAcrossPolygon } from './beam3d';\n/**\n * Minimum aperture area to consider (skip tiny apertures)\n */\nconst MIN_APERTURE_AREA = 1e-6;\n/**\n * Build a complete beam tree from source and room geometry\n *\n * @param sourcePosition - Position of the sound source\n * @param polygons - Room polygons (walls, floor, ceiling)\n * @param maxReflectionOrder - Maximum number of reflections to track\n * @returns Complete beam tree structure\n */\nexport function buildBeamTree3D(sourcePosition, polygons, maxReflectionOrder) {\n    // Create root node (source position, no reflection)\n    const root = {\n        id: -1,\n        parent: null,\n        virtualSource: Vector3.clone(sourcePosition),\n        children: []\n    };\n    // First order: source reflects off each visible polygon\n    // Only create first-order nodes if maxReflectionOrder >= 1\n    if (maxReflectionOrder >= 1) {\n        for (let i = 0; i < polygons.length; i++) {\n            const poly = polygons[i];\n            // Check if source can see this polygon (not backfacing)\n            if (!isPolygonFacingSource(poly, sourcePosition)) {\n                continue;\n            }\n            // Create virtual source by mirroring across polygon\n            const childVS = mirrorPointAcrossPolygon(sourcePosition, poly);\n            // First-order beam uses the full polygon as aperture\n            const childBoundaries = constructBeamBoundaryPlanes(childVS, poly);\n            const childNode = {\n                id: i,\n                parent: root,\n                virtualSource: childVS,\n                aperture: Polygon3D.clone(poly),\n                boundaryPlanes: childBoundaries,\n                children: []\n            };\n            root.children.push(childNode);\n            // Build higher-order reflections recursively\n            if (maxReflectionOrder > 1) {\n                buildBeamChildren(childNode, polygons, 2, maxReflectionOrder);\n            }\n        }\n    }\n    // Collect all leaf nodes for bucket optimization\n    const leafNodes = [];\n    collectLeafNodes(root, leafNodes);\n    return {\n        root,\n        leafNodes,\n        polygons,\n        maxReflectionOrder\n    };\n}\n/**\n * Recursively build child beams for higher-order reflections\n */\nfunction buildBeamChildren(node, polygons, currentOrder, maxOrder) {\n    if (currentOrder > maxOrder)\n        return;\n    if (!node.boundaryPlanes || !node.aperture)\n        return;\n    for (let i = 0; i < polygons.length; i++) {\n        // Skip the polygon we just reflected off (can't reflect off same surface twice in a row)\n        if (i === node.id)\n            continue;\n        const poly = polygons[i];\n        // Quick rejection: is polygon entirely outside beam?\n        if (quickRejectPolygon(poly, node.boundaryPlanes)) {\n            continue;\n        }\n        // Check if polygon is facing the virtual source (backface culling)\n        if (!isPolygonFacingSource(poly, node.virtualSource)) {\n            continue;\n        }\n        // Clip polygon to beam volume\n        const clipped = clipPolygonByPlanes(poly, node.boundaryPlanes);\n        if (!clipped)\n            continue;\n        // Skip tiny apertures\n        const area = Polygon3D.area(clipped);\n        if (area < MIN_APERTURE_AREA)\n            continue;\n        // Create child beam\n        const childVS = mirrorPointAcrossPolygon(node.virtualSource, poly);\n        const childBoundaries = constructBeamBoundaryPlanes(childVS, clipped);\n        const childNode = {\n            id: i,\n            parent: node,\n            virtualSource: childVS,\n            aperture: clipped,\n            boundaryPlanes: childBoundaries,\n            children: []\n        };\n        node.children.push(childNode);\n        // Continue recursion\n        if (currentOrder < maxOrder) {\n            buildBeamChildren(childNode, polygons, currentOrder + 1, maxOrder);\n        }\n    }\n}\n/**\n * Collect all leaf nodes (nodes with no children that have a valid aperture)\n */\nfunction collectLeafNodes(node, result) {\n    if (node.children.length === 0 && node.id !== -1) {\n        result.push(node);\n    }\n    for (const child of node.children) {\n        collectLeafNodes(child, result);\n    }\n}\n/**\n * Collect all nodes at a specific reflection order\n */\nexport function collectNodesAtOrder(tree, order) {\n    const result = [];\n    collectAtOrderRecursive(tree.root, 0, order, result);\n    return result;\n}\nfunction collectAtOrderRecursive(node, currentOrder, targetOrder, result) {\n    if (currentOrder === targetOrder && node.id !== -1) {\n        result.push(node);\n        return;\n    }\n    if (currentOrder >= targetOrder)\n        return;\n    for (const child of node.children) {\n        collectAtOrderRecursive(child, currentOrder + 1, targetOrder, result);\n    }\n}\n/**\n * Get the reflection order (depth) of a node\n */\nexport function getNodeOrder(node) {\n    let order = 0;\n    let current = node;\n    while (current && current.id !== -1) {\n        order++;\n        current = current.parent;\n    }\n    return order;\n}\n/**\n * Get the reflection path (polygon IDs) from root to a node\n */\nexport function getReflectionPath(node) {\n    const path = [];\n    let current = node;\n    while (current && current.id !== -1) {\n        path.unshift(current.id);\n        current = current.parent;\n    }\n    return path;\n}\n/**\n * Count total nodes in the beam tree\n */\nexport function countBeamNodes(tree) {\n    return countNodesRecursive(tree.root);\n}\nfunction countNodesRecursive(node) {\n    let count = 1;\n    for (const child of node.children) {\n        count += countNodesRecursive(child);\n    }\n    return count;\n}\nexport function getBeamTreeStats(tree) {\n    const nodesPerOrder = [];\n    let maxDepth = 0;\n    function traverse(node, depth) {\n        if (node.id !== -1) {\n            while (nodesPerOrder.length <= depth) {\n                nodesPerOrder.push(0);\n            }\n            nodesPerOrder[depth]++;\n            maxDepth = Math.max(maxDepth, depth);\n        }\n        for (const child of node.children) {\n            traverse(child, depth + 1);\n        }\n    }\n    traverse(tree.root, 0);\n    return {\n        totalNodes: countBeamNodes(tree),\n        leafNodes: tree.leafNodes.length,\n        maxDepth,\n        nodesPerOrder\n    };\n}\n/**\n * Clear all fail planes in the tree (reset optimization cache)\n */\nexport function clearFailPlanes(tree) {\n    clearFailPlanesRecursive(tree.root);\n}\nfunction clearFailPlanesRecursive(node) {\n    node.failPlane = undefined;\n    node.failPlaneType = undefined;\n    for (const child of node.children) {\n        clearFailPlanesRecursive(child);\n    }\n}\n/**\n * Iterate over all nodes in the tree (for batch operations)\n */\nexport function* iterateNodes(tree) {\n    yield* iterateNodesRecursive(tree.root);\n}\nfunction* iterateNodesRecursive(node) {\n    yield node;\n    for (const child of node.children) {\n        yield* iterateNodesRecursive(child);\n    }\n}\n//# sourceMappingURL=beamtree3d.js.map","/**\n * Fail Plane Optimization for BeamTrace3D\n *\n * The fail plane optimization caches the geometric reason why a path validation\n * failed, allowing O(1) rejection on subsequent frames when the listener moves.\n *\n * From the Laine et al. (2009) paper:\n * - Type 1 (polygon): Listener is behind the reflecting wall's plane\n * - Type 2 (beam): Listener is outside the beam volume (behind an edge plane)\n *\n * The fail plane is propagated (mirrored) through each reflection from the\n * detection node back to the leaf node for use in subsequent frames.\n */\nimport { Plane3D } from '../core/plane3d';\n/**\n * Detect fail plane for a listener position at a beam node\n *\n * This function determines which geometric constraint the listener violates,\n * and returns the corresponding fail plane.\n *\n * @param listenerPos - Current listener position\n * @param node - The beam node to check\n * @param polygons - Room polygons (for accessing the reflecting polygon)\n * @returns FailPlaneInfo if listener is outside, null if listener is valid\n */\nexport function detectFailPlane(listenerPos, node, polygons) {\n    if (!node.aperture || !node.boundaryPlanes) {\n        return null;\n    }\n    // Type 1: Check if listener is behind the reflecting polygon's plane\n    // The listener must be on the same side of the polygon as the virtual source\n    const reflectingPoly = polygons[node.id];\n    let polyPlane = reflectingPoly.plane;\n    // Orient plane so virtual source is in front\n    if (Plane3D.signedDistance(node.virtualSource, polyPlane) < 0) {\n        polyPlane = Plane3D.flip(polyPlane);\n    }\n    // If listener is behind the polygon plane, it can't receive reflections from this surface\n    if (Plane3D.signedDistance(listenerPos, polyPlane) < 0) {\n        return {\n            plane: polyPlane,\n            type: 'polygon',\n            nodeDepth: getNodeDepth(node)\n        };\n    }\n    // Type 2: Check beam boundaries\n    // Listener must be inside the beam volume (on front side of all boundary planes)\n    const edgeCount = node.boundaryPlanes.length - 1; // Last plane is aperture\n    for (let i = 0; i < node.boundaryPlanes.length; i++) {\n        const plane = node.boundaryPlanes[i];\n        if (Plane3D.signedDistance(listenerPos, plane) < 0) {\n            const type = i < edgeCount ? 'edge' : 'aperture';\n            return {\n                plane,\n                type,\n                nodeDepth: getNodeDepth(node)\n            };\n        }\n    }\n    return null;\n}\n/**\n * Get the depth of a node in the beam tree\n */\nfunction getNodeDepth(node) {\n    let depth = 0;\n    let current = node;\n    while (current && current.id !== -1) {\n        depth++;\n        current = current.parent;\n    }\n    return depth;\n}\n/**\n * Propagate a fail plane through the reflection chain\n *\n * When a fail plane is detected at some node, it needs to be mirrored\n * through each reflection surface to be valid for the leaf node.\n * This transforms the fail plane from the coordinate system at detection\n * to the coordinate system at the leaf.\n *\n * @param failPlane - The detected fail plane\n * @param fromNode - Node where failure was detected\n * @param toNode - Target node (usually leaf)\n * @param polygons - Room polygons for mirroring\n * @returns The propagated fail plane\n */\nexport function propagateFailPlane(failPlane, fromNode, toNode, polygons) {\n    let currentPlane = failPlane;\n    let current = fromNode;\n    // Walk from detection node toward root, mirroring at each reflection\n    while (current && current !== toNode && current.parent) {\n        if (current.id >= 0 && current.id < polygons.length) {\n            const reflectingPoly = polygons[current.id];\n            currentPlane = Plane3D.mirrorPlane(currentPlane, reflectingPoly.plane);\n        }\n        current = current.parent;\n    }\n    return currentPlane;\n}\n/**\n * Check if listener is still in the fail region (behind fail plane)\n *\n * This is the O(1) cache check that provides the speedup.\n * If the listener is behind the cached fail plane, we can skip\n * the expensive path validation.\n *\n * @param listenerPos - Current listener position\n * @param failPlane - Cached fail plane\n * @returns true if listener is behind the fail plane (path still invalid)\n */\nexport function isListenerBehindFailPlane(listenerPos, failPlane) {\n    return Plane3D.signedDistance(listenerPos, failPlane) < 0;\n}\n/**\n * Get the distance from listener to the fail plane\n *\n * Positive distance means listener is in front (valid side)\n * Negative distance means listener is behind (invalid side)\n *\n * This can be used to determine how far the listener needs to move\n * to potentially validate the path.\n */\nexport function distanceToFailPlane(listenerPos, failPlane) {\n    return Plane3D.signedDistance(listenerPos, failPlane);\n}\n/**\n * Find the minimum distance to any fail plane in a set of nodes\n *\n * Used by skip sphere optimization to determine sphere radius.\n */\nexport function minDistanceToFailPlanes(listenerPos, nodes) {\n    let minDist = Infinity;\n    for (const node of nodes) {\n        if (node.failPlane) {\n            const dist = Math.abs(Plane3D.signedDistance(listenerPos, node.failPlane));\n            minDist = Math.min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n/**\n * Update fail plane for a node after path validation fails\n *\n * Detects the fail plane and caches it on the node for future checks.\n *\n * @param node - The node that failed validation\n * @param listenerPos - Current listener position\n * @param polygons - Room polygons\n * @returns true if a fail plane was detected and cached\n */\nexport function updateNodeFailPlane(node, listenerPos, polygons) {\n    const failInfo = detectFailPlane(listenerPos, node, polygons);\n    if (failInfo) {\n        node.failPlane = failInfo.plane;\n        node.failPlaneType = failInfo.type;\n        return true;\n    }\n    return false;\n}\n/**\n * Clear fail plane cache from a node\n */\nexport function clearNodeFailPlane(node) {\n    node.failPlane = undefined;\n    node.failPlaneType = undefined;\n}\n/**\n * Check if a node has a cached fail plane\n */\nexport function hasFailPlane(node) {\n    return node.failPlane !== undefined;\n}\n//# sourceMappingURL=failplane3d.js.map","/**\n * Skip Sphere Optimization for BeamTrace3D\n *\n * The skip sphere optimization groups beam leaf nodes into buckets and\n * creates spatial rejection regions that allow skipping entire buckets\n * when the listener is inside the sphere.\n *\n * This is the 3D equivalent of the skip circle optimization from the\n * Laine et al. (2009) paper. When all paths in a bucket fail, a skip\n * sphere is created centered at the listener position with radius\n * equal to the minimum distance to any fail plane in the bucket.\n *\n * The paper found bucket size of 16 to be optimal for performance.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\n/**\n * Default bucket size (from paper: 16 nodes per bucket is optimal)\n */\nexport const DEFAULT_BUCKET_SIZE_3D = 16;\n/**\n * Create buckets from leaf nodes\n *\n * Nodes are grouped sequentially into buckets of the specified size.\n *\n * @param leafNodes - Array of leaf beam nodes\n * @param bucketSize - Number of nodes per bucket\n * @returns Array of buckets\n */\nexport function createBuckets3D(leafNodes, bucketSize = DEFAULT_BUCKET_SIZE_3D) {\n    const buckets = [];\n    for (let i = 0; i < leafNodes.length; i += bucketSize) {\n        buckets.push({\n            id: buckets.length,\n            nodes: leafNodes.slice(i, Math.min(i + bucketSize, leafNodes.length)),\n            skipSphere: null\n        });\n    }\n    return buckets;\n}\n/**\n * Check if a point is inside a skip sphere\n */\nexport function isInsideSkipSphere(point, skipSphere) {\n    const dist = Vector3.distance(point, skipSphere.center);\n    return dist < skipSphere.radius;\n}\n/**\n * Check skip sphere status for a bucket\n *\n * @param listenerPos - Current listener position\n * @param bucket - The bucket to check\n * @returns 'inside' if listener is inside skip sphere (can skip bucket),\n *          'outside' if listener escaped (must invalidate sphere),\n *          'none' if no skip sphere exists\n */\nexport function checkSkipSphere(listenerPos, bucket) {\n    if (!bucket.skipSphere) {\n        return 'none';\n    }\n    return isInsideSkipSphere(listenerPos, bucket.skipSphere) ? 'inside' : 'outside';\n}\n/**\n * Create a skip sphere for a bucket where all paths failed\n *\n * The radius is the minimum distance to any fail plane in the bucket.\n * This ensures that as long as the listener stays inside the sphere,\n * it will still be behind all fail planes and all paths will still fail.\n *\n * @param listenerPos - Current listener position (center of sphere)\n * @param nodes - Nodes in the bucket (all should have fail planes)\n * @returns Skip sphere, or null if any node lacks a fail plane\n */\nexport function createSkipSphere(listenerPos, nodes) {\n    let minDist = Infinity;\n    for (const node of nodes) {\n        if (!node.failPlane) {\n            // Can't create skip sphere if any node doesn't have a fail plane\n            return null;\n        }\n        // Distance to the fail plane (absolute value since we want sphere radius)\n        const dist = Math.abs(Plane3D.signedDistance(listenerPos, node.failPlane));\n        minDist = Math.min(minDist, dist);\n    }\n    // Don't create degenerate spheres\n    if (minDist === Infinity || minDist <= 1e-10) {\n        return null;\n    }\n    return {\n        center: Vector3.clone(listenerPos),\n        radius: minDist\n    };\n}\n/**\n * Invalidate a bucket's skip sphere\n *\n * Called when listener escapes the skip sphere.\n */\nexport function invalidateSkipSphere(bucket) {\n    bucket.skipSphere = null;\n}\n/**\n * Clear all fail planes in a bucket\n *\n * Called when skip sphere is invalidated to force re-evaluation.\n */\nexport function clearBucketFailPlanes(bucket) {\n    for (const node of bucket.nodes) {\n        node.failPlane = undefined;\n        node.failPlaneType = undefined;\n    }\n}\n/**\n * Update skip sphere for a bucket after processing\n *\n * If all paths in the bucket failed and all have fail planes,\n * create a skip sphere for future optimization.\n *\n * @param bucket - The bucket to update\n * @param listenerPos - Current listener position\n * @param allFailed - Whether all paths in bucket failed\n * @returns true if skip sphere was created\n */\nexport function updateBucketSkipSphere(bucket, listenerPos, allFailed) {\n    if (!allFailed) {\n        // At least one path succeeded, no skip sphere needed\n        return false;\n    }\n    // Check if all nodes have fail planes\n    for (const node of bucket.nodes) {\n        if (!node.failPlane) {\n            return false;\n        }\n    }\n    // Create skip sphere\n    bucket.skipSphere = createSkipSphere(listenerPos, bucket.nodes);\n    return bucket.skipSphere !== null;\n}\nexport function processBucketSkipSphere(bucket, listenerPos) {\n    const status = checkSkipSphere(listenerPos, bucket);\n    switch (status) {\n        case 'inside':\n            // Listener inside skip sphere - skip entire bucket\n            return { skip: true, needsRevalidation: false };\n        case 'outside':\n            // Listener escaped - need to invalidate and reprocess\n            invalidateSkipSphere(bucket);\n            clearBucketFailPlanes(bucket);\n            return { skip: false, needsRevalidation: true };\n        case 'none':\n        default:\n            // No skip sphere - normal processing\n            return { skip: false, needsRevalidation: false };\n    }\n}\nexport function getSkipSphereStats(buckets) {\n    let bucketsWithSphere = 0;\n    let totalRadius = 0;\n    let minRadius = Infinity;\n    let maxRadius = 0;\n    for (const bucket of buckets) {\n        if (bucket.skipSphere) {\n            bucketsWithSphere++;\n            totalRadius += bucket.skipSphere.radius;\n            minRadius = Math.min(minRadius, bucket.skipSphere.radius);\n            maxRadius = Math.max(maxRadius, bucket.skipSphere.radius);\n        }\n    }\n    return {\n        totalBuckets: buckets.length,\n        bucketsWithSphere,\n        averageRadius: bucketsWithSphere > 0 ? totalRadius / bucketsWithSphere : 0,\n        minRadius: minRadius === Infinity ? 0 : minRadius,\n        maxRadius\n    };\n}\n//# sourceMappingURL=skipsphere3d.js.map","/**\n * Optimized 3D Beam Tracing Solver\n *\n * Main solver that combines BSP tree, beam tree, fail plane, and skip sphere\n * optimizations for efficient acoustic path finding in 3D environments.\n *\n * Based on: Laine, S., Siltanen, S., Lokki, T., & Savioja, L. (2009).\n * \"Accelerated beam tracing algorithm.\" Applied Acoustics, 70(1), 172-181.\n */\nimport { Vector3 } from '../core/vector3';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { Plane3D } from '../core/plane3d';\nimport { buildBSP, rayTraceBSP, rayTraceBSPMultiIgnore } from '../structures/bsp3d';\nimport { buildBeamTree3D, clearFailPlanes } from '../structures/beamtree3d';\nimport { detectFailPlane, isListenerBehindFailPlane } from '../optimization/failplane3d';\nimport { createBuckets3D, checkSkipSphere, createSkipSphere, invalidateSkipSphere, clearBucketFailPlanes, DEFAULT_BUCKET_SIZE_3D } from '../optimization/skipsphere3d';\n/**\n * Optimized 3D Beam Tracing Solver\n *\n * Provides efficient acoustic path finding using:\n * - BSP tree for O(log n) ray-polygon intersection\n * - Beam tree for reflection path enumeration\n * - Fail plane caching for O(1) early rejection\n * - Skip sphere bucketing for spatial acceleration\n */\nexport class OptimizedSolver3D {\n    /**\n     * Create a new 3D beam tracing solver\n     *\n     * @param polygons - Room geometry as an array of polygons\n     * @param sourcePosition - Position of the sound source\n     * @param config - Optional configuration\n     */\n    constructor(polygons, sourcePosition, config = {}) {\n        const maxOrder = config.maxReflectionOrder ?? 5;\n        const bucketSize = config.bucketSize ?? DEFAULT_BUCKET_SIZE_3D;\n        this.polygons = polygons;\n        this.sourcePosition = Vector3.clone(sourcePosition);\n        // Build BSP tree for ray tracing\n        this.bspRoot = buildBSP(polygons);\n        // Build beam tree for reflection enumeration\n        this.beamTree = buildBeamTree3D(sourcePosition, polygons, maxOrder);\n        // Create buckets for skip sphere optimization\n        this.buckets = createBuckets3D(this.beamTree.leafNodes, bucketSize);\n        // Initialize metrics\n        this.metrics = this.createEmptyMetrics();\n        this.metrics.totalLeafNodes = this.beamTree.leafNodes.length;\n        this.metrics.bucketsTotal = this.buckets.length;\n    }\n    /**\n     * Get all valid reflection paths from source to listener\n     *\n     * @param listenerPos - Position of the listener\n     * @returns Array of valid reflection paths\n     */\n    getPaths(listenerPos) {\n        this.resetMetrics();\n        const validPaths = [];\n        // 1. Check direct path (order 0)\n        const directPath = this.validateDirectPath(listenerPos);\n        if (directPath) {\n            validPaths.push(directPath);\n        }\n        // 2. Check intermediate reflection orders (non-leaf nodes)\n        const intermediatePaths = this.findIntermediatePaths(listenerPos, this.beamTree.root);\n        validPaths.push(...intermediatePaths);\n        // 3. Process leaf nodes with bucket optimization\n        for (const bucket of this.buckets) {\n            const skipStatus = checkSkipSphere(listenerPos, bucket);\n            if (skipStatus === 'inside') {\n                // Listener inside skip sphere - skip entire bucket\n                this.metrics.bucketsSkipped++;\n                continue;\n            }\n            if (skipStatus === 'outside') {\n                // Listener escaped - invalidate sphere and clear fail planes\n                invalidateSkipSphere(bucket);\n                clearBucketFailPlanes(bucket);\n            }\n            this.metrics.bucketsChecked++;\n            let allFailed = true;\n            let allHaveFailPlanes = true;\n            for (const node of bucket.nodes) {\n                // Check fail plane cache first (O(1))\n                if (node.failPlane && isListenerBehindFailPlane(listenerPos, node.failPlane)) {\n                    this.metrics.failPlaneCacheHits++;\n                    continue;\n                }\n                // Fail plane was invalidated or listener escaped\n                if (node.failPlane) {\n                    node.failPlane = undefined;\n                    node.failPlaneType = undefined;\n                    this.metrics.failPlaneCacheMisses++;\n                }\n                // Full path validation\n                const result = this.validatePath(listenerPos, node);\n                if (result.valid && result.path) {\n                    validPaths.push(result.path);\n                    allFailed = false;\n                    allHaveFailPlanes = false;\n                }\n                else if (!node.failPlane) {\n                    allHaveFailPlanes = false;\n                }\n            }\n            // Create skip sphere if all paths failed with fail planes\n            if (allFailed && allHaveFailPlanes && bucket.nodes.length > 0) {\n                bucket.skipSphere = createSkipSphere(listenerPos, bucket.nodes);\n                if (bucket.skipSphere) {\n                    this.metrics.skipSphereCount++;\n                }\n            }\n        }\n        this.metrics.validPathCount = validPaths.length;\n        return validPaths;\n    }\n    /**\n     * Get all valid reflection paths with detailed information about each reflection.\n     *\n     * This method returns the same paths as getPaths() but with additional details:\n     * - Angle of incidence and reflection at each surface\n     * - Surface normal vectors\n     * - Segment lengths and cumulative distances\n     * - Grazing incidence detection\n     *\n     * @param listenerPos - Position of the listener\n     * @returns Array of detailed reflection paths\n     */\n    getDetailedPaths(listenerPos) {\n        const simplePaths = this.getPaths(listenerPos);\n        return simplePaths.map(path => convertToDetailedPath3D(path, this.polygons));\n    }\n    /**\n     * Validate the direct path from listener to source\n     */\n    validateDirectPath(listenerPos) {\n        const direction = Vector3.subtract(this.sourcePosition, listenerPos);\n        const dist = Vector3.length(direction);\n        const dir = Vector3.normalize(direction);\n        this.metrics.raycastCount++;\n        const hit = rayTraceBSP(listenerPos, dir, this.bspRoot, 0, dist, -1);\n        // If something blocks the path before reaching source, no direct path\n        if (hit && hit.t < dist - 1e-6) {\n            return null;\n        }\n        return [\n            { position: Vector3.clone(listenerPos), polygonId: null },\n            { position: Vector3.clone(this.sourcePosition), polygonId: null }\n        ];\n    }\n    /**\n     * Find paths through intermediate (non-leaf) nodes\n     *\n     * These are lower-order reflections that didn't spawn further children.\n     */\n    findIntermediatePaths(listenerPos, node) {\n        const paths = [];\n        // Process children recursively\n        for (const child of node.children) {\n            if (child.children.length > 0) {\n                // Has children - recurse\n                paths.push(...this.findIntermediatePaths(listenerPos, child));\n            }\n        }\n        // Try this node if it has an aperture (is a reflection, not root)\n        if (node.id !== -1 && node.aperture) {\n            const path = this.traverseBeam(listenerPos, node);\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    /**\n     * Traverse a beam from listener to source, building the reflection path\n     */\n    traverseBeam(listenerPos, node, debug = false) {\n        const pathPoints = [\n            { position: Vector3.clone(listenerPos), polygonId: null }\n        ];\n        // Build polygon path for logging\n        const polygonPath = [];\n        let tempNode = node;\n        while (tempNode && tempNode.id !== -1) {\n            polygonPath.unshift(tempNode.id);\n            tempNode = tempNode.parent;\n        }\n        if (debug) {\n            console.log(`[traverseBeam] Exploring beam with polygonPath: [${polygonPath.join(', ')}]`);\n            console.log(`  Listener: [${listenerPos[0].toFixed(3)}, ${listenerPos[1].toFixed(3)}, ${listenerPos[2].toFixed(3)}]`);\n            console.log(`  Virtual source: [${node.virtualSource[0].toFixed(3)}, ${node.virtualSource[1].toFixed(3)}, ${node.virtualSource[2].toFixed(3)}]`);\n        }\n        let currentPoint = listenerPos;\n        let currentNode = node;\n        // Track all polygon IDs that should be ignored in occlusion checks\n        // (the polygon we're coming from and the polygon we're going to)\n        const ignoreIds = new Set();\n        let segmentIndex = 0;\n        // Walk from leaf to root, finding reflection points\n        while (currentNode && currentNode.id !== -1) {\n            const poly = this.polygons[currentNode.id];\n            const imageSource = currentNode.virtualSource;\n            // Direction from current point toward virtual source\n            const dir = Vector3.normalize(Vector3.subtract(imageSource, currentPoint));\n            // Find intersection with reflecting polygon\n            const hit = Polygon3D.rayIntersection(currentPoint, dir, poly);\n            if (!hit) {\n                if (debug) {\n                    console.log(`  [Segment ${segmentIndex}] FAIL: No intersection with polygon ${currentNode.id}`);\n                }\n                return null;\n            }\n            if (debug) {\n                console.log(`  [Segment ${segmentIndex}] Ray from [${currentPoint[0].toFixed(3)}, ${currentPoint[1].toFixed(3)}, ${currentPoint[2].toFixed(3)}]`);\n                console.log(`    Direction: [${dir[0].toFixed(3)}, ${dir[1].toFixed(3)}, ${dir[2].toFixed(3)}]`);\n                console.log(`    Hit polygon ${currentNode.id} at t=${hit.t.toFixed(3)}, point=[${hit.point[0].toFixed(3)}, ${hit.point[1].toFixed(3)}, ${hit.point[2].toFixed(3)}]`);\n            }\n            // Check for occlusion between current point and reflection point\n            // We need to ignore:\n            // - The polygon we just came from (already in ignoreIds from previous iteration)\n            // - The polygon we're reflecting to (currentNode.id) since it's at the endpoint\n            ignoreIds.add(currentNode.id);\n            this.metrics.raycastCount++;\n            const occluder = rayTraceBSPMultiIgnore(currentPoint, dir, this.bspRoot, 1e-6, hit.t - 1e-6, ignoreIds);\n            if (occluder) {\n                if (debug) {\n                    console.log(`    OCCLUDED by polygon ${occluder.polygonId} at t=${occluder.t.toFixed(3)}, point=[${occluder.point[0].toFixed(3)}, ${occluder.point[1].toFixed(3)}, ${occluder.point[2].toFixed(3)}]`);\n                    console.log(`    ignoreIds: [${Array.from(ignoreIds).join(', ')}]`);\n                }\n                return null;\n            }\n            if (debug) {\n                console.log(`    OK - no occlusion (ignoreIds: [${Array.from(ignoreIds).join(', ')}])`);\n            }\n            // Add reflection point to path\n            pathPoints.push({\n                position: Vector3.clone(hit.point),\n                polygonId: currentNode.id\n            });\n            currentPoint = hit.point;\n            // Keep the current polygon in ignoreIds for the next segment\n            // (we're leaving from this polygon)\n            currentNode = currentNode.parent;\n            segmentIndex++;\n        }\n        // Final segment to actual source\n        if (currentNode) {\n            const dir = Vector3.normalize(Vector3.subtract(currentNode.virtualSource, currentPoint));\n            const dist = Vector3.distance(currentNode.virtualSource, currentPoint);\n            if (debug) {\n                console.log(`  [Final segment] Ray from [${currentPoint[0].toFixed(3)}, ${currentPoint[1].toFixed(3)}, ${currentPoint[2].toFixed(3)}]`);\n                console.log(`    To source: [${currentNode.virtualSource[0].toFixed(3)}, ${currentNode.virtualSource[1].toFixed(3)}, ${currentNode.virtualSource[2].toFixed(3)}]`);\n                console.log(`    Direction: [${dir[0].toFixed(3)}, ${dir[1].toFixed(3)}, ${dir[2].toFixed(3)}]`);\n                console.log(`    Distance: ${dist.toFixed(3)}`);\n                console.log(`    tMin: ${1e-6}, tMax: ${(dist - 1e-6).toFixed(6)}`);\n                console.log(`    ignoreIds: [${Array.from(ignoreIds).join(', ')}]`);\n                // Check intersection with back1 (inner wall at y=5.575)\n                // If segment crosses y=5.575, calculate where\n                const p1 = currentPoint;\n                const p2 = currentNode.virtualSource;\n                if ((p1[1] < 5.575 && p2[1] > 5.575) || (p1[1] > 5.575 && p2[1] < 5.575)) {\n                    const t = (5.575 - p1[1]) / (p2[1] - p1[1]);\n                    const xAtCross = p1[0] + t * (p2[0] - p1[0]);\n                    const zAtCross = p1[2] + t * (p2[2] - p1[2]);\n                    console.log(`    CROSSING y=5.575 at t=${t.toFixed(3)}, x=${xAtCross.toFixed(3)}, z=${zAtCross.toFixed(3)}`);\n                    console.log(`    back1 spans: x=[6.215, 12.43], z=[0, 4.877]`);\n                    if (xAtCross >= 6.215 && xAtCross <= 12.43 && zAtCross >= 0 && zAtCross <= 4.877) {\n                        console.log(`    *** SHOULD HIT back1 (polygons 3, 4) ***`);\n                        // Direct ray test against polygons 3 and 4\n                        console.log(`    Direct polygon intersection test:`);\n                        for (const polyId of [3, 4]) {\n                            const poly = this.polygons[polyId];\n                            const testHit = Polygon3D.rayIntersection(currentPoint, dir, poly);\n                            if (testHit) {\n                                console.log(`      Polygon ${polyId}: HIT at t=${testHit.t.toFixed(3)}, point=[${testHit.point[0].toFixed(3)}, ${testHit.point[1].toFixed(3)}, ${testHit.point[2].toFixed(3)}]`);\n                            }\n                            else {\n                                console.log(`      Polygon ${polyId}: NO HIT`);\n                                // Debug: show polygon vertices\n                                console.log(`        Vertices: ${poly.vertices.map(v => `[${v[0].toFixed(2)}, ${v[1].toFixed(2)}, ${v[2].toFixed(2)}]`).join(', ')}`);\n                            }\n                        }\n                    }\n                }\n            }\n            this.metrics.raycastCount++;\n            // Use the same ignoreIds set which contains all polygons in the reflection chain\n            const tMinVal = 1e-6;\n            const tMaxVal = dist - 1e-6;\n            const finalHit = rayTraceBSPMultiIgnore(currentPoint, dir, this.bspRoot, tMinVal, tMaxVal, ignoreIds);\n            if (finalHit) {\n                if (debug) {\n                    console.log(`    OCCLUDED by polygon ${finalHit.polygonId} at t=${finalHit.t.toFixed(3)}, point=[${finalHit.point[0].toFixed(3)}, ${finalHit.point[1].toFixed(3)}, ${finalHit.point[2].toFixed(3)}]`);\n                }\n                return null;\n            }\n            if (debug) {\n                console.log(`    OK - path valid!`);\n            }\n            // Add source point\n            pathPoints.push({\n                position: Vector3.clone(currentNode.virtualSource),\n                polygonId: null\n            });\n        }\n        return pathPoints;\n    }\n    /**\n     * Validate a path through a beam node\n     */\n    validatePath(listenerPos, leafNode) {\n        const path = this.traverseBeam(listenerPos, leafNode);\n        if (path) {\n            return { valid: true, path };\n        }\n        // Path failed - try to detect and cache fail plane\n        const failInfo = detectFailPlane(listenerPos, leafNode, this.polygons);\n        if (failInfo) {\n            leafNode.failPlane = failInfo.plane;\n            leafNode.failPlaneType = failInfo.type;\n        }\n        return { valid: false, path: null };\n    }\n    /**\n     * Get performance metrics from the last getPaths() call\n     */\n    getMetrics() {\n        return { ...this.metrics };\n    }\n    /**\n     * Debug a specific beam path by polygon IDs\n     * Logs detailed information about the path validation process\n     */\n    debugBeamPath(listenerPos, polygonPath) {\n        console.log('=== DEBUG BEAM PATH ===');\n        console.log(`Listener: [${listenerPos[0].toFixed(3)}, ${listenerPos[1].toFixed(3)}, ${listenerPos[2].toFixed(3)}]`);\n        console.log(`Polygon path: [${polygonPath.join(', ')}]`);\n        console.log(`Source: [${this.sourcePosition[0].toFixed(3)}, ${this.sourcePosition[1].toFixed(3)}, ${this.sourcePosition[2].toFixed(3)}]`);\n        // Find the beam node matching this polygon path\n        const findNode = (node, path, depth) => {\n            if (depth === path.length) {\n                return node;\n            }\n            for (const child of node.children) {\n                if (child.id === path[depth]) {\n                    return findNode(child, path, depth + 1);\n                }\n            }\n            return null;\n        };\n        const targetNode = findNode(this.beamTree.root, polygonPath, 0);\n        if (!targetNode) {\n            console.log('ERROR: Could not find beam node for this polygon path');\n            return;\n        }\n        console.log(`Found beam node with virtual source: [${targetNode.virtualSource[0].toFixed(3)}, ${targetNode.virtualSource[1].toFixed(3)}, ${targetNode.virtualSource[2].toFixed(3)}]`);\n        // Run traverseBeam with debug enabled\n        const result = this.traverseBeam(listenerPos, targetNode, true);\n        if (result) {\n            console.log('PATH VALID - returned path:');\n            for (let i = 0; i < result.length; i++) {\n                const p = result[i];\n                console.log(`  [${i}] pos=[${p.position[0].toFixed(3)}, ${p.position[1].toFixed(3)}, ${p.position[2].toFixed(3)}], polygonId=${p.polygonId}`);\n            }\n        }\n        else {\n            console.log('PATH INVALID');\n        }\n        console.log('=== END DEBUG ===');\n    }\n    /**\n     * Clear all cached fail planes and skip spheres\n     *\n     * Call this if the room geometry changes.\n     */\n    clearCache() {\n        clearFailPlanes(this.beamTree);\n        for (const bucket of this.buckets) {\n            invalidateSkipSphere(bucket);\n        }\n    }\n    /**\n     * Get the number of leaf nodes in the beam tree\n     */\n    getLeafNodeCount() {\n        return this.beamTree.leafNodes.length;\n    }\n    /**\n     * Get the maximum reflection order\n     */\n    getMaxReflectionOrder() {\n        return this.beamTree.maxReflectionOrder;\n    }\n    /**\n     * Get the source position\n     */\n    getSourcePosition() {\n        return Vector3.clone(this.sourcePosition);\n    }\n    /**\n     * Get beam data for visualization\n     * Returns beams organized by reflection order\n     */\n    getBeamsForVisualization(maxOrder) {\n        const beams = [];\n        const effectiveMaxOrder = maxOrder ?? this.beamTree.maxReflectionOrder;\n        const traverse = (node, order, pathSoFar) => {\n            if (order > effectiveMaxOrder)\n                return;\n            // Build the current path including this node's polygon\n            const currentPath = node.id !== -1 ? [...pathSoFar, node.id] : pathSoFar;\n            if (node.id !== -1 && node.aperture) {\n                beams.push({\n                    virtualSource: Vector3.clone(node.virtualSource),\n                    apertureVertices: node.aperture.vertices.map(v => Vector3.clone(v)),\n                    reflectionOrder: order,\n                    polygonId: node.id,\n                    polygonPath: currentPath\n                });\n            }\n            for (const child of node.children) {\n                traverse(child, order + 1, currentPath);\n            }\n        };\n        traverse(this.beamTree.root, 0, []);\n        return beams;\n    }\n    /**\n     * Create empty metrics object\n     */\n    createEmptyMetrics() {\n        return {\n            totalLeafNodes: 0,\n            bucketsTotal: 0,\n            bucketsSkipped: 0,\n            bucketsChecked: 0,\n            failPlaneCacheHits: 0,\n            failPlaneCacheMisses: 0,\n            raycastCount: 0,\n            skipSphereCount: 0,\n            validPathCount: 0\n        };\n    }\n    /**\n     * Reset metrics for a new getPaths() call\n     */\n    resetMetrics() {\n        const total = this.metrics.totalLeafNodes;\n        const buckets = this.metrics.bucketsTotal;\n        this.metrics = this.createEmptyMetrics();\n        this.metrics.totalLeafNodes = total;\n        this.metrics.bucketsTotal = buckets;\n    }\n}\n/**\n * Compute the total path length of a reflection path\n */\nexport function computePathLength(path) {\n    let length = 0;\n    for (let i = 1; i < path.length; i++) {\n        length += Vector3.distance(path[i - 1].position, path[i].position);\n    }\n    return length;\n}\n/**\n * Compute arrival time for a path (assuming speed of sound)\n */\nexport function computeArrivalTime(path, speedOfSound = 343) {\n    return computePathLength(path) / speedOfSound;\n}\n/**\n * Get the reflection order of a path (number of reflections)\n */\nexport function getPathReflectionOrder(path) {\n    // Count points with non-null polygonId (reflection points)\n    return path.filter(p => p.polygonId !== null).length;\n}\n// ============================================================\n// Helper functions for detailed path information\n// ============================================================\n/** Threshold angle (radians from 90°) for marking reflections as grazing */\nconst GRAZING_THRESHOLD_3D = 0.05; // ~3 degrees from grazing\n/**\n * Calculate the incidence angle between an incoming direction and surface normal.\n * Returns angle in radians (0 = perpendicular to surface, π/2 = grazing).\n */\nfunction calculateIncidenceAngle3D(incomingDir, surfaceNormal) {\n    // The incoming direction points toward the surface, so we use -incomingDir\n    // Angle of incidence is measured from the normal\n    const cosAngle = Math.abs(Vector3.dot(Vector3.negate(incomingDir), surfaceNormal));\n    // Clamp to [-1, 1] to handle floating point errors\n    const clampedCos = Math.max(-1, Math.min(1, cosAngle));\n    return Math.acos(clampedCos);\n}\n/**\n * Get the surface normal oriented toward the incoming ray.\n * This ensures the normal always points toward the side the ray came from.\n */\nfunction getOrientedNormal3D(polygon, incomingDir) {\n    const normal = Plane3D.normal(polygon.plane);\n    // If ray is coming from the back side, flip the normal\n    const dot = Vector3.dot(incomingDir, normal);\n    if (dot > 0) {\n        return Vector3.negate(normal);\n    }\n    return Vector3.clone(normal);\n}\n/**\n * Convert a simple reflection path to a detailed path with full reflection information.\n *\n * @param path - The simple reflection path from getPaths()\n * @param polygons - The room polygons (to look up polygon info by ID)\n * @returns Detailed path information including angles, normals, and distances\n */\nexport function convertToDetailedPath3D(path, polygons) {\n    if (path.length < 2) {\n        throw new Error('Path must have at least 2 points (listener and source)');\n    }\n    const listenerPosition = Vector3.clone(path[0].position);\n    const sourcePosition = Vector3.clone(path[path.length - 1].position);\n    const reflections = [];\n    const segments = [];\n    let cumulativeDistance = 0;\n    // Process each segment and reflection\n    for (let i = 0; i < path.length - 1; i++) {\n        const startPoint = path[i].position;\n        const endPoint = path[i + 1].position;\n        // Calculate segment info\n        const segmentLength = Vector3.distance(startPoint, endPoint);\n        segments.push({\n            startPoint: Vector3.clone(startPoint),\n            endPoint: Vector3.clone(endPoint),\n            length: segmentLength,\n            segmentIndex: i\n        });\n        // If the end point is a reflection (not the source), calculate reflection details\n        const endPolygonId = path[i + 1].polygonId;\n        if (endPolygonId !== null) {\n            const polygon = polygons[endPolygonId];\n            const hitPoint = path[i + 1].position;\n            // Incoming direction (normalized)\n            const incomingDirection = Vector3.normalize(Vector3.subtract(hitPoint, startPoint));\n            // Get the next point to calculate outgoing direction\n            const nextPoint = path[i + 2]?.position;\n            let outgoingDirection;\n            if (nextPoint) {\n                outgoingDirection = Vector3.normalize(Vector3.subtract(nextPoint, hitPoint));\n            }\n            else {\n                // Shouldn't happen in valid paths, but handle gracefully\n                outgoingDirection = Vector3.reflect(incomingDirection, Plane3D.normal(polygon.plane));\n            }\n            // Surface normal oriented toward incoming ray\n            const surfaceNormal = getOrientedNormal3D(polygon, incomingDirection);\n            // Calculate angles\n            const incidenceAngle = calculateIncidenceAngle3D(incomingDirection, surfaceNormal);\n            const reflectionAngle = incidenceAngle; // Specular reflection\n            // Update cumulative distance (includes this segment)\n            cumulativeDistance += segmentLength;\n            // Check if grazing (angle close to 90°)\n            const isGrazing = Math.abs(incidenceAngle - Math.PI / 2) < GRAZING_THRESHOLD_3D;\n            reflections.push({\n                polygon,\n                polygonId: endPolygonId,\n                hitPoint: Vector3.clone(hitPoint),\n                incidenceAngle,\n                reflectionAngle,\n                incomingDirection,\n                outgoingDirection,\n                surfaceNormal,\n                reflectionOrder: reflections.length + 1,\n                cumulativeDistance,\n                incomingSegmentLength: segmentLength,\n                isGrazing\n            });\n        }\n        else {\n            // Final segment to source - just add to cumulative distance\n            cumulativeDistance += segmentLength;\n        }\n    }\n    return {\n        listenerPosition,\n        sourcePosition,\n        totalPathLength: cumulativeDistance,\n        reflectionCount: reflections.length,\n        reflections,\n        segments,\n        simplePath: path\n    };\n}\n//# sourceMappingURL=solver3d.js.map","/**\n * BeamTrace3D - 3D Beam Tracing for Acoustic Simulations\n *\n * Main entry point for the 3D beam tracing library.\n * Extends the 2D BeamTrace implementation to full 3D with:\n * - 3D polygonal room geometry\n * - BSP tree acceleration\n * - Fail plane caching\n * - Skip sphere bucketing\n *\n * Based on: Laine, S., Siltanen, S., Lokki, T., & Savioja, L. (2009).\n * \"Accelerated beam tracing algorithm.\" Applied Acoustics, 70(1), 172-181.\n *\n * @example\n * ```typescript\n * import { Polygon3D, Source3D, Listener3D, Solver3D, createShoeboxRoom } from './beamtrace3d';\n *\n * // Create a simple room\n * const room = createShoeboxRoom(10, 8, 3);\n *\n * // Create source and solver\n * const source = new Source3D([5, 4, 1.5]);\n * const solver = new Solver3D(room, source, { maxReflectionOrder: 4 });\n *\n * // Find paths to listener\n * const listener = new Listener3D([2, 2, 1.2]);\n * const paths = solver.getPaths(listener.position);\n * ```\n */\n// Core types\nexport { Vector3 } from './core/vector3';\nexport { Plane3D } from './core/plane3d';\n// Geometry\nexport { Polygon3D, createShoeboxRoom, createQuad } from './geometry/polygon3d';\nexport { splitPolygon, splitPolygons } from './geometry/polygon-split';\nexport { clipPolygonByPlane, clipPolygonByPlanes, clipPolygonByFrustum, quickRejectPolygon, polygonMayIntersectVolume, clipRayByPlanes } from './geometry/clipping3d';\n// Structures\nexport { buildBSP, rayTraceBSP, rayTraceBSPMultiIgnore, rayOccluded, rayTraceAll, countNodes, treeDepth, setBSPDebug } from './structures/bsp3d';\nexport { createBeam3D, constructBeamBoundaryPlanes, isPointInBeam, findBeamViolation, distanceToBeamBoundary, mirrorPointAcrossPolygon, polygonMayBeInBeam, isPolygonFacingSource, beamSolidAngle } from './structures/beam3d';\nexport { buildBeamTree3D, collectNodesAtOrder, getNodeOrder, getReflectionPath, countBeamNodes, getBeamTreeStats, clearFailPlanes, iterateNodes } from './structures/beamtree3d';\n// Optimization\nexport { detectFailPlane, propagateFailPlane, isListenerBehindFailPlane, distanceToFailPlane, minDistanceToFailPlanes, updateNodeFailPlane, clearNodeFailPlane, hasFailPlane } from './optimization/failplane3d';\nexport { createBuckets3D, isInsideSkipSphere, checkSkipSphere, createSkipSphere, invalidateSkipSphere, clearBucketFailPlanes, updateBucketSkipSphere, processBucketSkipSphere, getSkipSphereStats, DEFAULT_BUCKET_SIZE_3D } from './optimization/skipsphere3d';\n// Solver\nexport { OptimizedSolver3D, computePathLength, computeArrivalTime, getPathReflectionOrder, convertToDetailedPath3D } from './solver/solver3d';\n// Convenience aliases\nimport { Vector3 } from './core/vector3';\nimport { createShoeboxRoom } from './geometry/polygon3d';\nimport { OptimizedSolver3D } from './solver/solver3d';\n/**\n * 3D Sound source\n */\nexport class Source3D {\n    constructor(position) {\n        this.position = Vector3.clone(position);\n    }\n}\n/**\n * 3D Listener\n */\nexport class Listener3D {\n    constructor(position) {\n        this.position = Vector3.clone(position);\n    }\n    /**\n     * Update listener position\n     */\n    moveTo(position) {\n        this.position = Vector3.clone(position);\n    }\n}\n/**\n * Main 3D Solver class (alias for OptimizedSolver3D with simpler interface)\n */\nexport class Solver3D {\n    constructor(polygons, source, config) {\n        this.source = source;\n        this.solver = new OptimizedSolver3D(polygons, source.position, config);\n    }\n    /**\n     * Get all valid reflection paths to a listener\n     */\n    getPaths(listener) {\n        const pos = Array.isArray(listener) ? listener : listener.position;\n        return this.solver.getPaths(pos);\n    }\n    /**\n     * Get all valid reflection paths with detailed information about each reflection.\n     *\n     * This method returns the same paths as getPaths() but with additional details:\n     * - Angle of incidence and reflection at each surface\n     * - Surface normal vectors\n     * - Segment lengths and cumulative distances\n     * - Grazing incidence detection\n     *\n     * @param listener - Listener position or Listener3D object\n     * @returns Array of detailed reflection paths\n     */\n    getDetailedPaths(listener) {\n        const pos = Array.isArray(listener) ? listener : listener.position;\n        return this.solver.getDetailedPaths(pos);\n    }\n    /**\n     * Get performance metrics from last getPaths() call\n     */\n    getMetrics() {\n        return this.solver.getMetrics();\n    }\n    /**\n     * Clear optimization caches\n     */\n    clearCache() {\n        this.solver.clearCache();\n    }\n    /**\n     * Get number of leaf nodes in beam tree\n     */\n    getLeafNodeCount() {\n        return this.solver.getLeafNodeCount();\n    }\n    /**\n     * Get maximum reflection order\n     */\n    getMaxReflectionOrder() {\n        return this.solver.getMaxReflectionOrder();\n    }\n    /**\n     * Get beam data for visualization\n     */\n    getBeamsForVisualization(maxOrder) {\n        return this.solver.getBeamsForVisualization(maxOrder);\n    }\n    /**\n     * Debug a specific beam path by polygon IDs\n     * Logs detailed information about the path validation process\n     */\n    debugBeamPath(listener, polygonPath) {\n        const pos = Array.isArray(listener) ? listener : listener.position;\n        this.solver.debugBeamPath(pos, polygonPath);\n    }\n}\n/**\n * Create a simple shoebox room for testing\n */\nexport function createRoom(width, depth, height) {\n    return createShoeboxRoom(width, depth, height);\n}\n//# sourceMappingURL=beamtrace3d.js.map","import Solver from \"../solver\";\r\nimport * as THREE from \"three\";\r\nimport { MeshLine, MeshLineMaterial } from 'three.meshline';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport {\r\n  Polygon3D,\r\n  Source3D,\r\n  Solver3D,\r\n  computePathLength,\r\n  computeArrivalTime,\r\n  getPathReflectionOrder,\r\n} from 'beam-trace';\r\nimport type {\r\n  ReflectionPath3D,\r\n  DetailedReflectionPath3D,\r\n  BeamVisualizationData,\r\n  Vector3 as BT_Vector3\r\n} from 'beam-trace';\r\n\r\nimport Room, { getRooms } from \"../../objects/room\";\r\nimport Source from \"../../objects/source\";\r\nimport Receiver from \"../../objects/receiver\";\r\nimport Surface from \"../../objects/surface\";\r\nimport { emit, on } from \"../../messenger\";\r\nimport { renderer } from \"../../render/renderer\";\r\nimport { addSolver, removeSolver, setSolverProperty, useSolver, useContainer, useResult, ResultKind, Result } from \"../../store\";\r\nimport { pickProps } from \"../../common/helpers\";\r\nimport * as ac from \"../acoustics\";\r\nimport { normalize } from \"../acoustics\";\r\nimport FileSaver from 'file-saver';\r\nimport { audioEngine } from \"../../audio-engine/audio-engine\";\r\nimport chroma from 'chroma-js';\r\nimport { encodeBufferFromDirection, getAmbisonicChannelCount } from \"ambisonics\";\r\n\r\n// Helper to create a highlighted path line (same as ImageSourceSolver)\r\nfunction createHighlightLine(): THREE.Mesh {\r\n  const line = new MeshLine();\r\n  line.setPoints([]);\r\n  const material = new MeshLineMaterial({\r\n    lineWidth: 0.1,\r\n    color: 0xff0000,\r\n    sizeAttenuation: 1,\r\n  });\r\n  return new THREE.Mesh(line, material);\r\n}\r\n\r\n// Path visualization colors by reflection order\r\n// Uses the same color scale as LTPChart for consistency: orange (#ff8a0b) to navy (#000080)\r\nconst colorScale = chroma.scale(['#ff8a0b', '#000080']).mode('lch');\r\n\r\n// Get color for a given reflection order (0 = direct, 1 = 1st order, etc.)\r\n// maxOrder determines the number of colors in the scale\r\nfunction getOrderColor(order: number, maxOrder: number): number {\r\n  const numColors = maxOrder + 1;\r\n  const colors = colorScale.colors(numColors);\r\n  const colorIndex = Math.min(order, numColors - 1);\r\n  const color = chroma(colors[colorIndex]);\r\n  return parseInt(color.hex().slice(1), 16);\r\n}\r\n\r\nexport interface BeamTracePath {\r\n  points: THREE.Vector3[];\r\n  order: number;\r\n  length: number;\r\n  arrivalTime: number;\r\n  polygonIds: (number | null)[];\r\n  /** Direction from which the path arrives at the receiver (normalized) */\r\n  arrivalDirection: THREE.Vector3;\r\n  // Detailed reflection info (optional, populated when using getDetailedPaths)\r\n  reflections?: {\r\n    polygonId: number;\r\n    hitPoint: THREE.Vector3;\r\n    incidenceAngle: number;\r\n    surfaceNormal: THREE.Vector3;\r\n    isGrazing: boolean;\r\n  }[];\r\n}\r\n\r\nexport type VisualizationMode = \"rays\" | \"beams\" | \"both\";\r\n\r\nexport interface BeamTraceSaveObject {\r\n  name: string;\r\n  kind: \"beam-trace\";\r\n  uuid: string;\r\n  autoCalculate: boolean;\r\n  roomID: string;\r\n  sourceIDs: string[];\r\n  receiverIDs: string[];\r\n  maxReflectionOrder: number;\r\n  visualizationMode: VisualizationMode;\r\n  showAllBeams: boolean;\r\n  visibleOrders: number[];\r\n  frequencies: number[];\r\n  levelTimeProgression: string;\r\n  impulseResponseResult: string;\r\n}\r\n\r\nexport interface BeamTraceSolverParams {\r\n  name?: string;\r\n  uuid?: string;\r\n  roomID?: string;\r\n  sourceIDs?: string[];\r\n  receiverIDs?: string[];\r\n  maxReflectionOrder?: number;\r\n  visualizationMode?: VisualizationMode;\r\n  showAllBeams?: boolean;\r\n  visibleOrders?: number[];\r\n  frequencies?: number[];\r\n  levelTimeProgression?: string;\r\n  impulseResponseResult?: string;\r\n}\r\n\r\nconst defaults: Required<BeamTraceSolverParams> = {\r\n  name: \"Beam Trace\",\r\n  uuid: \"\",\r\n  roomID: \"\",\r\n  sourceIDs: [],\r\n  receiverIDs: [],\r\n  maxReflectionOrder: 3,\r\n  visualizationMode: \"rays\",\r\n  showAllBeams: false,\r\n  visibleOrders: [0, 1, 2, 3],\r\n  frequencies: [125, 250, 500, 1000, 2000, 4000, 8000],\r\n  levelTimeProgression: \"\",\r\n  impulseResponseResult: \"\",\r\n};\r\n\r\nexport class BeamTraceSolver extends Solver {\r\n  roomID: string;\r\n  sourceIDs: string[];\r\n  receiverIDs: string[];\r\n  maxReflectionOrder: number;\r\n  frequencies: number[];\r\n  levelTimeProgression: string;\r\n  impulseResponseResult: string;\r\n\r\n  private _visualizationMode: VisualizationMode;\r\n  private _showAllBeams: boolean;\r\n  private _visibleOrders: number[];\r\n  private _plotFrequency: number;\r\n  private _plotOrders: number[];\r\n\r\n  // Internal beam-trace solver instance\r\n  private btSolver: Solver3D | null = null;\r\n  private polygons: Polygon3D[] = [];\r\n  private surfaceToPolygonIndex: Map<string, number[]> = new Map();\r\n  private polygonToSurface: Map<number, Surface> = new Map();\r\n\r\n  // Results\r\n  validPaths: BeamTracePath[] = [];\r\n  impulseResponse!: AudioBuffer;\r\n  impulseResponsePlaying: boolean = false;\r\n\r\n  // Metrics\r\n  lastMetrics: {\r\n    validPathCount: number;\r\n    raycastCount: number;\r\n    failPlaneCacheHits: number;\r\n    bucketsSkipped: number;\r\n    bufferUsage?: {\r\n      linesUsed: number;\r\n      linesCapacity: number;\r\n      linesPercent: number;\r\n      pointsUsed: number;\r\n      pointsCapacity: number;\r\n      pointsPercent: number;\r\n      overflowWarning: boolean;\r\n    };\r\n  } | null = null;\r\n\r\n  // Group for virtual source meshes (replaces Points for reliable raycasting)\r\n  private virtualSourcesGroup: THREE.Group;\r\n  // Map from virtual source mesh to beam data for click detection\r\n  private virtualSourceMap: Map<THREE.Mesh, BeamVisualizationData & { polygonPath: number[] }> = new Map();\r\n  // Currently selected virtual source mesh\r\n  private selectedVirtualSource: THREE.Mesh | null = null;\r\n\r\n  // Click handler cleanup\r\n  private clickHandler: ((event: MouseEvent) => void) | null = null;\r\n  private hoverHandler: ((event: MouseEvent) => void) | null = null;\r\n\r\n  // Selected path highlight (for LTP chart click interaction)\r\n  private selectedPath: THREE.Mesh;\r\n  private selectedBeamsGroup: THREE.Group;\r\n\r\n  constructor(params: BeamTraceSolverParams = {}) {\r\n    super(params);\r\n    const p = { ...defaults, ...params };\r\n\r\n    this.kind = \"beam-trace\";\r\n    this.uuid = p.uuid || uuidv4();\r\n    this.name = p.name;\r\n    this.roomID = p.roomID;\r\n    this.sourceIDs = p.sourceIDs;\r\n    this.receiverIDs = p.receiverIDs;\r\n    this.maxReflectionOrder = p.maxReflectionOrder;\r\n    this.frequencies = p.frequencies;\r\n    this._visualizationMode = p.visualizationMode;\r\n    this._showAllBeams = p.showAllBeams;\r\n    this._visibleOrders = p.visibleOrders.length > 0 ? p.visibleOrders : Array.from({ length: p.maxReflectionOrder + 1 }, (_, i) => i);\r\n    this._plotFrequency = 1000;\r\n    this._plotOrders = Array.from({ length: p.maxReflectionOrder + 1 }, (_, i) => i); // [0, 1, 2, ... maxReflectionOrder]\r\n    this.levelTimeProgression = p.levelTimeProgression || uuidv4();\r\n    this.impulseResponseResult = p.impulseResponseResult || uuidv4();\r\n\r\n    // Auto-find room if not specified\r\n    if (!this.roomID) {\r\n      const rooms = getRooms();\r\n      if (rooms.length > 0) {\r\n        this.roomID = rooms[0].uuid;\r\n      }\r\n    }\r\n\r\n    // Create LTP result for this solver\r\n    emit(\"ADD_RESULT\", {\r\n      kind: ResultKind.LevelTimeProgression,\r\n      data: [],\r\n      info: {\r\n        initialSPL: [100],\r\n        frequency: [this._plotFrequency],\r\n        maxOrder: this.maxReflectionOrder,\r\n      },\r\n      name: `LTP - ${this.name}`,\r\n      uuid: this.levelTimeProgression,\r\n      from: this.uuid\r\n    } as Result<ResultKind.LevelTimeProgression>);\r\n\r\n    // Create IR result for this solver\r\n    emit(\"ADD_RESULT\", {\r\n      kind: ResultKind.ImpulseResponse,\r\n      data: [],\r\n      info: {\r\n        sampleRate: 44100,\r\n        sourceName: \"\",\r\n        receiverName: \"\",\r\n        sourceId: this.sourceIDs[0] || \"\",\r\n        receiverId: this.receiverIDs[0] || \"\"\r\n      },\r\n      name: `IR - ${this.name}`,\r\n      uuid: this.impulseResponseResult,\r\n      from: this.uuid\r\n    } as Result<ResultKind.ImpulseResponse>);\r\n\r\n    // Create selected path highlight line\r\n    this.selectedPath = createHighlightLine();\r\n    renderer.markup.add(this.selectedPath);\r\n\r\n    // Create group for highlighted beam lines\r\n    this.selectedBeamsGroup = new THREE.Group();\r\n    this.selectedBeamsGroup.name = \"selected-beams-highlight\";\r\n    renderer.markup.add(this.selectedBeamsGroup);\r\n\r\n    // Create group for virtual source spheres\r\n    this.virtualSourcesGroup = new THREE.Group();\r\n    this.virtualSourcesGroup.name = \"virtual-sources\";\r\n    renderer.markup.add(this.virtualSourcesGroup);\r\n  }\r\n\r\n  save(): BeamTraceSaveObject {\r\n    return {\r\n      ...pickProps([\r\n        \"name\",\r\n        \"kind\",\r\n        \"uuid\",\r\n        \"autoCalculate\",\r\n        \"roomID\",\r\n        \"sourceIDs\",\r\n        \"receiverIDs\",\r\n        \"maxReflectionOrder\",\r\n        \"frequencies\",\r\n        \"levelTimeProgression\",\r\n        \"impulseResponseResult\"\r\n      ], this),\r\n      visualizationMode: this._visualizationMode,\r\n      showAllBeams: this._showAllBeams,\r\n      visibleOrders: this._visibleOrders,\r\n    } as BeamTraceSaveObject;\r\n  }\r\n\r\n  restore(state: BeamTraceSaveObject): this {\r\n    this.name = state.name;\r\n    this.uuid = state.uuid;\r\n    this.autoCalculate = state.autoCalculate ?? false;\r\n    this.roomID = state.roomID;\r\n    this.sourceIDs = state.sourceIDs;\r\n    this.receiverIDs = state.receiverIDs;\r\n    this.maxReflectionOrder = state.maxReflectionOrder;\r\n    this._visualizationMode = state.visualizationMode || \"rays\";\r\n    this._showAllBeams = state.showAllBeams ?? false;\r\n    this._visibleOrders = state.visibleOrders ?? Array.from({ length: this.maxReflectionOrder + 1 }, (_, i) => i);\r\n    this.frequencies = state.frequencies;\r\n    this.levelTimeProgression = state.levelTimeProgression || uuidv4();\r\n    this.impulseResponseResult = state.impulseResponseResult || uuidv4();\r\n    return this;\r\n  }\r\n\r\n  dispose() {\r\n    this.clearVisualization();\r\n    this.removeClickHandler();\r\n    renderer.markup.remove(this.selectedPath);\r\n    renderer.markup.remove(this.selectedBeamsGroup);\r\n    renderer.markup.remove(this.virtualSourcesGroup);\r\n    emit(\"REMOVE_RESULT\", this.levelTimeProgression);\r\n    emit(\"REMOVE_RESULT\", this.impulseResponseResult);\r\n  }\r\n\r\n  private setupClickHandler() {\r\n    // Remove existing handlers if any\r\n    this.removeClickHandler();\r\n\r\n    const canvas = renderer.renderer.domElement;\r\n\r\n    // Helper to get mouse position in normalized device coordinates\r\n    const getMouseNDC = (event: MouseEvent): THREE.Vector2 => {\r\n      const rect = canvas.getBoundingClientRect();\r\n      return new THREE.Vector2(\r\n        ((event.clientX - rect.left) / rect.width) * 2 - 1,\r\n        -((event.clientY - rect.top) / rect.height) * 2 + 1\r\n      );\r\n    };\r\n\r\n    // Hover handler - change cursor when over a clickable virtual source\r\n    this.hoverHandler = (event: MouseEvent) => {\r\n      if (this.virtualSourceMap.size === 0) {\r\n        canvas.style.cursor = 'default';\r\n        return;\r\n      }\r\n\r\n      const mouse = getMouseNDC(event);\r\n      const raycaster = new THREE.Raycaster();\r\n      raycaster.setFromCamera(mouse, renderer.camera);\r\n\r\n      const virtualSourceMeshes = Array.from(this.virtualSourceMap.keys());\r\n      const intersects = raycaster.intersectObjects(virtualSourceMeshes);\r\n\r\n      if (intersects.length > 0) {\r\n        canvas.style.cursor = 'pointer';\r\n      } else {\r\n        canvas.style.cursor = 'default';\r\n      }\r\n    };\r\n\r\n    // Click handler\r\n    this.clickHandler = (event: MouseEvent) => {\r\n      // Only handle left clicks\r\n      if (event.button !== 0) return;\r\n      if (this.virtualSourceMap.size === 0) return;\r\n\r\n      const mouse = getMouseNDC(event);\r\n      const raycaster = new THREE.Raycaster();\r\n      raycaster.setFromCamera(mouse, renderer.camera);\r\n\r\n      const virtualSourceMeshes = Array.from(this.virtualSourceMap.keys());\r\n      const intersects = raycaster.intersectObjects(virtualSourceMeshes);\r\n\r\n      if (intersects.length > 0) {\r\n        const clickedMesh = intersects[0].object as THREE.Mesh;\r\n        const beam = this.virtualSourceMap.get(clickedMesh);\r\n\r\n        if (beam) {\r\n          // Toggle selection - if already selected, deselect\r\n          if (this.selectedVirtualSource === clickedMesh) {\r\n            this.selectedVirtualSource = null;\r\n            this.clearSelectedBeams();\r\n          } else {\r\n            this.selectedVirtualSource = clickedMesh;\r\n            this.highlightVirtualSourcePath(beam);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    canvas.addEventListener('click', this.clickHandler);\r\n    canvas.addEventListener('mousemove', this.hoverHandler);\r\n  }\r\n\r\n  // Highlight the ray path from a clicked virtual source to the receiver\r\n  // beam contains polygonPath which is the sequence of polygon IDs for reflections\r\n  private highlightVirtualSourcePath(beam: BeamVisualizationData & { polygonPath: number[] }) {\r\n    // Clear previous selections\r\n    (this.selectedPath.geometry as MeshLine).setPoints([]);\r\n    this.clearSelectedBeams();\r\n\r\n    const colorHex = getOrderColor(beam.reflectionOrder, this.maxReflectionOrder);\r\n    const vs = new THREE.Vector3(beam.virtualSource[0], beam.virtualSource[1], beam.virtualSource[2]);\r\n\r\n    // Get receiver position\r\n    if (this.receiverIDs.length === 0) return;\r\n    const receiver = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\r\n    if (!receiver) return;\r\n    const receiverPos = receiver.position.clone();\r\n\r\n    // Draw dashed line from virtual source to receiver (the \"unfolded\" path)\r\n    const dashedMaterial = new THREE.LineDashedMaterial({\r\n      color: colorHex,\r\n      transparent: true,\r\n      opacity: 0.4,\r\n      dashSize: 0.3,\r\n      gapSize: 0.15\r\n    });\r\n    const unfoldedLineGeom = new THREE.BufferGeometry().setFromPoints([vs, receiverPos]);\r\n    const unfoldedLine = new THREE.Line(unfoldedLineGeom, dashedMaterial);\r\n    unfoldedLine.computeLineDistances();\r\n    this.selectedBeamsGroup.add(unfoldedLine);\r\n\r\n    // Add a larger highlight sphere on the virtual source\r\n    const highlightGeom = new THREE.SphereGeometry(0.18, 16, 16);\r\n    const highlightMat = new THREE.MeshBasicMaterial({\r\n      color: colorHex,\r\n      transparent: true,\r\n      opacity: 0.4\r\n    });\r\n    const highlightMesh = new THREE.Mesh(highlightGeom, highlightMat);\r\n    highlightMesh.position.copy(vs);\r\n    this.selectedBeamsGroup.add(highlightMesh);\r\n\r\n    // Find the matching path inside the room by comparing polygon sequence\r\n    const polygonPath = beam.polygonPath;\r\n    if (!polygonPath || polygonPath.length === 0) return;\r\n\r\n    const targetOrder = beam.reflectionOrder;\r\n\r\n    for (const path of this.validPaths) {\r\n      // Path structure: path.polygonIds = [null (listener), polyN, poly_{N-1}, ..., poly_1, null (source)]\r\n      // A path with N reflections has length N+2 (including source and listener points)\r\n      const pathOrder = path.order;\r\n\r\n      if (pathOrder !== targetOrder) continue;\r\n\r\n      // Check if the polygon sequence matches\r\n      // polygonPath is [poly0, poly1, ..., polyN] (first to last reflection, root to leaf in beam tree)\r\n      // path.polygonIds is [null, polyN, poly_{N-1}, ..., poly_1, null] (leaf to root order)\r\n      // So we need to compare in reverse: polygonPath[i] should match path.polygonIds[pathOrder - i]\r\n      let matches = true;\r\n      for (let i = 0; i < polygonPath.length; i++) {\r\n        const pathIndex = pathOrder - i; // Index of reflection point in path (1-based from listener)\r\n        const pathPolygonId = path.polygonIds[pathIndex];\r\n        if (pathPolygonId !== polygonPath[i]) {\r\n          matches = false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (matches) {\r\n        // Draw the actual ray path inside the room as thick cylinders\r\n        const points = path.points;\r\n        const numReflections = path.order;\r\n\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n          const start = points[i];\r\n          const end = points[i + 1];\r\n          const segLen = start.distanceTo(end);\r\n          const midPoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);\r\n\r\n          // Color based on segment order\r\n          const segmentOrder = numReflections - i;\r\n          const segColor = (segmentOrder === 0) ? 0xffffff : getOrderColor(segmentOrder, this.maxReflectionOrder);\r\n\r\n          const cylGeom = new THREE.CylinderGeometry(0.025, 0.025, segLen, 8);\r\n          const cylMat = new THREE.MeshBasicMaterial({ color: segColor });\r\n          const cyl = new THREE.Mesh(cylGeom, cylMat);\r\n\r\n          cyl.position.copy(midPoint);\r\n          const direction = new THREE.Vector3().subVectors(end, start).normalize();\r\n          const quaternion = new THREE.Quaternion();\r\n          quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);\r\n          cyl.setRotationFromQuaternion(quaternion);\r\n\r\n          this.selectedBeamsGroup.add(cyl);\r\n        }\r\n\r\n        // Add spheres at reflection points\r\n        for (let i = 1; i < path.points.length - 1; i++) {\r\n          const pointOrder = numReflections - i + 1;\r\n          const pointColor = getOrderColor(pointOrder, this.maxReflectionOrder);\r\n\r\n          const pointGeom = new THREE.SphereGeometry(0.08, 12, 12);\r\n          const pointMat = new THREE.MeshBasicMaterial({ color: pointColor });\r\n          const pointMesh = new THREE.Mesh(pointGeom, pointMat);\r\n          pointMesh.position.copy(path.points[i]);\r\n          this.selectedBeamsGroup.add(pointMesh);\r\n        }\r\n\r\n        renderer.needsToRender = true;\r\n        return;\r\n      }\r\n    }\r\n\r\n    renderer.needsToRender = true;\r\n  }\r\n\r\n  private removeClickHandler() {\r\n    const canvas = renderer.renderer.domElement;\r\n    if (this.clickHandler) {\r\n      canvas.removeEventListener('click', this.clickHandler);\r\n      this.clickHandler = null;\r\n    }\r\n    if (this.hoverHandler) {\r\n      canvas.removeEventListener('mousemove', this.hoverHandler);\r\n      this.hoverHandler = null;\r\n      canvas.style.cursor = 'default';\r\n    }\r\n  }\r\n\r\n  // Convert room surfaces to beam-trace Polygon3D format\r\n  private extractPolygons(): Polygon3D[] {\r\n    const room = this.room;\r\n    if (!room) return [];\r\n\r\n    const polygons: Polygon3D[] = [];\r\n    this.surfaceToPolygonIndex.clear();\r\n    this.polygonToSurface.clear();\r\n\r\n    room.allSurfaces.forEach((surface: Surface) => {\r\n      const surfacePolygons = this.surfaceToPolygons(surface);\r\n      const startIndex = polygons.length;\r\n\r\n      surfacePolygons.forEach((poly, i) => {\r\n        this.polygonToSurface.set(startIndex + i, surface);\r\n        polygons.push(poly);\r\n      });\r\n\r\n      this.surfaceToPolygonIndex.set(\r\n        surface.uuid,\r\n        surfacePolygons.map((_, i) => startIndex + i)\r\n      );\r\n    });\r\n\r\n    return polygons;\r\n  }\r\n\r\n  // Convert a Surface to Polygon3D objects\r\n  private surfaceToPolygons(surface: Surface): Polygon3D[] {\r\n    const polygons: Polygon3D[] = [];\r\n    const geometry = surface.geometry;\r\n    const posAttr = geometry.getAttribute('position');\r\n\r\n    if (!posAttr) return polygons;\r\n\r\n    // Get world matrix for the surface\r\n    surface.updateMatrixWorld(true);\r\n    const worldMatrix = surface.matrixWorld;\r\n\r\n    // Process triangles\r\n    const indices = geometry.getIndex();\r\n    const positions = posAttr.array;\r\n\r\n    const processTriangle = (i0: number, i1: number, i2: number) => {\r\n      const v0 = new THREE.Vector3(\r\n        positions[i0 * 3],\r\n        positions[i0 * 3 + 1],\r\n        positions[i0 * 3 + 2]\r\n      ).applyMatrix4(worldMatrix);\r\n\r\n      const v1 = new THREE.Vector3(\r\n        positions[i1 * 3],\r\n        positions[i1 * 3 + 1],\r\n        positions[i1 * 3 + 2]\r\n      ).applyMatrix4(worldMatrix);\r\n\r\n      const v2 = new THREE.Vector3(\r\n        positions[i2 * 3],\r\n        positions[i2 * 3 + 1],\r\n        positions[i2 * 3 + 2]\r\n      ).applyMatrix4(worldMatrix);\r\n\r\n      const vertices: BT_Vector3[] = [\r\n        [v0.x, v0.y, v0.z],\r\n        [v1.x, v1.y, v1.z],\r\n        [v2.x, v2.y, v2.z]\r\n      ];\r\n\r\n      const polygon = Polygon3D.create(vertices);\r\n      polygons.push(polygon);\r\n    };\r\n\r\n    if (indices) {\r\n      const indexArray = indices.array;\r\n      for (let i = 0; i < indexArray.length; i += 3) {\r\n        processTriangle(indexArray[i], indexArray[i + 1], indexArray[i + 2]);\r\n      }\r\n    } else {\r\n      // Non-indexed geometry\r\n      const numVertices = posAttr.count;\r\n      for (let i = 0; i < numVertices; i += 3) {\r\n        processTriangle(i, i + 1, i + 2);\r\n      }\r\n    }\r\n\r\n    return polygons;\r\n  }\r\n\r\n  // Build/rebuild the beam-trace solver\r\n  buildSolver() {\r\n    if (this.sourceIDs.length === 0) {\r\n      console.warn(\"BeamTraceSolver: No source selected\");\r\n      return;\r\n    }\r\n\r\n    const source = useContainer.getState().containers[this.sourceIDs[0]] as Source;\r\n    if (!source) {\r\n      console.warn(\"BeamTraceSolver: Source not found\");\r\n      return;\r\n    }\r\n\r\n    // Extract room geometry\r\n    this.polygons = this.extractPolygons();\r\n    if (this.polygons.length === 0) {\r\n      console.warn(\"BeamTraceSolver: No polygons extracted from room\");\r\n      return;\r\n    }\r\n\r\n    // Create beam-trace source\r\n    const sourcePos: BT_Vector3 = [\r\n      source.position.x,\r\n      source.position.y,\r\n      source.position.z\r\n    ];\r\n    const btSource = new Source3D(sourcePos);\r\n\r\n    // Create solver\r\n    this.btSolver = new Solver3D(this.polygons, btSource, {\r\n      maxReflectionOrder: this.maxReflectionOrder\r\n    });\r\n\r\n    console.log(`BeamTraceSolver: Built with ${this.polygons.length} polygons, max order ${this.maxReflectionOrder}`);\r\n  }\r\n\r\n  // Calculate paths to all receivers\r\n  calculate() {\r\n    if (this.sourceIDs.length === 0 || this.receiverIDs.length === 0) {\r\n      console.warn(\"BeamTraceSolver: Need at least one source and one receiver\");\r\n      return;\r\n    }\r\n\r\n    // Rebuild solver (in case source moved or room changed)\r\n    this.buildSolver();\r\n\r\n    if (!this.btSolver) {\r\n      console.warn(\"BeamTraceSolver: Solver not built\");\r\n      return;\r\n    }\r\n\r\n    this.validPaths = [];\r\n    this.clearVisualization();\r\n\r\n    // Process each receiver\r\n    this.receiverIDs.forEach(receiverID => {\r\n      const receiver = useContainer.getState().containers[receiverID] as Receiver;\r\n      if (!receiver) return;\r\n\r\n      const listenerPos: BT_Vector3 = [\r\n        receiver.position.x,\r\n        receiver.position.y,\r\n        receiver.position.z\r\n      ];\r\n      // Get paths from beam-trace solver\r\n      const paths = this.btSolver!.getPaths(listenerPos);\r\n      this.lastMetrics = this.btSolver!.getMetrics();\r\n\r\n      // Convert to our format\r\n      paths.forEach(path => {\r\n        const btPath = this.convertPath(path);\r\n        this.validPaths.push(btPath);\r\n      });\r\n    });\r\n\r\n    // Sort by arrival time\r\n    this.validPaths.sort((a, b) => a.arrivalTime - b.arrivalTime);\r\n\r\n    // Update visualization based on current mode\r\n    switch (this._visualizationMode) {\r\n      case \"rays\":\r\n        this.drawPaths();\r\n        break;\r\n      case \"beams\":\r\n        this.drawBeams();\r\n        break;\r\n      case \"both\":\r\n        this.drawPaths();\r\n        this.drawBeams();\r\n        break;\r\n    }\r\n\r\n    // Calculate LTP result\r\n    this.calculateLTP(343);\r\n\r\n    console.log(`BeamTraceSolver: Found ${this.validPaths.length} valid paths`);\r\n    if (this.lastMetrics) {\r\n      console.log(`  Raycasts: ${this.lastMetrics.raycastCount}`);\r\n      console.log(`  Cache hits: ${this.lastMetrics.failPlaneCacheHits}`);\r\n      console.log(`  Buckets skipped: ${this.lastMetrics.bucketsSkipped}`);\r\n    }\r\n\r\n    renderer.needsToRender = true;\r\n  }\r\n\r\n  // Convert beam-trace path to our format\r\n  private convertPath(path: ReflectionPath3D): BeamTracePath {\r\n    const points = path.map(p => new THREE.Vector3(p.position[0], p.position[1], p.position[2]));\r\n    const length = computePathLength(path);\r\n    const arrivalTime = computeArrivalTime(path);\r\n    const order = getPathReflectionOrder(path);\r\n    const polygonIds = path.map(p => p.polygonId);\r\n\r\n    // Compute arrival direction (direction from second-to-last point to receiver)\r\n    // points[0] is the receiver, points[1] is the last reflection point (or source for direct)\r\n    let arrivalDirection: THREE.Vector3;\r\n    if (points.length >= 2) {\r\n      arrivalDirection = new THREE.Vector3()\r\n        .subVectors(points[0], points[1])\r\n        .normalize()\r\n        .negate(); // Negate to get direction ray arrives FROM\r\n    } else {\r\n      // Fallback for edge case\r\n      arrivalDirection = new THREE.Vector3(0, 0, 1);\r\n    }\r\n\r\n    return { points, order, length, arrivalTime, polygonIds, arrivalDirection };\r\n  }\r\n\r\n  // Calculate Level Time Progression result\r\n  calculateLTP(_c: number = 343) {\r\n    if (this.validPaths.length === 0) return;\r\n\r\n    // Sort paths by arrival time\r\n    const sortedPaths = [...this.validPaths].sort((a, b) => a.arrivalTime - b.arrivalTime);\r\n\r\n    // Get the current LTP result and update it\r\n    const levelTimeProgression = { ...useResult.getState().results[this.levelTimeProgression] as Result<ResultKind.LevelTimeProgression> };\r\n    levelTimeProgression.data = [];\r\n    levelTimeProgression.info = {\r\n      ...levelTimeProgression.info,\r\n      maxOrder: this.maxReflectionOrder,\r\n      frequency: [this._plotFrequency]\r\n    };\r\n\r\n    // Calculate arrival pressure for each path\r\n    for (let i = 0; i < sortedPaths.length; i++) {\r\n      const path = sortedPaths[i];\r\n      const pressure = this.calculateArrivalPressure(levelTimeProgression.info.initialSPL, path);\r\n      const pressureLp = ac.P2Lp(pressure) as number[];\r\n\r\n      levelTimeProgression.data.push({\r\n        time: path.arrivalTime,\r\n        pressure: pressureLp,\r\n        arrival: i + 1,\r\n        order: path.order,\r\n        uuid: `${this.uuid}-path-${i}`\r\n      });\r\n    }\r\n\r\n    emit(\"UPDATE_RESULT\", { uuid: this.levelTimeProgression, result: levelTimeProgression });\r\n  }\r\n\r\n  // Clear LTP data\r\n  clearLevelTimeProgressionData() {\r\n    const levelTimeProgression = { ...useResult.getState().results[this.levelTimeProgression] };\r\n    levelTimeProgression.data = [];\r\n    emit(\"UPDATE_RESULT\", { uuid: this.levelTimeProgression, result: levelTimeProgression });\r\n  }\r\n\r\n  // Setter for plot frequency (recalculates LTP when changed)\r\n  set plotFrequency(f: number) {\r\n    this._plotFrequency = f;\r\n    this.calculateLTP(343);\r\n  }\r\n\r\n  get plotFrequency(): number {\r\n    return this._plotFrequency;\r\n  }\r\n\r\n  // Plot orders for LTP chart filtering (mirrors ImageSourceSolver API)\r\n  get plotOrders(): number[] {\r\n    return this._plotOrders;\r\n  }\r\n\r\n  set plotOrders(orders: number[]) {\r\n    this._plotOrders = orders;\r\n    // No need to redraw visualization - beam trace doesn't filter by plotOrders\r\n    // This is only used by the LTP chart\r\n  }\r\n\r\n  // Toggle ray path highlight when clicking on LTP chart bar\r\n  // uuid format is `${this.uuid}-path-${index}` from calculateLTP\r\n  toggleRayPathHighlight(pathUuid: string) {\r\n    // Extract path index from uuid (format: `{solverUuid}-path-{index}`)\r\n    const match = pathUuid.match(/-path-(\\d+)$/);\r\n    if (!match) {\r\n      console.warn('BeamTraceSolver: Invalid path UUID format:', pathUuid);\r\n      return;\r\n    }\r\n\r\n    const pathIndex = parseInt(match[1], 10);\r\n    this.highlightPathByIndex(pathIndex);\r\n  }\r\n\r\n  // Visualization methods\r\n  private clearVisualization() {\r\n    // Clear lines and points using renderer.markup (same as ImageSourceSolver)\r\n    renderer.markup.clearLines();\r\n    renderer.markup.clearPoints();\r\n    // Clear virtual source meshes\r\n    this.clearVirtualSources();\r\n    this.virtualSourceMap.clear();\r\n    this.selectedVirtualSource = null;\r\n  }\r\n\r\n  private drawPaths() {\r\n    // Use renderer.markup.addLine() like ImageSourceSolver for consistent visualization\r\n    // Use the same color scale as LTPChart for visual consistency\r\n    // Filter paths by visible orders\r\n    const filteredPaths = this.validPaths.filter(path => this._visibleOrders.includes(path.order));\r\n\r\n    filteredPaths.forEach(path => {\r\n      const colorHex = getOrderColor(path.order, this.maxReflectionOrder);\r\n      // Convert hex color to RGB (0-1 range)\r\n      const r = ((colorHex >> 16) & 0xff) / 255;\r\n      const g = ((colorHex >> 8) & 0xff) / 255;\r\n      const b = (colorHex & 0xff) / 255;\r\n      const color: [number, number, number] = [r, g, b];\r\n\r\n      // Draw line segments between consecutive points\r\n      for (let i = 0; i < path.points.length - 1; i++) {\r\n        const p1 = path.points[i];\r\n        const p2 = path.points[i + 1];\r\n        renderer.markup.addLine(\r\n          [p1.x, p1.y, p1.z],\r\n          [p2.x, p2.y, p2.z],\r\n          color,\r\n          color\r\n        );\r\n      }\r\n    });\r\n\r\n    // Get buffer usage stats and store in metrics\r\n    const usageStats = renderer.markup.getUsageStats();\r\n    if (this.lastMetrics) {\r\n      this.lastMetrics.bufferUsage = usageStats;\r\n    }\r\n\r\n    // Log buffer usage warnings\r\n    if (usageStats.overflowWarning) {\r\n      console.error(`⚠️ Path buffer overflow! Lines: ${usageStats.linesUsed}/${usageStats.linesCapacity}. Reduce reflection order.`);\r\n    } else if (usageStats.linesPercent > 80) {\r\n      console.warn(`Buffer usage high: Lines ${usageStats.linesPercent.toFixed(1)}%`);\r\n    }\r\n  }\r\n\r\n  private drawBeams() {\r\n    if (!this.btSolver) return;\r\n\r\n    // Clear virtual source meshes and map\r\n    this.clearVirtualSources();\r\n    this.virtualSourceMap.clear();\r\n    this.selectedVirtualSource = null;\r\n\r\n    // Get current paths to determine which virtual sources are valid\r\n    const paths = this.validPaths;\r\n\r\n    // Build a map of valid paths by their polygon sequence for quick lookup\r\n    const validPathsByPolygonSequence = new Map<string, BeamTracePath>();\r\n    paths.forEach(path => {\r\n      // Build polygon sequence key (excluding null entries for source/receiver)\r\n      const polygonSequence = path.polygonIds.filter(id => id !== null).join(',');\r\n      if (polygonSequence) {\r\n        validPathsByPolygonSequence.set(polygonSequence, path);\r\n      }\r\n    });\r\n\r\n    const beamData = this.btSolver.getBeamsForVisualization(this.maxReflectionOrder);\r\n\r\n    beamData.forEach((beam: BeamVisualizationData) => {\r\n      // Filter by visible orders\r\n      if (!this._visibleOrders.includes(beam.reflectionOrder)) {\r\n        return;\r\n      }\r\n\r\n      // Check if this beam has a valid path to the receiver\r\n      const hasValidPath = this.beamHasValidPath(beam, paths);\r\n\r\n      // Skip virtual sources without valid paths unless showAllBeams is enabled\r\n      if (!hasValidPath && !this._showAllBeams) {\r\n        return;\r\n      }\r\n\r\n      // Calculate sphere radius based on reflection order (smaller for higher orders)\r\n      const radius = Math.max(0.05, 0.10 - beam.reflectionOrder * 0.01);\r\n\r\n      // Get color based on reflection order\r\n      const colorHex = getOrderColor(beam.reflectionOrder, this.maxReflectionOrder);\r\n\r\n      // Dim invalid beams\r\n      let finalColor = colorHex;\r\n      if (!hasValidPath) {\r\n        // Mix with gray to dim\r\n        const r = ((colorHex >> 16) & 0xff) * 0.4 + 128 * 0.6;\r\n        const g = ((colorHex >> 8) & 0xff) * 0.4 + 128 * 0.6;\r\n        const b = (colorHex & 0xff) * 0.4 + 128 * 0.6;\r\n        finalColor = (Math.round(r) << 16) | (Math.round(g) << 8) | Math.round(b);\r\n      }\r\n\r\n      const vs = new THREE.Vector3(beam.virtualSource[0], beam.virtualSource[1], beam.virtualSource[2]);\r\n\r\n      // Create virtual source sphere mesh\r\n      const vsGeom = new THREE.SphereGeometry(radius, 12, 12);\r\n      const vsMat = new THREE.MeshStandardMaterial({\r\n        color: finalColor,\r\n        transparent: !hasValidPath,\r\n        opacity: hasValidPath ? 1.0 : 0.4,\r\n        roughness: 0.6,\r\n        metalness: 0.1\r\n      });\r\n      const vsMesh = new THREE.Mesh(vsGeom, vsMat);\r\n      vsMesh.position.copy(vs);\r\n      this.virtualSourcesGroup.add(vsMesh);\r\n\r\n      // Register this mesh for click detection (only valid beams are clickable)\r\n      if (hasValidPath) {\r\n        this.virtualSourceMap.set(vsMesh, {\r\n          ...beam,\r\n          polygonPath: beam.polygonPath || []\r\n        });\r\n      }\r\n    });\r\n\r\n    // Setup click handler for virtual source selection\r\n    this.setupClickHandler();\r\n\r\n    renderer.needsToRender = true;\r\n  }\r\n\r\n  // Check if a beam has a valid path to the receiver\r\n  private beamHasValidPath(beam: BeamVisualizationData, paths: BeamTracePath[]): boolean {\r\n    const polygonPath = beam.polygonPath;\r\n    if (!polygonPath || polygonPath.length === 0) return false;\r\n\r\n    const targetOrder = beam.reflectionOrder;\r\n\r\n    for (const path of paths) {\r\n      if (path.order !== targetOrder) continue;\r\n\r\n      // Check if the polygon sequence matches\r\n      // polygonPath is [poly0, poly1, ..., polyN] (first to last reflection)\r\n      // path.polygonIds is [null, polyN, poly_{N-1}, ..., poly_1, null] (leaf to root order)\r\n      let matches = true;\r\n      for (let i = 0; i < polygonPath.length; i++) {\r\n        const pathIndex = targetOrder - i;\r\n        const pathPolygonId = path.polygonIds[pathIndex];\r\n        if (pathPolygonId !== polygonPath[i]) {\r\n          matches = false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (matches) return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // Clear virtual source meshes\r\n  private clearVirtualSources() {\r\n    while (this.virtualSourcesGroup.children.length > 0) {\r\n      const child = this.virtualSourcesGroup.children[0];\r\n      this.virtualSourcesGroup.remove(child);\r\n      if (child instanceof THREE.Mesh) {\r\n        child.geometry?.dispose();\r\n        const material = child.material;\r\n        if (Array.isArray(material)) {\r\n          for (const mat of material) {\r\n            if (mat instanceof THREE.Material) {\r\n              mat.dispose();\r\n            }\r\n          }\r\n        } else if (material instanceof THREE.Material) {\r\n          material.dispose();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Calculate impulse response\r\n  async calculateImpulseResponse(): Promise<AudioBuffer> {\r\n    if (this.validPaths.length === 0) {\r\n      throw new Error(\"No paths calculated yet. Run calculate() first.\");\r\n    }\r\n\r\n    const sampleRate = audioEngine.sampleRate;\r\n    const initialSPL = 100;\r\n    const spls = Array(this.frequencies.length).fill(initialSPL);\r\n\r\n    const totalTime = this.validPaths[this.validPaths.length - 1].arrivalTime + 0.05;\r\n    const numberOfSamples = Math.floor(sampleRate * totalTime) * 2;\r\n\r\n    const samples: Float32Array[] = [];\r\n    for (let f = 0; f < this.frequencies.length; f++) {\r\n      samples.push(new Float32Array(numberOfSamples));\r\n    }\r\n\r\n    // Add contributions from each path\r\n    for (const path of this.validPaths) {\r\n      const randomPhase = Math.random() > 0.5 ? 1 : -1;\r\n      const pressure = this.calculateArrivalPressure(spls, path);\r\n      const roundedSample = Math.floor(path.arrivalTime * sampleRate);\r\n\r\n      for (let f = 0; f < this.frequencies.length; f++) {\r\n        if (roundedSample < samples[f].length) {\r\n          samples[f][roundedSample] += pressure[f] * randomPhase;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Use filter worker (similar to RayTracer)\r\n    const FilterWorker = () => new Worker(new URL('../../audio-engine/filter.worker.ts', import.meta.url));\r\n    const worker = FilterWorker();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      worker.postMessage({ samples });\r\n\r\n      worker.onmessage = (event) => {\r\n        const filteredSamples = event.data.samples as Float32Array[];\r\n        const signal = new Float32Array(filteredSamples[0].length >> 1);\r\n\r\n        let max = 0;\r\n        for (let i = 0; i < filteredSamples.length; i++) {\r\n          for (let j = 0; j < signal.length; j++) {\r\n            signal[j] += filteredSamples[i][j];\r\n            if (Math.abs(signal[j]) > max) {\r\n              max = Math.abs(signal[j]);\r\n            }\r\n          }\r\n        }\r\n\r\n        const normalizedSignal = normalize(signal);\r\n        const offlineContext = audioEngine.createOfflineContext(1, signal.length, sampleRate);\r\n        const source = audioEngine.createBufferSource(normalizedSignal, offlineContext);\r\n\r\n        source.connect(offlineContext.destination);\r\n        source.start();\r\n\r\n        audioEngine.renderContextAsync(offlineContext)\r\n          .then(ir => {\r\n            this.impulseResponse = ir;\r\n            this.updateImpulseResponseResult(ir, sampleRate);\r\n            resolve(ir);\r\n          })\r\n          .catch(reject)\r\n          .finally(() => worker.terminate());\r\n      };\r\n\r\n      worker.onerror = (error) => {\r\n        worker.terminate();\r\n        reject(error);\r\n      };\r\n    });\r\n  }\r\n\r\n  // Calculate arrival pressure for a path\r\n  private calculateArrivalPressure(initialSPL: number[], path: BeamTracePath): number[] {\r\n    const intensities = ac.P2I(ac.Lp2P(initialSPL)) as number[];\r\n\r\n    // Apply absorption at each reflection\r\n    path.polygonIds.forEach(polygonId => {\r\n      if (polygonId === null) return; // Source or receiver point\r\n\r\n      const surface = this.polygonToSurface.get(polygonId);\r\n      if (!surface) return;\r\n\r\n      for (let f = 0; f < this.frequencies.length; f++) {\r\n        const R = 1 - surface.absorptionFunction(this.frequencies[f]);\r\n        intensities[f] *= R;\r\n      }\r\n    });\r\n\r\n    // Convert back to SPL and apply air absorption\r\n    const arrivalLp = ac.P2Lp(ac.I2P(intensities)) as number[];\r\n    const airAttenuationdB = ac.airAttenuation(this.frequencies);\r\n\r\n    for (let f = 0; f < this.frequencies.length; f++) {\r\n      arrivalLp[f] -= airAttenuationdB[f] * path.length;\r\n    }\r\n\r\n    return ac.Lp2P(arrivalLp) as number[];\r\n  }\r\n\r\n  // Update the IR result with calculated data\r\n  private updateImpulseResponseResult(ir: AudioBuffer, sampleRate: number) {\r\n    const containers = useContainer.getState().containers;\r\n    const sourceName = this.sourceIDs.length > 0 ? containers[this.sourceIDs[0]]?.name || 'source' : 'source';\r\n    const receiverName = this.receiverIDs.length > 0 ? containers[this.receiverIDs[0]]?.name || 'receiver' : 'receiver';\r\n\r\n    // Convert AudioBuffer to time/amplitude data for the chart\r\n    const channelData = ir.getChannelData(0);\r\n    const data: { time: number; amplitude: number }[] = [];\r\n\r\n    // Downsample for display (show every Nth sample to keep data manageable)\r\n    const downsampleFactor = Math.max(1, Math.floor(channelData.length / 2000));\r\n    for (let i = 0; i < channelData.length; i += downsampleFactor) {\r\n      data.push({\r\n        time: i / sampleRate,\r\n        amplitude: channelData[i]\r\n      });\r\n    }\r\n\r\n    console.log(`BeamTraceSolver: Updating IR result with ${data.length} samples, duration: ${(channelData.length / sampleRate).toFixed(3)}s`);\r\n\r\n    const result: Result<ResultKind.ImpulseResponse> = {\r\n      kind: ResultKind.ImpulseResponse,\r\n      data,\r\n      info: {\r\n        sampleRate,\r\n        sourceName,\r\n        receiverName,\r\n        sourceId: this.sourceIDs[0] || \"\",\r\n        receiverId: this.receiverIDs[0] || \"\"\r\n      },\r\n      name: `IR: ${sourceName} → ${receiverName}`,\r\n      uuid: this.impulseResponseResult,\r\n      from: this.uuid\r\n    };\r\n\r\n    emit(\"UPDATE_RESULT\", { uuid: this.impulseResponseResult, result });\r\n  }\r\n\r\n  async playImpulseResponse() {\r\n    if (!this.impulseResponse) {\r\n      await this.calculateImpulseResponse();\r\n    }\r\n\r\n    if (audioEngine.context.state === 'suspended') {\r\n      audioEngine.context.resume();\r\n    }\r\n\r\n    const source = audioEngine.context.createBufferSource();\r\n    source.buffer = this.impulseResponse;\r\n    source.connect(audioEngine.context.destination);\r\n    source.start();\r\n\r\n    emit(\"BEAMTRACE_SET_PROPERTY\", { uuid: this.uuid, property: \"impulseResponsePlaying\", value: true });\r\n\r\n    source.onended = () => {\r\n      source.stop();\r\n      source.disconnect(audioEngine.context.destination);\r\n      emit(\"BEAMTRACE_SET_PROPERTY\", { uuid: this.uuid, property: \"impulseResponsePlaying\", value: false });\r\n    };\r\n  }\r\n\r\n  async downloadImpulseResponse(filename: string, sampleRate = audioEngine.sampleRate) {\r\n    if (!this.impulseResponse) {\r\n      await this.calculateImpulseResponse();\r\n    }\r\n\r\n    const blob = ac.wavAsBlob([normalize(this.impulseResponse.getChannelData(0))], { sampleRate, bitDepth: 32 });\r\n    const extension = !filename.endsWith(\".wav\") ? \".wav\" : \"\";\r\n    FileSaver.saveAs(blob, filename + extension);\r\n  }\r\n\r\n  // Ambisonic impulse response storage\r\n  ambisonicImpulseResponse?: AudioBuffer;\r\n  ambisonicOrder: number = 1;\r\n\r\n  /**\r\n   * Calculate an ambisonic impulse response from the beam-traced paths.\r\n   * Each reflection is encoded based on its arrival direction at the receiver.\r\n   *\r\n   * @param order - Ambisonic order (1 = first order with 4 channels, 2 = 9 channels, etc.)\r\n   * @returns Promise resolving to an AudioBuffer with ambisonic channels\r\n   */\r\n  async calculateAmbisonicImpulseResponse(order: number = 1): Promise<AudioBuffer> {\r\n    if (this.validPaths.length === 0) {\r\n      throw new Error(\"No paths calculated yet. Run calculate() first.\");\r\n    }\r\n\r\n    const sampleRate = audioEngine.sampleRate;\r\n    const initialSPL = 100;\r\n    const spls = Array(this.frequencies.length).fill(initialSPL);\r\n\r\n    const totalTime = this.validPaths[this.validPaths.length - 1].arrivalTime + 0.05;\r\n    if (totalTime <= 0) throw new Error(\"Invalid impulse response duration\");\r\n    const numberOfSamples = Math.floor(sampleRate * totalTime) * 2;\r\n    if (numberOfSamples < 2) throw new Error(\"Impulse response too short to process\");\r\n    const nCh = getAmbisonicChannelCount(order);\r\n\r\n    // Create per-frequency, per-channel sample buffers\r\n    const samples: Float32Array[][] = [];\r\n    for (let f = 0; f < this.frequencies.length; f++) {\r\n      samples.push([]);\r\n      for (let ch = 0; ch < nCh; ch++) {\r\n        samples[f].push(new Float32Array(numberOfSamples));\r\n      }\r\n    }\r\n\r\n    // Process each path\r\n    for (const path of this.validPaths) {\r\n      const randomPhase = Math.random() > 0.5 ? 1 : -1;\r\n      const pressure = this.calculateArrivalPressure(spls, path);\r\n      const roundedSample = Math.floor(path.arrivalTime * sampleRate);\r\n\r\n      if (roundedSample >= numberOfSamples) continue;\r\n\r\n      // Get arrival direction\r\n      const dir = path.arrivalDirection;\r\n\r\n      // Create a single-sample impulse for this reflection\r\n      const impulse = new Float32Array(1);\r\n\r\n      // Encode each frequency band\r\n      for (let f = 0; f < this.frequencies.length; f++) {\r\n        impulse[0] = pressure[f] * randomPhase;\r\n\r\n        // Encode the impulse at this direction (using Three.js coordinate system)\r\n        const encoded = encodeBufferFromDirection(impulse, dir.x, dir.y, dir.z, order, 'threejs');\r\n\r\n        // Add to the output buffers\r\n        for (let ch = 0; ch < nCh; ch++) {\r\n          samples[f][ch][roundedSample] += encoded[ch][0];\r\n        }\r\n      }\r\n    }\r\n\r\n    // Use filter worker to apply octave-band filtering\r\n    const FilterWorker = () => new Worker(new URL('../../audio-engine/filter.worker.ts', import.meta.url));\r\n\r\n    return new Promise((resolve, reject) => {\r\n      // Process each ambisonic channel through the filter bank\r\n      const processChannel = async (chIndex: number): Promise<Float32Array> => {\r\n        return new Promise((resolveChannel) => {\r\n          const channelFreqSamples: Float32Array[] = [];\r\n          for (let f = 0; f < this.frequencies.length; f++) {\r\n            channelFreqSamples.push(samples[f][chIndex]);\r\n          }\r\n\r\n          const channelWorker = FilterWorker();\r\n          channelWorker.postMessage({ samples: channelFreqSamples });\r\n          channelWorker.onmessage = (event) => {\r\n            const filteredSamples = event.data.samples as Float32Array[];\r\n            const signal = new Float32Array(filteredSamples[0].length >> 1);\r\n\r\n            for (let f = 0; f < filteredSamples.length; f++) {\r\n              for (let j = 0; j < signal.length; j++) {\r\n                signal[j] += filteredSamples[f][j];\r\n              }\r\n            }\r\n\r\n            channelWorker.terminate();\r\n            resolveChannel(signal);\r\n          };\r\n        });\r\n      };\r\n\r\n      // Process all channels\r\n      Promise.all(\r\n        Array.from({ length: nCh }, (_, ch) => processChannel(ch))\r\n      ).then((channelSignals) => {\r\n        // Find global max for normalization\r\n        let max = 0;\r\n        for (const signal of channelSignals) {\r\n          for (let j = 0; j < signal.length; j++) {\r\n            if (Math.abs(signal[j]) > max) {\r\n              max = Math.abs(signal[j]);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Normalize all channels by the same factor\r\n        if (max > 0) {\r\n          for (const signal of channelSignals) {\r\n            for (let j = 0; j < signal.length; j++) {\r\n              signal[j] /= max;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Create multi-channel AudioBuffer\r\n        const signalLength = channelSignals[0].length;\r\n        if (signalLength === 0) {\r\n          reject(new Error(\"Filtered signal has zero length\"));\r\n          return;\r\n        }\r\n        const offlineContext = audioEngine.createOfflineContext(nCh, signalLength, sampleRate);\r\n        const buffer = offlineContext.createBuffer(nCh, signalLength, sampleRate);\r\n\r\n        for (let ch = 0; ch < nCh; ch++) {\r\n          buffer.copyToChannel(new Float32Array(channelSignals[ch]), ch);\r\n        }\r\n\r\n        this.ambisonicImpulseResponse = buffer;\r\n        this.ambisonicOrder = order;\r\n        resolve(buffer);\r\n      }).catch(reject);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Download the ambisonic impulse response as a multi-channel WAV file.\r\n   * Channels are in ACN order with N3D normalization.\r\n   *\r\n   * @param filename - Output filename (without extension)\r\n   * @param order - Ambisonic order (default: 1)\r\n   */\r\n  async downloadAmbisonicImpulseResponse(\r\n    filename: string,\r\n    order: number = 1\r\n  ) {\r\n    // Calculate if not already cached or if order changed\r\n    if (!this.ambisonicImpulseResponse || this.ambisonicOrder !== order) {\r\n      await this.calculateAmbisonicImpulseResponse(order);\r\n    }\r\n\r\n    const nCh = this.ambisonicImpulseResponse!.numberOfChannels;\r\n    const sampleRate = this.ambisonicImpulseResponse!.sampleRate;\r\n    const channelData: Float32Array[] = [];\r\n\r\n    for (let ch = 0; ch < nCh; ch++) {\r\n      channelData.push(this.ambisonicImpulseResponse!.getChannelData(ch));\r\n    }\r\n\r\n    const blob = ac.wavAsBlob(channelData, { sampleRate, bitDepth: 32 });\r\n    const extension = !filename.endsWith(\".wav\") ? \".wav\" : \"\";\r\n    const orderLabel = order === 1 ? \"FOA\" : `HOA${order}`;\r\n    FileSaver.saveAs(blob, `${filename}_${orderLabel}${extension}`);\r\n  }\r\n\r\n  // Clear results\r\n  reset() {\r\n    this.validPaths = [];\r\n    this.clearVisualization();\r\n    this.btSolver = null;\r\n    this.lastMetrics = null;\r\n\r\n    // Clear LTP data\r\n    this.clearLevelTimeProgressionData();\r\n\r\n    // Clear highlighted path and beams\r\n    (this.selectedPath.geometry as MeshLine).setPoints([]);\r\n    this.clearSelectedBeams();\r\n\r\n    renderer.needsToRender = true;\r\n  }\r\n\r\n  // Helper to clear highlighted beam lines\r\n  private clearSelectedBeams() {\r\n    while (this.selectedBeamsGroup.children.length > 0) {\r\n      const child = this.selectedBeamsGroup.children[0];\r\n      this.selectedBeamsGroup.remove(child);\r\n      if (child instanceof THREE.Mesh || child instanceof THREE.Line) {\r\n        child.geometry?.dispose();\r\n        if (child.material instanceof THREE.Material) {\r\n          child.material.dispose();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Getters and setters\r\n  get room(): Room | undefined {\r\n    return useContainer.getState().containers[this.roomID] as Room | undefined;\r\n  }\r\n\r\n  get sources(): Source[] {\r\n    return this.sourceIDs\r\n      .map(id => useContainer.getState().containers[id] as Source)\r\n      .filter(Boolean);\r\n  }\r\n\r\n  get receivers(): Receiver[] {\r\n    return this.receiverIDs\r\n      .map(id => useContainer.getState().containers[id] as Receiver)\r\n      .filter(Boolean);\r\n  }\r\n\r\n  get numValidPaths(): number {\r\n    return this.validPaths.length;\r\n  }\r\n\r\n  set maxReflectionOrderReset(order: number) {\r\n    // Clamp to non-negative integer\r\n    this.maxReflectionOrder = Math.max(0, Math.floor(order));\r\n    // Update plotOrders and visibleOrders to include all orders up to the new max\r\n    this._plotOrders = Array.from({ length: this.maxReflectionOrder + 1 }, (_, i) => i);\r\n    this._visibleOrders = Array.from({ length: this.maxReflectionOrder + 1 }, (_, i) => i);\r\n    // Auto-recalculate if we have sources and receivers configured\r\n    if (this.sourceIDs.length > 0 && this.receiverIDs.length > 0) {\r\n      this.calculate();\r\n      emit(\"BEAMTRACE_CALCULATE_COMPLETE\", this.uuid);\r\n    } else {\r\n      this.reset();\r\n    }\r\n  }\r\n\r\n  get maxReflectionOrderReset(): number {\r\n    return this.maxReflectionOrder;\r\n  }\r\n\r\n  get visualizationMode(): VisualizationMode {\r\n    return this._visualizationMode;\r\n  }\r\n\r\n  set visualizationMode(mode: VisualizationMode) {\r\n    this._visualizationMode = mode;\r\n\r\n    // Clear and redraw based on mode\r\n    this.clearVisualization();\r\n\r\n    switch (mode) {\r\n      case \"rays\":\r\n        if (this.validPaths.length > 0) {\r\n          this.drawPaths();\r\n        }\r\n        break;\r\n      case \"beams\":\r\n        if (this.btSolver) {\r\n          this.drawBeams();\r\n        }\r\n        break;\r\n      case \"both\":\r\n        if (this.validPaths.length > 0) {\r\n          this.drawPaths();\r\n        }\r\n        if (this.btSolver) {\r\n          this.drawBeams();\r\n        }\r\n        break;\r\n    }\r\n\r\n    renderer.needsToRender = true;\r\n  }\r\n\r\n  // Show all beams toggle (including invalid/orphaned beams)\r\n  get showAllBeams(): boolean {\r\n    return this._showAllBeams;\r\n  }\r\n\r\n  set showAllBeams(value: boolean) {\r\n    this._showAllBeams = value;\r\n    // Redraw beams if in beams or both mode\r\n    if (this._visualizationMode === \"beams\" || this._visualizationMode === \"both\") {\r\n      this.clearVisualization();\r\n      if (this._visualizationMode === \"both\" && this.validPaths.length > 0) {\r\n        this.drawPaths();\r\n      }\r\n      if (this.btSolver) {\r\n        this.drawBeams();\r\n      }\r\n      renderer.needsToRender = true;\r\n    }\r\n  }\r\n\r\n  // Visible reflection orders for filtering visualization\r\n  get visibleOrders(): number[] {\r\n    return this._visibleOrders;\r\n  }\r\n\r\n  set visibleOrders(orders: number[]) {\r\n    this._visibleOrders = orders;\r\n    // Redraw visualization with new filter\r\n    this.clearVisualization();\r\n    switch (this._visualizationMode) {\r\n      case \"rays\":\r\n        if (this.validPaths.length > 0) {\r\n          this.drawPaths();\r\n        }\r\n        break;\r\n      case \"beams\":\r\n        if (this.btSolver) {\r\n          this.drawBeams();\r\n        }\r\n        break;\r\n      case \"both\":\r\n        if (this.validPaths.length > 0) {\r\n          this.drawPaths();\r\n        }\r\n        if (this.btSolver) {\r\n          this.drawBeams();\r\n        }\r\n        break;\r\n    }\r\n    renderer.needsToRender = true;\r\n  }\r\n\r\n  // Debug a specific beam path by polygon IDs\r\n  debugBeamPath(polygonPath: number[]) {\r\n    if (!this.btSolver) {\r\n      console.warn(\"BeamTraceSolver: No solver built. Run calculate() first.\");\r\n      return;\r\n    }\r\n    if (this.receiverIDs.length === 0) {\r\n      console.warn(\"BeamTraceSolver: No receiver selected for debugging.\");\r\n      return;\r\n    }\r\n\r\n    const receiver = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\r\n    if (!receiver) {\r\n      console.warn(\"BeamTraceSolver: Receiver not found.\");\r\n      return;\r\n    }\r\n\r\n    const listenerPos: BT_Vector3 = [\r\n      receiver.position.x,\r\n      receiver.position.y,\r\n      receiver.position.z\r\n    ];\r\n\r\n    console.group(`🔍 Debugging beam path: [${polygonPath.join(' → ')}]`);\r\n    this.btSolver.debugBeamPath(listenerPos, polygonPath);\r\n    console.groupEnd();\r\n  }\r\n\r\n  // Enable/disable BSP debug output (placeholder - setBSPDebug not exported from beam-trace)\r\n  setBSPDebug(enabled: boolean) {\r\n    // Note: setBSPDebug is not currently exported from beam-trace package\r\n    // This is a placeholder that logs the intent\r\n    console.log(`BeamTraceSolver: BSP debug ${enabled ? 'enabled' : 'disabled'} (note: requires beam-trace package update to export setBSPDebug)`);\r\n  }\r\n\r\n  // Get detailed paths with reflection information\r\n  getDetailedPaths(): DetailedReflectionPath3D[] {\r\n    if (!this.btSolver) {\r\n      console.warn(\"BeamTraceSolver: No solver built. Run calculate() first.\");\r\n      return [];\r\n    }\r\n    if (this.receiverIDs.length === 0) {\r\n      console.warn(\"BeamTraceSolver: No receiver selected.\");\r\n      return [];\r\n    }\r\n\r\n    const receiver = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\r\n    if (!receiver) {\r\n      console.warn(\"BeamTraceSolver: Receiver not found.\");\r\n      return [];\r\n    }\r\n\r\n    const listenerPos: BT_Vector3 = [\r\n      receiver.position.x,\r\n      receiver.position.y,\r\n      receiver.position.z\r\n    ];\r\n\r\n    return this.btSolver.getDetailedPaths(listenerPos);\r\n  }\r\n\r\n  // Highlight a specific path by index (for interactive selection)\r\n  highlightPathByIndex(pathIndex: number) {\r\n    const sortedPaths = [...this.validPaths].sort((a, b) => a.arrivalTime - b.arrivalTime);\r\n\r\n    if (pathIndex < 0 || pathIndex >= sortedPaths.length) {\r\n      console.warn('BeamTraceSolver: Path index out of bounds:', pathIndex);\r\n      return;\r\n    }\r\n\r\n    const path = sortedPaths[pathIndex];\r\n\r\n    // Clear previous selections\r\n    (this.selectedPath.geometry as MeshLine).setPoints([]);\r\n    this.clearSelectedBeams();\r\n\r\n    // Get the order-based color for this path\r\n    const pathColorHex = getOrderColor(path.order, this.maxReflectionOrder);\r\n\r\n    // Draw the ray path inside the room with order-based color (solid lines)\r\n    const rayMaterial = new THREE.LineBasicMaterial({\r\n      color: pathColorHex,\r\n      linewidth: 2,\r\n      transparent: false\r\n    });\r\n\r\n    // Draw each segment of the ray path\r\n    for (let i = 0; i < path.points.length - 1; i++) {\r\n      const segmentGeom = new THREE.BufferGeometry().setFromPoints([\r\n        path.points[i],\r\n        path.points[i + 1]\r\n      ]);\r\n      const segmentLine = new THREE.Line(segmentGeom, rayMaterial);\r\n      this.selectedBeamsGroup.add(segmentLine);\r\n    }\r\n\r\n    // Draw dashed line from virtual source to receiver for each reflection order\r\n    if (this.btSolver && this.receiverIDs.length > 0) {\r\n      const receiver = useContainer.getState().containers[this.receiverIDs[0]] as Receiver;\r\n      if (receiver) {\r\n        // Find the virtual source for the highest order beam in this path\r\n        const beamData = this.btSolver.getBeamsForVisualization(this.maxReflectionOrder);\r\n        const lastPolygonId = path.polygonIds[path.order];\r\n\r\n        if (lastPolygonId !== null) {\r\n          const matchingBeam = beamData.find((beam: BeamVisualizationData) =>\r\n            beam.polygonId === lastPolygonId && beam.reflectionOrder === path.order\r\n          );\r\n\r\n          if (matchingBeam) {\r\n            const dashedMaterial = new THREE.LineDashedMaterial({\r\n              color: pathColorHex,\r\n              linewidth: 1,\r\n              dashSize: 0.3,\r\n              gapSize: 0.15,\r\n              transparent: true,\r\n              opacity: 0.7\r\n            });\r\n\r\n            const virtualSourcePos = new THREE.Vector3(\r\n              matchingBeam.virtualSource[0],\r\n              matchingBeam.virtualSource[1],\r\n              matchingBeam.virtualSource[2]\r\n            );\r\n            const receiverPos = receiver.position.clone();\r\n\r\n            const dashedLineGeom = new THREE.BufferGeometry().setFromPoints([virtualSourcePos, receiverPos]);\r\n            const dashedLine = new THREE.Line(dashedLineGeom, dashedMaterial);\r\n            dashedLine.computeLineDistances();\r\n            this.selectedBeamsGroup.add(dashedLine);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log(`BeamTraceSolver: Highlighting path ${pathIndex} with order ${path.order}, arrival time ${path.arrivalTime.toFixed(4)}s`);\r\n\r\n    renderer.needsToRender = true;\r\n  }\r\n\r\n  // Clear the current path highlight\r\n  clearPathHighlight() {\r\n    (this.selectedPath.geometry as MeshLine).setPoints([]);\r\n    this.clearSelectedBeams();\r\n    renderer.needsToRender = true;\r\n  }\r\n}\r\n\r\nexport default BeamTraceSolver;\r\n\r\n// Event type declarations\r\ndeclare global {\r\n  interface EventTypes {\r\n    ADD_BEAMTRACE: BeamTraceSolver | undefined;\r\n    REMOVE_BEAMTRACE: string;\r\n    BEAMTRACE_SET_PROPERTY: SetPropertyPayload<BeamTraceSolver>;\r\n    BEAMTRACE_CALCULATE: string;\r\n    BEAMTRACE_CALCULATE_COMPLETE: string;\r\n    BEAMTRACE_RESET: string;\r\n    BEAMTRACE_PLAY_IR: string;\r\n    BEAMTRACE_DOWNLOAD_IR: string;\r\n    BEAMTRACE_DOWNLOAD_AMBISONIC_IR: { uuid: string; order: number };\r\n    SHOULD_ADD_BEAMTRACE: undefined;\r\n  }\r\n}\r\n\r\n// Event handlers\r\non(\"BEAMTRACE_SET_PROPERTY\", setSolverProperty);\r\non(\"REMOVE_BEAMTRACE\", removeSolver);\r\non(\"ADD_BEAMTRACE\", addSolver(BeamTraceSolver));\r\n\r\non(\"BEAMTRACE_CALCULATE\", (uuid: string) => {\r\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\r\n  solver.calculate();\r\n  // Defer the complete event to allow React state updates to flush\r\n  // This ensures setCalculating(true) is processed before setCalculating(false)\r\n  setTimeout(() => emit(\"BEAMTRACE_CALCULATE_COMPLETE\", uuid), 0);\r\n});\r\n\r\non(\"BEAMTRACE_RESET\", (uuid: string) => {\r\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\r\n  solver.reset();\r\n});\r\n\r\non(\"BEAMTRACE_PLAY_IR\", (uuid: string) => {\r\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\r\n  solver.playImpulseResponse().catch((err: Error) => {\r\n    window.alert(err.message || \"Failed to play impulse response\");\r\n  });\r\n});\r\n\r\non(\"BEAMTRACE_DOWNLOAD_IR\", (uuid: string) => {\r\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\r\n  const containers = useContainer.getState().containers;\r\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\r\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\r\n  const filename = `ir-beamtrace-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\r\n  solver.downloadImpulseResponse(filename).catch((err: Error) => {\r\n    window.alert(err.message || \"Failed to download impulse response\");\r\n  });\r\n});\r\n\r\non(\"BEAMTRACE_DOWNLOAD_AMBISONIC_IR\", ({ uuid, order }: { uuid: string; order: number }) => {\r\n  const solver = useSolver.getState().solvers[uuid] as BeamTraceSolver;\r\n  const containers = useContainer.getState().containers;\r\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\r\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\r\n  const filename = `ir-beamtrace-ambi-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\r\n  solver.downloadAmbisonicImpulseResponse(filename, order).catch((err: Error) => {\r\n    window.alert(err.message || \"Failed to download ambisonic impulse response\");\r\n  });\r\n});\r\n\r\non(\"SHOULD_ADD_BEAMTRACE\", () => {\r\n  emit(\"ADD_BEAMTRACE\", undefined);\r\n});\r\n"],"names":["Vector3","x","y","z","v","a","b","s","len","epsilon","normal","d","bLenSq","scale","precision","Plane3D","point","n","p1","p2","p3","v1","v2","c","plane","dist","planeToMirror","mirrorPlane","offset","tangent","bitangent","p1m","p2m","p3m","rayOrigin","rayDirection","denom","t","dotNormals","Polygon3D","vertices","materialId","verts","poly","sum","total","v0","i","cross","result","next","front","back","classification","edge","toPoint","min","max","areaThreshold","reversedVerts","flippedPlane","splitPolygon","frontVerts","backVerts","d1","d2","c1","c2","intersection","clipPolygonByPlane","input","output","current","dCurrent","dNext","currentInside","nextInside","clipPolygonByPlanes","planes","quickRejectPolygon","allBehind","buildBSP","polygons","indexed","polygon","buildBSPRecursive","splitterIndex","chooseSplitter","splitter","frontPolys","backPolys","bestIndex","bestScore","sampleSize","step","splits","j","score","rayTraceBSP","origin","direction","node","tMin","tMax","ignoreId","dOrigin","dDir","near","far","tSplit","hit","polyHit","rayTraceBSPMultiIgnore","ignoreIds","constructBeamBoundaryPlanes","virtualSource","aperture","edges","apertureCentroid","edgePlane","aperturePlane","mirrorPointAcrossPolygon","isPolygonFacingSource","centroid","toSource","MIN_APERTURE_AREA","buildBeamTree3D","sourcePosition","maxReflectionOrder","root","childVS","childBoundaries","childNode","buildBeamChildren","leafNodes","collectLeafNodes","currentOrder","maxOrder","clipped","child","clearFailPlanes","tree","clearFailPlanesRecursive","detectFailPlane","listenerPos","polyPlane","getNodeDepth","edgeCount","type","depth","isListenerBehindFailPlane","failPlane","DEFAULT_BUCKET_SIZE_3D","createBuckets3D","bucketSize","buckets","isInsideSkipSphere","skipSphere","checkSkipSphere","bucket","createSkipSphere","nodes","minDist","invalidateSkipSphere","clearBucketFailPlanes","OptimizedSolver3D","config","validPaths","directPath","intermediatePaths","skipStatus","allFailed","allHaveFailPlanes","path","convertToDetailedPath3D","dir","paths","debug","pathPoints","polygonPath","tempNode","currentPoint","currentNode","segmentIndex","imageSource","occluder","xAtCross","zAtCross","polyId","testHit","tMinVal","tMaxVal","finalHit","leafNode","failInfo","findNode","targetNode","p","beams","effectiveMaxOrder","traverse","order","pathSoFar","currentPath","computePathLength","length","computeArrivalTime","speedOfSound","getPathReflectionOrder","GRAZING_THRESHOLD_3D","calculateIncidenceAngle3D","incomingDir","surfaceNormal","cosAngle","clampedCos","getOrientedNormal3D","listenerPosition","reflections","segments","cumulativeDistance","startPoint","endPoint","segmentLength","endPolygonId","hitPoint","incomingDirection","nextPoint","outgoingDirection","incidenceAngle","reflectionAngle","isGrazing","Source3D","position","Solver3D","source","listener","pos","createHighlightLine","line","MeshLine","material","MeshLineMaterial","THREE","colorScale","chroma","getOrderColor","numColors","colors","colorIndex","color","defaults","BeamTraceSolver","Solver","params","uuidv4","_","rooms","getRooms","emit","ResultKind","renderer","pickProps","state","canvas","getMouseNDC","event","rect","mouse","raycaster","virtualSourceMeshes","intersects","clickedMesh","beam","colorHex","vs","receiver","useContainer","receiverPos","dashedMaterial","unfoldedLineGeom","unfoldedLine","highlightGeom","highlightMat","highlightMesh","targetOrder","pathOrder","matches","pathIndex","points","numReflections","start","end","segLen","midPoint","segmentOrder","segColor","cylGeom","cylMat","cyl","quaternion","pointOrder","pointColor","pointGeom","pointMat","pointMesh","room","surface","surfacePolygons","startIndex","geometry","posAttr","worldMatrix","indices","positions","processTriangle","i0","i1","i2","indexArray","numVertices","sourcePos","btSource","receiverID","btPath","arrivalTime","polygonIds","arrivalDirection","_c","sortedPaths","levelTimeProgression","useResult","pressure","pressureLp","ac.P2Lp","f","orders","pathUuid","match","g","usageStats","validPathsByPolygonSequence","polygonSequence","id","hasValidPath","radius","finalColor","r","vsGeom","vsMat","vsMesh","mat","sampleRate","audioEngine","spls","totalTime","numberOfSamples","samples","randomPhase","roundedSample","worker","resolve","reject","filteredSamples","signal","normalizedSignal","normalize","offlineContext","ir","error","initialSPL","intensities","ac.P2I","ac.Lp2P","polygonId","R","arrivalLp","ac.I2P","airAttenuationdB","ac.airAttenuation","containers","sourceName","receiverName","channelData","data","downsampleFactor","filename","blob","ac.wavAsBlob","extension","FileSaver","nCh","getAmbisonicChannelCount","ch","impulse","encoded","encodeBufferFromDirection","FilterWorker","processChannel","chIndex","resolveChannel","channelFreqSamples","channelWorker","channelSignals","signalLength","buffer","orderLabel","mode","value","enabled","pathColorHex","rayMaterial","segmentGeom","segmentLine","beamData","lastPolygonId","matchingBeam","virtualSourcePos","dashedLineGeom","dashedLine","on","setSolverProperty","removeSolver","addSolver","uuid","useSolver","err","solver"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}