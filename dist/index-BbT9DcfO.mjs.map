{"version":3,"file":"index-BbT9DcfO.mjs","sources":["../src/compute/raytracer/image-source/index.ts"],"sourcesContent":["// @ts-nocheck\r\nimport Solver from \"../../solver\";\r\nimport { renderer } from \"../../../render/renderer\";\r\nimport { v4 as uuid } from 'uuid';\r\nimport * as THREE from \"three\";\r\nimport { MeshLine, MeshLineMaterial } from 'three.meshline';\r\nimport * as ac from \"../../acoustics\";\r\nimport Room, { getRooms } from \"../../../objects/room\";\r\nimport { emit, messenger, on } from \"../../../messenger\";\r\nimport Source from \"../../../objects/source\";\r\nimport Receiver from \"../../../objects/receiver\";\r\nimport { Vector3 } from \"three\";\r\nimport Surface from \"../../../objects/surface\";\r\nimport { intersection } from \"lodash\";\r\nimport { addSolver, removeSolver, Result, ResultKind, ResultTypes, setSolverProperty, useResult, useSolver } from \"../../../store\";\r\nimport {useContainer} from '../../../store';\r\nimport { pickProps } from \"../../../common/helpers\";\r\nimport { normalize } from \"../../acoustics\";\r\nimport FileSaver from 'file-saver';\r\nimport { audioEngine } from \"../../../audio-engine/audio-engine\";\r\n\r\nfunction createLine(){\r\n  let points = [];\r\n  const line = new MeshLine();\r\n  line.setPoints(points);\r\n  const material = new MeshLineMaterial({\r\n    lineWidth: 0.1,\r\n    color: 0xff0000,\r\n    sizeAttenuation: 1, \r\n  });\r\n  return new THREE.Mesh(line, material);\r\n}\r\n\r\ninterface ImageSourceParams {\r\n  baseSource: Source,\r\n  position: Vector3,\r\n  room: Room,  \r\n  reflector: Surface | null,\r\n  parent: ImageSource | null,  \r\n  order: number,\r\n}\r\n\r\nclass ImageSource{\r\n\r\n  // the source that all image sources are based off of\r\n  // note: this is not the parent image source! that is 'parent' below \r\n  public baseSource: Source; \r\n  \r\n  public children: ImageSource[]; \r\n  public parent: ImageSource | null;  \r\n\r\n  public reflector: Surface | null; \r\n  public order: number; \r\n  public position: Vector3; \r\n\r\n  public room: Room;\r\n\r\n  public uuid: string; \r\n\r\n  constructor(params: ImageSourceParams){\r\n    this.baseSource = params.baseSource;\r\n    this.reflector = params.reflector; \r\n    this.order = params.order; \r\n\r\n    this.position = params.position; \r\n\r\n    this.children = []; \r\n    this.parent = params.parent; \r\n\r\n    this.room = params.room; \r\n    this.uuid = uuid(); \r\n  }\r\n\r\n  public constructPathsForAllDescendents(r: Receiver,constructForThis=true): ImageSourcePath[]{\r\n    let paths: ImageSourcePath[] = [];\r\n\r\n    // compute direct sound path\r\n    if(constructForThis){\r\n      let thisPath = constructImageSourcePath(this, r);\r\n      if(thisPath !== null){\r\n        paths.push(thisPath);\r\n      }\r\n    }\r\n\r\n    for(let i = 0; i<this.children.length; i++){\r\n      let p = constructImageSourcePath(this.children[i],r);\r\n\r\n      if (p!== null){\r\n        paths.push(p);\r\n      }\r\n\r\n      if(this.children[i].hasChildren){\r\n        paths = paths.concat(this.children[i].constructPathsForAllDescendents(r,false)); \r\n      } \r\n\r\n    }\r\n    return paths; \r\n  }\r\n\r\n  public markupAllDescendents(){\r\n    for(let i = 0; i<this.children.length; i++){\r\n      let pos: Vector3 = this.children[i].position.clone();\r\n      renderer.markup.addPoint([pos.x,pos.y,pos.z], [0,0,0]);\r\n      if (this.children[i].hasChildren){\r\n        this.children[i].markupAllDescendents(); \r\n      }else{\r\n      }\r\n    }\r\n  }\r\n\r\n  public markup(){\r\n    let pos: Vector3 = this.position.clone(); \r\n    renderer.markup.addPoint([pos.x,pos.y,pos.z], [0,0,0]);\r\n  }\r\n\r\n  public getTotalDescendents(): number{\r\n    let sum = 0; \r\n\r\n    for(let i = 0; i<this.children.length; i++){\r\n      sum++;\r\n      if(this.children[i].hasChildren){\r\n        sum = sum + this.children[i].getTotalDescendents(); \r\n      } \r\n    }\r\n    return sum; \r\n  }\r\n\r\n  public getChildrenOfOrder(order: number): ImageSource[]{\r\n    let order_children: ImageSource[] = [];\r\n\r\n    ((this.order === order) && (this.order === 0)) && order_children.push(this);\r\n\r\n    for(let i = 0; i<this.children.length; i++){\r\n      if(this.children[i].order === order){\r\n        order_children.push(this.children[i]);\r\n      }\r\n\r\n      if(this.children[i].hasChildren){\r\n        let a = this.children[i].getChildrenOfOrder(order); \r\n        order_children = order_children.concat(a); \r\n      }\r\n\r\n    }\r\n    return order_children; \r\n  }\r\n\r\n  get hasChildren() {\r\n    if (this.children.length > 0){\r\n      return true; \r\n    }else{\r\n      return false; \r\n    }\r\n  }\r\n\r\n}\r\n\r\ninterface intersection{\r\n  point: Vector3; \r\n  reflectingSurface: Surface | null;\r\n  angle: number | null; \r\n}\r\n\r\nclass ImageSourcePath{\r\n\r\n  public path: intersection[]; \r\n  public uuid; \r\n  public highlight; \r\n  \r\n  constructor(path: intersection[]){\r\n    this.path = path; \r\n    this.uuid = uuid(); \r\n    this.highlight = false; \r\n  }\r\n\r\n  markup(){\r\n    for(let i = 0; i<this.path.length-1; i++){\r\n      let p1: Vector3 = (this.path[i]).point.clone();\r\n      let p2: Vector3 =  (this.path[i+1]).point.clone();\r\n      renderer.markup.addLine([p1.x,p1.y,p1.z],[p2.x,p2.y,p2.z]);\r\n    }\r\n  }\r\n\r\n  isvalid(room_surfaces: Surface[]): boolean{\r\n\r\n    for(let order = 1; order <= this.order+1; order++){\r\n\r\n      let segmentStart: Vector3 = this.path[order-1].point;\r\n      let segmentEnd: Vector3 = this.path[order].point; \r\n\r\n      let prevReflector: Surface | null = this.path[order-1].reflectingSurface; \r\n      let reflector: Surface | null = this.path[order].reflectingSurface; \r\n\r\n      for(let j = 1; j<room_surfaces.length; j++){\r\n        if((room_surfaces[j] !== prevReflector) && (room_surfaces[j] !== reflector)){\r\n\r\n          // from current image source to last image source / receiver\r\n          let direction: Vector3 = new Vector3(0,0,0); \r\n          direction.subVectors(segmentEnd, segmentStart);\r\n          direction.normalize(); \r\n\r\n          let raycaster = new THREE.Raycaster(); \r\n          raycaster.set(segmentStart,direction);\r\n          let intersections; \r\n          intersections = raycaster.intersectObject(room_surfaces[j].mesh, true);\r\n\r\n          // remove any intersections of surfaces BEHIND the desired end point\r\n          // (verify this)\r\n          let trueIntersections = [];\r\n          for(let i = 0; i<intersections.length; i++){\r\n            if(segmentStart.distanceTo(intersections[i].point) < segmentStart.distanceTo(segmentEnd)){\r\n              //@ts-ignore\r\n              trueIntersections.push(intersections[i]);\r\n            }\r\n          }\r\n\r\n          if (trueIntersections.length > 0){\r\n            return false; \r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n    return true; \r\n  }\r\n\r\n  public get order(){\r\n    return this.path.length - 2; \r\n  }\r\n\r\n  public get totalLength(){\r\n    let length: number = 0; \r\n    let startingPoint: Vector3; \r\n    let endingPoint: Vector3;\r\n    for(let i = 1; i<this.path.length; i++){\r\n      startingPoint = this.path[i-1].point;\r\n      endingPoint = this.path[i].point;\r\n      length = length+startingPoint.distanceTo(endingPoint); \r\n    }\r\n    return length; \r\n  }\r\n  \r\n  public arrivalPressure(initialSPL: number[], freqs: number[]): number[]{\r\n\r\n    let intensity = ac.P2I(ac.Lp2P(initialSPL)) as number[];  \r\n    let arrivalPressure = []; \r\n\r\n    for(let s = 0; s<this.path.length; s++){\r\n\r\n      let intersection = this.path[s];\r\n      if(intersection.reflectingSurface === null){\r\n        // either source or a receiver\r\n        // do nothing to intensity levels\r\n      }else{\r\n        // intersected with a surface\r\n        for(let findex = 0; findex<freqs.length; findex++){\r\n          // @ts-ignore\r\n          //let reflectionCoefficient = (intersection.reflectingSurface as Surface).reflectionFunction(freqs[findex],intersection.angle);\r\n          let reflectionCoefficient = 1-(intersection.reflectingSurface as Surface).absorptionFunction(freqs[findex]); \r\n          intensity[findex] = intensity[findex]*reflectionCoefficient; \r\n        }\r\n      }\r\n    }\r\n\r\n    // convert back to SPL \r\n    let arrivalLp = ac.P2Lp(ac.I2P(intensity)); \r\n    \r\n    // apply air absorption (dB/m)\r\n    const airAttenuationdB = ac.airAttenuation(freqs); \r\n    for(let f = 0; f<freqs.length; f++){\r\n      arrivalLp[f] = arrivalLp[f] - airAttenuationdB[f]*this.totalLength; \r\n    }\r\n\r\n    // convert back to pressure\r\n    return ac.Lp2P(arrivalLp) as number[]; \r\n  }\r\n\r\n  public arrivalTime(c: number): number{\r\n    return this.totalLength / c; \r\n  }\r\n}\r\n\r\nexport type ImageSourceSaveObject = {\r\n  name: string;\r\n  kind: \"image-source\";\r\n  uuid: string;\r\n  autoCalculate: boolean;\r\n  roomID: string;\r\n  sourceIDs: string[];\r\n  surfaceIDs: string[];\r\n  receiverIDs: string[];\r\n  maxReflectionOrder: number;\r\n  imageSourcesVisible: boolean;\r\n  rayPathsVisible: boolean;\r\n  plotOrders: number[];\r\n  frequencies: number[];\r\n  levelTimeProgression: string;\r\n}\r\n\r\n\r\nexport interface ImageSourceSolverParams {\r\n  name: string;\r\n  uuid?: string;\r\n  roomID: string;\r\n  sourceIDs: string[];\r\n  surfaceIDs: string[];\r\n  receiverIDs: string[];\r\n  maxReflectionOrder: number;\r\n  imageSourcesVisible: boolean;\r\n  rayPathsVisible: boolean;\r\n  plotOrders: number[];\r\n  frequencies: number[];\r\n  levelTimeProgression?: string;\r\n}\r\n\r\nconst defaults = {\r\n  name: \"Image Source\",\r\n  roomID: \"\",\r\n  sourceIDs: [] as string[],\r\n  surfaceIDs: [] as string[],\r\n  receiverIDs: [] as string[],\r\n  maxReflectionOrder: 2,\r\n  imageSourcesVisible: true,\r\n  rayPathsVisible: true, \r\n  plotOrders: [0, 1, 2], // all paths\r\n  frequencies: [125,250,500,1000,2000,4000,8000],\r\n};\r\n\r\nexport interface HybridRayPath {\r\n  time: number,\r\n  pressure: number[]\r\n}\r\n\r\nexport class ImageSourceSolver extends Solver {\r\n\r\n    sourceIDs: string[]; \r\n    receiverIDs: string[];\r\n    roomID: string;\r\n    surfaceIDs: string[];\r\n    uuid: string; \r\n    levelTimeProgression: string;\r\n    maxReflectionOrder: number; \r\n    frequencies: number[]; \r\n    \r\n    private _imageSourcesVisible: boolean;\r\n    private _rayPathsVisible: boolean;\r\n    private _plotOrders: number[]; \r\n\r\n    impulseResponse!: AudioBuffer; \r\n    impulseResponsePlaying: boolean; \r\n\r\n    rootImageSource: ImageSource | null; \r\n    validRayPaths: ImageSourcePath[] | null; \r\n    allRayPaths: ImageSourcePath[] | null; \r\n\r\n    selectedImageSourcePath: MeshLine;\r\n\r\n    private _plotFrequency: number; \r\n\r\n    isHybrid: boolean; \r\n\r\n    constructor(params: ImageSourceSolverParams = defaults, isHybrid:boolean = false){\r\n        super(params);\r\n        this.uuid = params.uuid || uuid(); \r\n        this.kind = \"image-source\";\r\n        this.name = params.name;\r\n        this.roomID = params.roomID;\r\n        this.sourceIDs = params.sourceIDs;\r\n        this.receiverIDs = params.receiverIDs;\r\n        this.maxReflectionOrder = params.maxReflectionOrder; \r\n        this.frequencies = params.frequencies; \r\n        this._imageSourcesVisible = params.imageSourcesVisible; \r\n        this._rayPathsVisible = params.rayPathsVisible; \r\n        this._plotOrders = params.plotOrders; \r\n        this.levelTimeProgression = params.levelTimeProgression || uuid();\r\n        this.isHybrid = isHybrid; \r\n\r\n        this.impulseResponsePlaying = false; \r\n\r\n        this._plotFrequency = 1000; \r\n\r\n        if(!this.isHybrid){\r\n          emit(\"ADD_RESULT\", {\r\n            kind: ResultKind.LevelTimeProgression, \r\n            data: [],\r\n            info: {\r\n              initialSPL: [100],\r\n              frequency: [this._plotFrequency],\r\n              maxOrder: this.maxReflectionOrder,\r\n            },\r\n            name: `LTP - ${this.name}`,\r\n            uuid: this.levelTimeProgression,\r\n            from: this.uuid\r\n          } as Result<ResultKind.LevelTimeProgression>);\r\n        }\r\n\r\n        this.surfaceIDs = []; \r\n        \r\n        this.rootImageSource = null;\r\n        this.allRayPaths = null;  \r\n        this.validRayPaths = null; \r\n\r\n        const rooms = getRooms();\r\n\r\n        // get room \r\n        this.roomID = rooms[0].uuid;\r\n\r\n        // //@ts-ignore\r\n        this.selectedImageSourcePath = createLine();\r\n        renderer.markup.add(this.selectedImageSourcePath);\r\n    }\r\n\r\n    save(){\r\n      return pickProps([\r\n        \"name\",\r\n        \"kind\",\r\n        \"uuid\",\r\n        \"autoCalculate\",\r\n        \"roomID\",\r\n        \"sourceIDs\",\r\n        \"surfaceIDs\",\r\n        \"receiverIDs\",\r\n        \"maxReflectionOrder\",\r\n        \"imageSourcesVisible\",\r\n        \"rayPathsVisible\",\r\n        \"plotOrders\",\r\n        \"levelTimeProgression\"\r\n      ], this) as ImageSourceSaveObject;\r\n    }\r\n\r\n    dispose(){\r\n        renderer.markup.remove(this.selectedImageSourcePath);\r\n        this.reset();\r\n        emit(\"REMOVE_RESULT\", this.levelTimeProgression);\r\n    }\r\n\r\n    updateSelectedImageSourcePath(imageSourcePath: ImageSourcePath){\r\n      (this.selectedImageSourcePath.geometry as MeshLine).setPoints(\r\n        imageSourcePath.path.map(x=>x.point.toArray()).flat()\r\n      );\r\n      // (this.selectedImageSourcePath.geometry as LineGeometry).setFromPoints(\r\n      //   imageSourcePath.path.map(x=>x.point)\r\n      // );\r\n      // (this.selectedImageSourcePath.geometry as LineGeometry).setDrawRange(0,imageSourcePath.path.length);\r\n      console.log(imageSourcePath.path.map(x=>x.point.toArray()).flat());\r\n    }\r\n\r\n    updateImageSourceCalculation(){\r\n\r\n      // clear markup (replace with a more robust method eventually)\r\n      this.clearRayPaths(); \r\n      this.clearImageSources(); \r\n\r\n      // add in checking to make sure only 1 source and 1 receiver are selected\r\n\r\n      let is_params: ImageSourceParams = {\r\n        baseSource: useContainer.getState().containers[this.sourceIDs[0]] as Source,\r\n        position: (useContainer.getState().containers[this.sourceIDs[0]] as Source).position.clone(), \r\n        room: this.room, \r\n        reflector: null,\r\n        parent: null, \r\n        order: 0, \r\n      };\r\n      \r\n      let is_base: ImageSource = new ImageSource(is_params);\r\n      let is_calculated: ImageSource | null = computeImageSources(is_base,this.maxReflectionOrder); \r\n\r\n      this.rootImageSource = is_calculated; \r\n\r\n      // construct all possible paths\r\n      let paths: ImageSourcePath[];\r\n      let valid_paths: ImageSourcePath[] = [];\r\n      if(is_calculated !== null){\r\n        paths = is_calculated.constructPathsForAllDescendents(useContainer.getState().containers[this.receiverIDs[0]] as Receiver);\r\n\r\n        this.allRayPaths = paths; \r\n\r\n        // get valid paths\r\n        for(let i = 0; i<paths?.length; i++){\r\n          if(paths[i].isvalid(this.room.allSurfaces as Surface[])){\r\n            valid_paths.push(paths[i]); \r\n          }\r\n        }\r\n      }\r\n      this.validRayPaths = valid_paths; \r\n      (this._imageSourcesVisible) && (this.drawImageSources());\r\n      (this._rayPathsVisible) && (this.drawRayPaths()); \r\n\r\n      if(!this.isHybrid){\r\n        this.calculateLTP(343); \r\n      }\r\n    }\r\n\r\n    // hybrid solver use only\r\n    returnSortedPathsForHybrid(c: number, initialSPLs: number[], freqs: number[]){\r\n      this.updateImageSourceCalculation(); \r\n\r\n      let sortedPath: ImageSourcePath[] | null = this.validRayPaths; \r\n      sortedPath?.sort((a, b) => (a.arrivalTime(c) > b.arrivalTime(c)) ? 1 : -1); \r\n\r\n      let result: HybridRayPath[] = [];\r\n\r\n      if(sortedPath != null){\r\n        for(let i = 0; i<sortedPath.length; i++){\r\n          let t = sortedPath[i].arrivalTime(c);\r\n          let p = sortedPath[i].arrivalPressure(initialSPLs, freqs); \r\n          let path: HybridRayPath = {\r\n            time: t, \r\n            pressure: p,\r\n          }\r\n          result.push(path);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    calculateLTP(c: number, consoleOutput: boolean = false){\r\n      // If no paths have been calculated yet, run the calculation first\r\n      if (!this.validRayPaths || this.validRayPaths.length === 0) {\r\n        if (this.sourceIDs.length > 0 && this.receiverIDs.length > 0) {\r\n          this.updateImageSourceCalculation();\r\n          return; // updateImageSourceCalculation calls calculateLTP at the end\r\n        }\r\n        return;\r\n      }\r\n\r\n      let sortedPath: ImageSourcePath[] | null = this.validRayPaths;\r\n      sortedPath?.sort((a, b) => (a.arrivalTime(c) > b.arrivalTime(c)) ? 1 : -1);\r\n      const levelTimeProgression = { ...useResult.getState().results[this.levelTimeProgression] as Result<ResultKind.LevelTimeProgression> };\r\n      levelTimeProgression.data = [] as ResultTypes[ResultKind.LevelTimeProgression][\"data\"];\r\n      levelTimeProgression.info = {\r\n        ...levelTimeProgression.info,\r\n        maxOrder: this.maxReflectionOrder,\r\n        frequency: [this._plotFrequency]\r\n      }\r\n      if(sortedPath !== undefined){\r\n        for(let i = 0; i<sortedPath?.length; i++){\r\n          let t = sortedPath[i].arrivalTime(343);\r\n          let p = sortedPath[i].arrivalPressure(levelTimeProgression.info.initialSPL, levelTimeProgression.info.frequency);\r\n          if(consoleOutput){\r\n            console.log(\"Arrival: \" + (i+1) + \" | Arrival Time: (s) \" + t + \" | Arrival Pressure(1000Hz): \" + p + \" | Order \" + sortedPath[i].order);\r\n          }\r\n\r\n          levelTimeProgression.data.push({\r\n            time: t,\r\n            pressure: ac.P2Lp(p) as number[],\r\n            arrival: i+1,\r\n            order: sortedPath[i].order,\r\n            uuid: sortedPath[i].uuid\r\n          })\r\n        }\r\n      }\r\n\r\n      emit(\"UPDATE_RESULT\", { uuid: this.levelTimeProgression, result: levelTimeProgression });\r\n    }\r\n\r\n    getPathsOfOrder(order: number): ImageSourcePath[]{\r\n      let rayPathsOfOrder: ImageSourcePath[] = [];\r\n      if(this.validRayPaths !== null){\r\n        for(let i = 0; i<this.validRayPaths?.length; i++){\r\n          if(this.validRayPaths[i].order === order){\r\n            rayPathsOfOrder.push(this.validRayPaths[i]);\r\n          }\r\n        }\r\n      }\r\n      return rayPathsOfOrder; \r\n    }\r\n\r\n    test(){\r\n\r\n      // debugging\r\n\r\n        // get source\r\n        let source: Source = messenger.postMessage(\"FETCH_SOURCE\",this.sourceIDs[0])[0];\r\n\r\n        // assign base image source\r\n        let is_params: ImageSourceParams = {\r\n          baseSource: source.clone(),\r\n          position: source.position.clone(), \r\n          room: room, \r\n          reflector: null,\r\n          parent: null, \r\n          order: 0, \r\n        };\r\n\r\n        let is: ImageSource = new ImageSource(is_params);\r\n        \r\n        let maxOrder = 1; \r\n        let is_2 = computeImageSources(is,maxOrder); \r\n        is_2?.markup(); \r\n        console.log(is_2); \r\n\r\n        let receiver: Receiver = this.receivers[0];\r\n        console.log(receiver);\r\n\r\n        let paths: ImageSourcePath[];\r\n        if(is_2 !== null){\r\n          paths = is_2.constructPathsForAllDescendents(receiver);\r\n\r\n          let f = [125, 250, 500, 1000, 2000, 4000];\r\n          let initialSPL = [100,100,100,100,100,100]; \r\n\r\n          let validCount = 0; \r\n          for(let i = 0; i<paths.length; i++){\r\n            if(paths[i].isvalid(this.room.allSurfaces as Surface[])){\r\n              paths[i].markup(); \r\n              console.log(paths[i]);\r\n              console.log(paths[i].totalLength)\r\n              console.log(paths[i].arrivalTime(343)); \r\n              console.log(ac.Lp2P(initialSPL));\r\n              //console.log(paths[i].arrivalPressure(initialSPL,f))\r\n              validCount++; \r\n            }\r\n          }\r\n          console.log(validCount + \" out of \" + paths.length + \" paths are valid\"); \r\n        } \r\n    }\r\n\r\n    clearLevelTimeProgressionData(){\r\n      const levelTimeProgression = { ...useResult.getState().results[this.levelTimeProgression] };\r\n      levelTimeProgression.data = [];\r\n      emit(\"UPDATE_RESULT\", { uuid: this.levelTimeProgression, result: levelTimeProgression });\r\n    }\r\n    \r\n    reset(){\r\n      this.rootImageSource = null;\r\n      this.allRayPaths = null;  \r\n      this.validRayPaths = null; \r\n      this.plotOrders = (this.possibleOrders).map((e)=>e.value); \r\n      (this.selectedImageSourcePath.geometry as MeshLine).setPoints([]); \r\n      this.clearImageSources(); \r\n      this.clearRayPaths(); \r\n      this.clearLevelTimeProgressionData();\r\n    }\r\n\r\n    // plot functions\r\n    drawImageSources(){\r\n      this.clearImageSources(); \r\n      for(let i = 0; i<this.plotOrders.length; i++){\r\n        let is = this.rootImageSource?.getChildrenOfOrder(this.plotOrders[i]) as ImageSource[];   \r\n        for(let j = 0; j<is?.length; j++){\r\n          is[j].markup(); \r\n        }\r\n      }\r\n    }\r\n\r\n    clearImageSources(){\r\n      // placeholder\r\n      renderer.markup.clearPoints(); \r\n    }\r\n\r\n    drawRayPaths(orders?:number[]){\r\n      this.clearRayPaths(); \r\n      for(let i = 0; i<this.plotOrders.length; i++){\r\n        let is_paths = this.getPathsOfOrder(this.plotOrders[i]) as ImageSourcePath[]; \r\n        for(let j = 0; j<is_paths.length; j++){\r\n          is_paths[j].markup(); \r\n        }\r\n      }\r\n    }\r\n\r\n    clearRayPaths(){\r\n      // placeholder\r\n      renderer.markup.clearLines(); \r\n    }\r\n\r\n    toggleRayPathHighlight(rayPathUUID: string){\r\n      if(this.validRayPaths != null){\r\n        for(let i = 0; i<this.validRayPaths.length; i++){\r\n          if(rayPathUUID === this.validRayPaths[i].uuid){\r\n            this.updateSelectedImageSourcePath(this.validRayPaths[i])\r\n            //@ts-ignore\r\n            console.log(\"WILL HIGHLIGHT RAY PATH WITH ARRIVAL SPL \" + ac.P2Lp(this.validRayPaths[i].arrivalPressure([100], [1000]) as number) + \" AND ARRIVAL TIME \" + this.validRayPaths[i].arrivalTime(343));\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    async calculateImpulseResponse(){\r\n      const initialSPL = 100; //PLACEHOLDER\r\n      const freqs = this.frequencies;\r\n      const sampleRate = 44100;\r\n      const spls = Array(freqs.length).fill(initialSPL);\r\n\r\n      if(this.receiverIDs.length === 0) throw Error(\"No receivers have been assigned to the raytracer\");\r\n      if(this.sourceIDs.length === 0) throw Error(\"No sources have been assigned to the raytracer\");\r\n      if(this.validRayPaths?.length === 0) throw Error(\"No rays have been traced yet\");\r\n\r\n      let sortedPath: ImageSourcePath[] | null = this.validRayPaths; \r\n      sortedPath?.sort((a, b) => (a.arrivalTime(343) > b.arrivalTime(343)) ? 1 : -1); \r\n\r\n      console.log(sortedPath);\r\n\r\n      if(sortedPath != null){\r\n        const endTime = sortedPath[sortedPath.length - 1].arrivalTime(343)+0.05;\r\n        const endSample = sampleRate*endTime;\r\n\r\n        let samples: Float32Array[] = [];\r\n        for(let f = 0; f<this.frequencies.length; f++){\r\n          samples.push(new Float32Array(Math.floor(endSample)));\r\n        }\r\n\r\n        for(let i = 0; i<sortedPath.length; i++){\r\n          let t = sortedPath[i].arrivalTime(343);\r\n          let p = sortedPath[i].arrivalPressure(spls, this.frequencies); \r\n\r\n          (Math.random() > 0.5) && (p=p.map(x=>-x)); \r\n\r\n          let roundedSample = Math.floor(t*sampleRate);\r\n\r\n          for(let f = 0; f<this.frequencies.length; f++){\r\n            samples[f][roundedSample] += p[f]; \r\n          }\r\n        }\r\n          \r\n        // samples.forEach((x,i,arr)=>{\r\n        //   const {b, a} = coefs.get(freqs[i])!;\r\n        //   arr[i] = filter(b,a,x);\r\n        // });\r\n    \r\n        const offlineContext = audioEngine.createOfflineContext(1, endSample, sampleRate);\r\n\r\n        const sources = Array(this.frequencies.length); \r\n        for(let f = 0; f<this.frequencies.length; f++){\r\n          sources[f] = audioEngine.createFilteredSource(samples[f],this.frequencies[f],1.414,1,offlineContext); \r\n        }\r\n\r\n        //const sources = samples.map(x => audioEngine.createBufferSource(x, offlineContext));\r\n\r\n        console.log(sources);\r\n\r\n        const merger = audioEngine.createMerger(sources.length, offlineContext);\r\n        \r\n        for(let i = 0; i<sources.length; i++){\r\n          sources[i].source.connect(merger, 0, i);\r\n        }\r\n    \r\n        merger.connect(offlineContext.destination);\r\n        sources.forEach(source=>source.source.start());\r\n\r\n        this.impulseResponse = await audioEngine.renderContextAsync(offlineContext);\r\n\r\n        return this.impulseResponse;\r\n\r\n      } \r\n    }\r\n\r\n    async playImpulseResponse(){\r\n      if(!this.impulseResponse){\r\n        await this.calculateImpulseResponse().catch(console.error);\r\n      }\r\n      if (audioEngine.context.state === 'suspended') {\r\n        audioEngine.context.resume();\r\n      }\r\n      console.log(this.impulseResponse);\r\n      const impulseResponse = audioEngine.context.createBufferSource();\r\n      impulseResponse.buffer = this.impulseResponse;\r\n      impulseResponse.connect(audioEngine.context.destination);\r\n      impulseResponse.start();\r\n      emit(\"IMAGESOURCE_SET_PROPERTY\", { uuid: this.uuid, property: \"impulseResponsePlaying\", value: true });\r\n      impulseResponse.onended = () => {\r\n        impulseResponse.stop();\r\n        impulseResponse.disconnect(audioEngine.context.destination);\r\n        emit(\"IMAGESOURCE_SET_PROPERTY\", { uuid: this.uuid, property: \"impulseResponsePlaying\", value: false });\r\n      };\r\n    }\r\n    async downloadImpulseResponse(filename: string, sampleRate = 44100){\r\n      if(!this.impulseResponse){\r\n        await this.calculateImpulseResponse().catch(console.error);\r\n      }\r\n      const blob = ac.wavAsBlob([normalize(this.impulseResponse.getChannelData(0))], { sampleRate, bitDepth: 32 });\r\n      const extension = !filename.endsWith(\".wav\") ? \".wav\" : \"\";\r\n      FileSaver.saveAs(blob, filename + extension);\r\n    }\r\n\r\n    // getters and setters\r\n    get sources() {\r\n      if (this.sourceIDs.length > 0) {\r\n        return this.sourceIDs.map((x) => useContainer.getState().containers[x]);\r\n      } else {\r\n        return [];\r\n      }\r\n    }\r\n    get receivers() {\r\n      if (this.receiverIDs.length > 0 && Object.keys(useContainer.getState().containers).length > 0) {\r\n        return this.receiverIDs.map((x) => (useContainer.getState().containers[x] as Receiver));\r\n      } else return [];\r\n    }\r\n\r\n    get room(): Room {\r\n      return useContainer.getState().containers[this.roomID] as Room;\r\n    }\r\n    \r\n    get numValidRays(): number {\r\n      let numValid = this.validRayPaths?.length; \r\n\r\n      if(numValid === undefined){\r\n        return 0; \r\n      }else{\r\n        return numValid; \r\n      }\r\n    }\r\n\r\n    get numTotalRays(): number {\r\n      let numTotal = this.allRayPaths?.length;\r\n\r\n      if(numTotal === undefined){\r\n        return 0; \r\n      }else{\r\n        return numTotal; \r\n      }\r\n    }\r\n\r\n    set maxReflectionOrderReset(o: number){\r\n      this.maxReflectionOrder = o; \r\n      this.reset(); \r\n    }\r\n\r\n    get maxReflectionOrderReset(){\r\n      return this.maxReflectionOrder; \r\n    }\r\n\r\n    set rayPathsVisible(vis: boolean){\r\n      if(vis === this._rayPathsVisible){\r\n        // do nothing\r\n      }else{\r\n        if(vis){\r\n          this.drawRayPaths(); \r\n        }else{\r\n          this.clearRayPaths(); \r\n        }\r\n      }\r\n      this._rayPathsVisible = vis; \r\n    }\r\n\r\n    get rayPathsVisible(){\r\n      return this._rayPathsVisible; \r\n    }\r\n\r\n    set imageSourcesVisible(vis: boolean){\r\n      if(vis === this._imageSourcesVisible){\r\n        // do nothing\r\n      }else{\r\n        if(vis){\r\n          this.drawImageSources(); \r\n        }else{\r\n          this.clearImageSources(); \r\n        }\r\n      }\r\n      this._imageSourcesVisible = vis; \r\n    }\r\n\r\n    get imageSourcesVisible(){\r\n      return this._imageSourcesVisible; \r\n    }\r\n\r\n    get possibleOrders(){\r\n      type OptionType = {\r\n        value: number;\r\n        label: any; \r\n      };\r\n\r\n      let o: OptionType[] = []; \r\n      for(let i = 0; i<=this.maxReflectionOrder; i++){\r\n        let op: OptionType = {\r\n          value: i,\r\n          label: i.toString()\r\n        }\r\n        o.push(op); \r\n      }\r\n      return o;\r\n    }\r\n\r\n    get selectedPlotOrders(){\r\n      type OptionType = {\r\n        value: number;\r\n        label: any; \r\n      };\r\n      let o: OptionType[] = []; \r\n      for(let i = 0; i<this.plotOrders.length; i++){\r\n        let op: OptionType = {\r\n          value: this.plotOrders[i],\r\n          label: this.plotOrders[i].toString()\r\n        }\r\n        o.push(op); \r\n      }\r\n      return o;\r\n    }\r\n\r\n    set toggleOrder(order: number){\r\n      if(order > this.maxReflectionOrder){\r\n        // do nothing\r\n      }else if(this.plotOrders.includes(order)){\r\n        this.plotOrders.splice(this.plotOrders.indexOf(order), 1);\r\n      }else{\r\n        this.plotOrders.push(order); \r\n      }\r\n      this.clearRayPaths(); \r\n      this.clearImageSources(); \r\n      this.drawRayPaths();\r\n      this.drawImageSources(); \r\n    }\r\n\r\n    get plotOrders(){\r\n      return this._plotOrders;\r\n    }\r\n\r\n    set plotOrders(orders: number[]) {\r\n      this._plotOrders = orders;\r\n      this.clearRayPaths(); \r\n      this.clearImageSources(); \r\n      this.rayPathsVisible && this.drawRayPaths();\r\n      this.imageSourcesVisible && this.drawImageSources(); \r\n    }\r\n\r\n    set plotFrequency(f: number){\r\n      this._plotFrequency = f;\r\n      this.calculateLTP(343); \r\n    }\r\n\r\n  \r\n}\r\n\r\nexport default ImageSourceSolver;\r\n\r\nfunction computeImageSources(is: ImageSource, maxOrder: number): ImageSource | null {\r\n\r\n  let surfaces: any[] = is.room.allSurfaces; \r\n    \r\n  // end recursion\r\n  if(maxOrder==0){\r\n    return null;\r\n  }\r\n\r\n  for(let i=0; i<surfaces.length; i++){\r\n  \r\n    // returns true if current image source's previous reflector is either null (direct sound) or not the current reflector.\r\n    let reflectorCondition: boolean = (is.reflector === null || is.reflector !== surfaces[i]);\r\n\r\n    // returns true if reflecting surface is in front of previous surface\r\n    let inFrontOf: boolean = true; \r\n\r\n    // check if facing each other\r\n    let facingEachOther: boolean;\r\n    if(is.reflector!==null){\r\n      facingEachOther = surfacesFacingEachother(surfaces[i], is.reflector);\r\n    }else{\r\n      facingEachOther = true;\r\n    }\r\n\r\n    if(reflectorCondition && (inFrontOf && facingEachOther)){\r\n\r\n      let is_reflect_params: ImageSourceParams = {\r\n        baseSource: is.baseSource,\r\n        position: reflectPointAcrossSurface(is.position.clone(),surfaces[i]).clone(), \r\n        room: is.room, \r\n        reflector: surfaces[i],\r\n        parent: is, \r\n        order: is.order+1, \r\n      };\r\n      \r\n      let reflectedSource: ImageSource = new ImageSource(is_reflect_params); \r\n\r\n      is.children.push(reflectedSource);\r\n\r\n      if(maxOrder > 0){\r\n        computeImageSources(reflectedSource,maxOrder-1);\r\n      }\r\n    }\r\n  }\r\n  return is; \r\n}\r\n\r\nfunction constructImageSourcePath(is: ImageSource, listener: Receiver): ImageSourcePath | null{\r\n  // note: will return null if no valid path\r\n  // otherwise, will return ImageSourcePath object representing path \r\n\r\n  let path: intersection[] = []; \r\n  \r\n  let maxOrder = is.order; \r\n\r\n  let listenerStart: intersection = {\r\n    point: listener.position.clone(),\r\n    reflectingSurface: null, \r\n    angle: null,\r\n  }\r\n  path[maxOrder+1] = listenerStart; \r\n\r\n  let raycaster = new THREE.Raycaster(); \r\n\r\n  for(let order = maxOrder; order>=1; order--){\r\n    let nextPosition: Vector3 = is.position.clone(); \r\n    let lastPosition: Vector3 = (path[order+1]).point.clone(); \r\n\r\n    let direction: Vector3 = new Vector3(0,0,0); // from current image source to last image source / receiver\r\n    direction.subVectors(nextPosition, lastPosition);\r\n    direction.normalize(); \r\n\r\n    raycaster.set(lastPosition,direction);\r\n    let intersections;\r\n    if(is.reflector !== null){\r\n      intersections = raycaster.intersectObject(is.reflector.mesh,true);\r\n    }\r\n    \r\n    if(intersections.length>0){\r\n      \r\n      let intersect: intersection = {\r\n        point: intersections[0].point, \r\n        reflectingSurface: is.reflector,\r\n        angle: direction.clone().multiplyScalar(-1).angleTo(intersections[0].face!.normal),\r\n      };\r\n\r\n      path[order] = intersect; \r\n    }else{\r\n      return null; // no valid path\r\n    }\r\n\r\n    if(is.parent !== null){\r\n      is = is.parent;\r\n    }\r\n\r\n  }\r\n\r\n  let sourceEnd: intersection = {\r\n    point: is.position.clone(),  \r\n    reflectingSurface: null, \r\n    angle: null, \r\n  };\r\n\r\n  path[0] = sourceEnd; \r\n  let pathObject = new ImageSourcePath(path); \r\n  return pathObject;\r\n}\r\n\r\nfunction isInFrontOf(surface1: Surface, surface2: Surface): boolean{\r\n  // figure out how to check this\r\n  return true; \r\n}\r\n\r\nfunction surfacesFacingEachother(surface1: Surface, surface2: Surface): boolean{\r\n  let normal1: Vector3 = surface1.normal.clone(); \r\n  let normal2: Vector3 = surface2.normal.clone(); \r\n\r\n  if(normal1.dot(normal2) <= 0){\r\n    return true;\r\n  }else{\r\n    return false; \r\n  }\r\n}\r\n\r\nfunction reflectPointAcrossSurface(point: Vector3, surface: Surface): Vector3{\r\n\r\n  // SEE https://gamedev.stackexchange.com/questions/43615/how-can-i-reflect-a-point-with-respect-to-the-plane\r\n\r\n  let a: Vector3 = new Vector3(surface.polygon.vertices[0][0], surface.polygon.vertices[0][1], surface.polygon.vertices[0][2]);\r\n  let b: Vector3 = new Vector3(surface.polygon.vertices[1][0], surface.polygon.vertices[1][1], surface.polygon.vertices[1][2]);\r\n  let c: Vector3 = new Vector3(surface.polygon.vertices[2][0], surface.polygon.vertices[2][1], surface.polygon.vertices[2][2]);\r\n\r\n  let a_global: Vector3 = surface.localToWorld(a);\r\n  let b_global: Vector3 = surface.localToWorld(b);\r\n  let c_global: Vector3 = surface.localToWorld(c);\r\n\r\n  b_global.sub(a_global);\r\n  c_global.sub(a_global);\r\n  b_global.cross(c_global);\r\n  b_global.normalize(); \r\n  let normal_calc = b_global; \r\n\r\n  // TODO: may want to change this, making some changes in the surface class\r\n  let normal = surface.normal.clone();\r\n  let negnormal = normal.clone(); \r\n  negnormal.multiplyScalar(-1);\r\n\r\n  let d = a_global.dot(negnormal);\r\n  \r\n  let u = normal.clone(); \r\n  u.multiplyScalar(point.dot(normal)+d); \r\n  \r\n  let v = point.clone(); \r\n  v.sub(u);\r\n\r\n  let mirror = u; \r\n  mirror.multiplyScalar(-1);\r\n  mirror.add(v);\r\n\r\n  return mirror; \r\n}\r\n\r\n\r\ndeclare global {\r\n  interface EventTypes {\r\n    ADD_IMAGESOURCE: ImageSourceSolver | undefined,\r\n    REMOVE_IMAGESOURCE: string;\r\n    IMAGESOURCE_CLEAR_RAYS: string;\r\n    IMAGESOURCE_SET_PROPERTY: {\r\n      uuid: string;\r\n      property: keyof ImageSourceSolver;\r\n      value: ImageSourceSolver[EventTypes[\"IMAGESOURCE_SET_PROPERTY\"][\"property\"]]; \r\n    }\r\n    UPDATE_IMAGESOURCE: string; \r\n    RESET_IMAGESOURCE: string;\r\n    CALCULATE_LTP: string; \r\n    IMAGESOURCE_PLAY_IR: string; \r\n    IMAGESOURCE_DOWNLOAD_IR: string; \r\n  }\r\n}\r\n\r\non(\"IMAGESOURCE_SET_PROPERTY\", setSolverProperty);\r\non(\"REMOVE_IMAGESOURCE\", removeSolver);\r\non(\"ADD_IMAGESOURCE\", addSolver(ImageSourceSolver));\r\non(\"UPDATE_IMAGESOURCE\", (uuid: string) => void (useSolver.getState().solvers[uuid] as ImageSourceSolver).updateImageSourceCalculation());\r\non(\"RESET_IMAGESOURCE\", (uuid: string) => void (useSolver.getState().solvers[uuid] as ImageSourceSolver).reset());\r\non(\"CALCULATE_LTP\", (uuid: string) => void (useSolver.getState().solvers[uuid] as ImageSourceSolver).calculateLTP(343));\r\non(\"IMAGESOURCE_PLAY_IR\", (uuid: string) => void (useSolver.getState().solvers[uuid] as ImageSourceSolver).playImpulseResponse().catch(console.error));\r\non(\"IMAGESOURCE_DOWNLOAD_IR\", (uuid: string) => {\r\n  const solver = useSolver.getState().solvers[uuid] as ImageSourceSolver;\r\n  const containers = useContainer.getState().containers;\r\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\r\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\r\n  const filename = `ir-imagesource-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\r\n  void solver.downloadImpulseResponse(filename).catch(console.error);\r\n});\r\n\r\n\r\n\r\n"],"names":["createLine","points","line","MeshLine","material","MeshLineMaterial","THREE","ImageSource","params","uuid","r","constructForThis","paths","thisPath","constructImageSourcePath","i","p","pos","renderer","sum","order","order_children","a","ImageSourcePath","path","p1","p2","room_surfaces","segmentStart","segmentEnd","prevReflector","reflector","j","direction","Vector3","raycaster","intersections","trueIntersections","length","startingPoint","endingPoint","initialSPL","freqs","intensity","ac.P2I","ac.Lp2P","s","intersection","findex","reflectionCoefficient","arrivalLp","ac.P2Lp","ac.I2P","airAttenuationdB","ac.airAttenuation","f","c","defaults","ImageSourceSolver","Solver","isHybrid","emit","ResultKind","rooms","getRooms","pickProps","imageSourcePath","x","is_params","useContainer","is_base","is_calculated","computeImageSources","valid_paths","initialSPLs","sortedPath","b","result","t","consoleOutput","levelTimeProgression","useResult","rayPathsOfOrder","source","messenger","is","is_2","receiver","validCount","orders","is_paths","rayPathUUID","sampleRate","spls","endTime","endSample","samples","roundedSample","offlineContext","audioEngine","sources","merger","impulseResponse","filename","blob","ac.wavAsBlob","normalize","extension","FileSaver","numValid","numTotal","o","vis","op","maxOrder","surfaces","reflectorCondition","facingEachOther","surfacesFacingEachother","is_reflect_params","reflectPointAcrossSurface","reflectedSource","listener","listenerStart","nextPosition","lastPosition","intersect","sourceEnd","surface1","surface2","normal1","normal2","point","surface","a_global","b_global","c_global","normal","negnormal","d","u","v","mirror","on","setSolverProperty","removeSolver","addSolver","useSolver","solver","containers","sourceName","receiverName"],"mappings":"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"}