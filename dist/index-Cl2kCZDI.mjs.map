{"version":3,"file":"index-Cl2kCZDI.mjs","sources":["../src/compute/raytracer/image-source/index.ts"],"sourcesContent":["import Solver from \"../../solver\";\nimport { renderer } from \"../../../render/renderer\";\nimport { v4 as uuid } from 'uuid';\nimport * as THREE from \"three\";\nimport { MeshLine, MeshLineMaterial } from 'three.meshline';\nimport * as ac from \"../../acoustics\";\nimport Room, { getRooms } from \"../../../objects/room\";\nimport { emit, messenger, on } from \"../../../messenger\";\nimport Source from \"../../../objects/source\";\nimport Receiver from \"../../../objects/receiver\";\nimport { Vector3 } from \"three\";\nimport Surface from \"../../../objects/surface\";\nimport { addSolver, removeSolver, Result, ResultKind, ResultTypes, setSolverProperty, useResult, useSolver } from \"../../../store\";\nimport {useContainer} from '../../../store';\nimport { pickProps } from \"../../../common/helpers\";\nimport { audioEngine } from \"../../../audio-engine/audio-engine\";\nimport {\n  playImpulseResponse as sharedPlayIR,\n  downloadImpulseResponse as sharedDownloadIR,\n} from \"../../shared/export-playback\";\n\nfunction createLine(){\n  let points: THREE.Vector3[] = [];\n  const line = new MeshLine();\n  line.setPoints(points);\n  const material = new MeshLineMaterial({\n    lineWidth: 0.1,\n    color: 0xff0000,\n    sizeAttenuation: 1, \n  });\n  return new THREE.Mesh(line, material);\n}\n\ninterface ImageSourceParams {\n  baseSource: Source,\n  position: Vector3,\n  room: Room,  \n  reflector: Surface | null,\n  parent: ImageSource | null,  \n  order: number,\n}\n\nclass ImageSource{\n\n  // the source that all image sources are based off of\n  // note: this is not the parent image source! that is 'parent' below \n  public baseSource: Source; \n  \n  public children: ImageSource[]; \n  public parent: ImageSource | null;  \n\n  public reflector: Surface | null; \n  public order: number; \n  public position: Vector3; \n\n  public room: Room;\n\n  public uuid: string; \n\n  constructor(params: ImageSourceParams){\n    this.baseSource = params.baseSource;\n    this.reflector = params.reflector; \n    this.order = params.order; \n\n    this.position = params.position; \n\n    this.children = []; \n    this.parent = params.parent; \n\n    this.room = params.room; \n    this.uuid = uuid(); \n  }\n\n  public constructPathsForAllDescendents(r: Receiver,constructForThis=true): ImageSourcePath[]{\n    let paths: ImageSourcePath[] = [];\n\n    // compute direct sound path\n    if(constructForThis){\n      let thisPath = constructImageSourcePath(this, r);\n      if(thisPath !== null){\n        paths.push(thisPath);\n      }\n    }\n\n    for(let i = 0; i<this.children.length; i++){\n      let p = constructImageSourcePath(this.children[i],r);\n\n      if (p!== null){\n        paths.push(p);\n      }\n\n      if(this.children[i].hasChildren){\n        paths = paths.concat(this.children[i].constructPathsForAllDescendents(r,false)); \n      } \n\n    }\n    return paths; \n  }\n\n  public markupAllDescendents(){\n    for(let i = 0; i<this.children.length; i++){\n      let pos: Vector3 = this.children[i].position.clone();\n      renderer.markup.addPoint([pos.x,pos.y,pos.z], [0,0,0]);\n      if (this.children[i].hasChildren){\n        this.children[i].markupAllDescendents(); \n      }else{\n      }\n    }\n  }\n\n  public markup(){\n    let pos: Vector3 = this.position.clone(); \n    renderer.markup.addPoint([pos.x,pos.y,pos.z], [0,0,0]);\n  }\n\n  public getTotalDescendents(): number{\n    let sum = 0; \n\n    for(let i = 0; i<this.children.length; i++){\n      sum++;\n      if(this.children[i].hasChildren){\n        sum = sum + this.children[i].getTotalDescendents(); \n      } \n    }\n    return sum; \n  }\n\n  public getChildrenOfOrder(order: number): ImageSource[]{\n    let order_children: ImageSource[] = [];\n\n    ((this.order === order) && (this.order === 0)) && order_children.push(this);\n\n    for(let i = 0; i<this.children.length; i++){\n      if(this.children[i].order === order){\n        order_children.push(this.children[i]);\n      }\n\n      if(this.children[i].hasChildren){\n        let a = this.children[i].getChildrenOfOrder(order); \n        order_children = order_children.concat(a); \n      }\n\n    }\n    return order_children; \n  }\n\n  get hasChildren() {\n    if (this.children.length > 0){\n      return true; \n    }else{\n      return false; \n    }\n  }\n\n}\n\ninterface IntersectionPoint {\n  point: Vector3;\n  reflectingSurface: Surface | null;\n  angle: number | null;\n}\n\nclass ImageSourcePath{\n\n  public path: IntersectionPoint[];\n  public uuid;\n  public highlight;\n\n  constructor(path: IntersectionPoint[]){\n    this.path = path; \n    this.uuid = uuid(); \n    this.highlight = false; \n  }\n\n  markup(){\n    for(let i = 0; i<this.path.length-1; i++){\n      let p1: Vector3 = (this.path[i]).point.clone();\n      let p2: Vector3 =  (this.path[i+1]).point.clone();\n      renderer.markup.addLine([p1.x,p1.y,p1.z],[p2.x,p2.y,p2.z]);\n    }\n  }\n\n  isvalid(room_surfaces: Surface[]): boolean{\n\n    for(let order = 1; order <= this.order+1; order++){\n\n      let segmentStart: Vector3 = this.path[order-1].point;\n      let segmentEnd: Vector3 = this.path[order].point; \n\n      let prevReflector: Surface | null = this.path[order-1].reflectingSurface; \n      let reflector: Surface | null = this.path[order].reflectingSurface; \n\n      for(let j = 0; j<room_surfaces.length; j++){\n        if((room_surfaces[j] !== prevReflector) && (room_surfaces[j] !== reflector)){\n\n          // from current image source to last image source / receiver\n          let direction: Vector3 = new Vector3(0,0,0); \n          direction.subVectors(segmentEnd, segmentStart);\n          direction.normalize(); \n\n          let raycaster = new THREE.Raycaster(); \n          raycaster.set(segmentStart,direction);\n          let intersections; \n          intersections = raycaster.intersectObject(room_surfaces[j].mesh, true);\n\n          // remove any intersections of surfaces BEHIND the desired end point\n          // (verify this)\n          let trueIntersections = [];\n          for(let i = 0; i<intersections.length; i++){\n            if(segmentStart.distanceTo(intersections[i].point) < segmentStart.distanceTo(segmentEnd)){\n              trueIntersections.push(intersections[i]);\n            }\n          }\n\n          if (trueIntersections.length > 0){\n            return false; \n          }\n        }\n      }\n\n    }\n    return true; \n  }\n\n  public get order(){\n    return this.path.length - 2; \n  }\n\n  public get totalLength(){\n    let length: number = 0; \n    let startingPoint: Vector3; \n    let endingPoint: Vector3;\n    for(let i = 1; i<this.path.length; i++){\n      startingPoint = this.path[i-1].point;\n      endingPoint = this.path[i].point;\n      length = length+startingPoint.distanceTo(endingPoint); \n    }\n    return length; \n  }\n  \n  public arrivalPressure(initialSPL: number[], freqs: number[], temperature: number = 20): number[]{\n\n    let intensity = ac.P2I(ac.Lp2P(initialSPL)) as number[];\n\n    for(let s = 0; s<this.path.length; s++){\n\n      let intersection = this.path[s];\n      if(intersection.reflectingSurface === null){\n        // either source or a receiver\n        // do nothing to intensity levels\n      }else{\n        // intersected with a surface\n        for(let findex = 0; findex<freqs.length; findex++){\n          const reflectionCoefficient = Math.abs((intersection.reflectingSurface as Surface).reflectionFunction(freqs[findex], intersection.angle!));\n          intensity[findex] = intensity[findex]*reflectionCoefficient;\n        }\n      }\n    }\n\n    // convert back to SPL\n    let arrivalLp = ac.P2Lp(ac.I2P(intensity)) as number[];\n\n    // apply air absorption (dB/m)\n    const airAttenuationdB = ac.airAttenuation(freqs, temperature);\n    for(let f = 0; f<freqs.length; f++){\n      arrivalLp[f] = arrivalLp[f] - airAttenuationdB[f]*this.totalLength;\n    }\n\n    // convert back to pressure\n    return ac.Lp2P(arrivalLp) as number[];\n  }\n\n  public arrivalTime(c: number): number{\n    return this.totalLength / c; \n  }\n}\n\nexport type ImageSourceSaveObject = {\n  name: string;\n  kind: \"image-source\";\n  uuid: string;\n  autoCalculate: boolean;\n  roomID: string;\n  sourceIDs: string[];\n  surfaceIDs: string[];\n  receiverIDs: string[];\n  maxReflectionOrder: number;\n  imageSourcesVisible: boolean;\n  rayPathsVisible: boolean;\n  plotOrders: number[];\n  frequencies: number[];\n  levelTimeProgression: string;\n}\n\n\nexport interface ImageSourceSolverParams {\n  name: string;\n  uuid?: string;\n  roomID: string;\n  sourceIDs: string[];\n  surfaceIDs: string[];\n  receiverIDs: string[];\n  maxReflectionOrder: number;\n  imageSourcesVisible: boolean;\n  rayPathsVisible: boolean;\n  plotOrders: number[];\n  frequencies: number[];\n  levelTimeProgression?: string;\n}\n\nconst defaults = {\n  name: \"Image Source\",\n  roomID: \"\",\n  sourceIDs: [] as string[],\n  surfaceIDs: [] as string[],\n  receiverIDs: [] as string[],\n  maxReflectionOrder: 2,\n  imageSourcesVisible: true,\n  rayPathsVisible: true, \n  plotOrders: [0, 1, 2], // all paths\n  frequencies: [125,250,500,1000,2000,4000,8000],\n};\n\nexport interface HybridRayPath {\n  time: number,\n  pressure: number[]\n}\n\nexport class ImageSourceSolver extends Solver {\n\n    sourceIDs: string[];\n    receiverIDs: string[];\n    roomID: string;\n    surfaceIDs: string[];\n    uuid: string;\n    levelTimeProgression: string;\n    maxReflectionOrder: number;\n    frequencies: number[];\n\n    private _imageSourcesVisible: boolean;\n    private _rayPathsVisible: boolean;\n    private _plotOrders: number[]; \n\n    impulseResponse!: AudioBuffer; \n    impulseResponsePlaying: boolean; \n\n    rootImageSource: ImageSource | null; \n    validRayPaths: ImageSourcePath[] | null; \n    allRayPaths: ImageSourcePath[] | null; \n\n    selectedImageSourcePath: THREE.Mesh;\n\n    private _plotFrequency: number; \n\n    isHybrid: boolean; \n\n    constructor(params: ImageSourceSolverParams = defaults, isHybrid:boolean = false){\n        super(params);\n        this.uuid = params.uuid || uuid(); \n        this.kind = \"image-source\";\n        this.name = params.name;\n        this.roomID = params.roomID;\n        this.sourceIDs = params.sourceIDs;\n        this.receiverIDs = params.receiverIDs;\n        this.maxReflectionOrder = params.maxReflectionOrder; \n        this.frequencies = params.frequencies; \n        this._imageSourcesVisible = params.imageSourcesVisible; \n        this._rayPathsVisible = params.rayPathsVisible; \n        this._plotOrders = params.plotOrders; \n        this.levelTimeProgression = params.levelTimeProgression || uuid();\n        this.isHybrid = isHybrid;\n\n        this.impulseResponsePlaying = false; \n\n        this._plotFrequency = 1000; \n\n        if(!this.isHybrid){\n          emit(\"ADD_RESULT\", {\n            kind: ResultKind.LevelTimeProgression, \n            data: [],\n            info: {\n              initialSPL: [100],\n              frequency: [this._plotFrequency],\n              maxOrder: this.maxReflectionOrder,\n            },\n            name: `LTP - ${this.name}`,\n            uuid: this.levelTimeProgression,\n            from: this.uuid\n          } as Result<ResultKind.LevelTimeProgression>);\n        }\n\n        this.surfaceIDs = []; \n        \n        this.rootImageSource = null;\n        this.allRayPaths = null;  \n        this.validRayPaths = null; \n\n        const rooms = getRooms();\n\n        // get room \n        this.roomID = rooms[0].uuid;\n\n        // //@ts-ignore\n        this.selectedImageSourcePath = createLine();\n        renderer.markup.add(this.selectedImageSourcePath);\n    }\n\n    save(){\n      return pickProps([\n        \"name\",\n        \"kind\",\n        \"uuid\",\n        \"autoCalculate\",\n        \"roomID\",\n        \"sourceIDs\",\n        \"surfaceIDs\",\n        \"receiverIDs\",\n        \"maxReflectionOrder\",\n        \"imageSourcesVisible\",\n        \"rayPathsVisible\",\n        \"plotOrders\",\n        \"levelTimeProgression\"\n      ], this) as ImageSourceSaveObject;\n    }\n\n    dispose(){\n        renderer.markup.remove(this.selectedImageSourcePath);\n        this.reset();\n        emit(\"REMOVE_RESULT\", this.levelTimeProgression);\n    }\n\n    updateSelectedImageSourcePath(imageSourcePath: ImageSourcePath){\n      (this.selectedImageSourcePath.geometry as unknown as MeshLine).setPoints(\n        new Float32Array(imageSourcePath.path.map(x=>x.point.toArray()).flat())\n      );\n      // (this.selectedImageSourcePath.geometry as LineGeometry).setFromPoints(\n      //   imageSourcePath.path.map(x=>x.point)\n      // );\n      // (this.selectedImageSourcePath.geometry as LineGeometry).setDrawRange(0,imageSourcePath.path.length);\n      console.log(imageSourcePath.path.map(x=>x.point.toArray()).flat());\n    }\n\n    updateImageSourceCalculation(){\n\n      // clear markup (replace with a more robust method eventually)\n      this.clearRayPaths(); \n      this.clearImageSources(); \n\n      // add in checking to make sure only 1 source and 1 receiver are selected\n\n      let is_params: ImageSourceParams = {\n        baseSource: useContainer.getState().containers[this.sourceIDs[0]] as Source,\n        position: (useContainer.getState().containers[this.sourceIDs[0]] as Source).position.clone(), \n        room: this.room, \n        reflector: null,\n        parent: null, \n        order: 0, \n      };\n      \n      let is_base: ImageSource = new ImageSource(is_params);\n      let is_calculated: ImageSource | null = computeImageSources(is_base,this.maxReflectionOrder); \n\n      this.rootImageSource = is_calculated; \n\n      // construct all possible paths\n      let paths: ImageSourcePath[];\n      let valid_paths: ImageSourcePath[] = [];\n      if(is_calculated !== null){\n        paths = is_calculated.constructPathsForAllDescendents(useContainer.getState().containers[this.receiverIDs[0]] as Receiver);\n\n        this.allRayPaths = paths; \n\n        // get valid paths\n        for(let i = 0; i<paths?.length; i++){\n          if(paths[i].isvalid(this.room.allSurfaces as Surface[])){\n            valid_paths.push(paths[i]); \n          }\n        }\n      }\n      this.validRayPaths = valid_paths; \n      (this._imageSourcesVisible) && (this.drawImageSources());\n      (this._rayPathsVisible) && (this.drawRayPaths()); \n\n      if(!this.isHybrid){\n        this.calculateLTP();\n      }\n    }\n\n    // hybrid solver use only\n    returnSortedPathsForHybrid(c: number, initialSPLs: number[], freqs: number[]){\n      this.updateImageSourceCalculation(); \n\n      let sortedPath: ImageSourcePath[] | null = this.validRayPaths; \n      sortedPath?.sort((a, b) => (a.arrivalTime(c) > b.arrivalTime(c)) ? 1 : -1); \n\n      let result: HybridRayPath[] = [];\n\n      if(sortedPath != null){\n        for(let i = 0; i<sortedPath.length; i++){\n          let t = sortedPath[i].arrivalTime(c);\n          let p = sortedPath[i].arrivalPressure(initialSPLs, freqs, this.temperature);\n          let path: HybridRayPath = {\n            time: t, \n            pressure: p,\n          }\n          result.push(path);\n        }\n      }\n      return result;\n    }\n\n    calculateLTP(c: number = this.c, consoleOutput: boolean = false){\n      // If no paths have been calculated yet, run the calculation first\n      if (!this.validRayPaths || this.validRayPaths.length === 0) {\n        if (this.sourceIDs.length > 0 && this.receiverIDs.length > 0) {\n          this.updateImageSourceCalculation();\n          return; // updateImageSourceCalculation calls calculateLTP at the end\n        }\n        return;\n      }\n\n      let sortedPath: ImageSourcePath[] | null = this.validRayPaths;\n      sortedPath?.sort((a, b) => (a.arrivalTime(c) > b.arrivalTime(c)) ? 1 : -1);\n      const levelTimeProgression = { ...useResult.getState().results[this.levelTimeProgression] as Result<ResultKind.LevelTimeProgression> };\n      levelTimeProgression.data = [] as ResultTypes[ResultKind.LevelTimeProgression][\"data\"];\n      levelTimeProgression.info = {\n        ...levelTimeProgression.info,\n        maxOrder: this.maxReflectionOrder,\n        frequency: [this._plotFrequency]\n      }\n      if(sortedPath !== undefined){\n        for(let i = 0; i<sortedPath?.length; i++){\n          let t = sortedPath[i].arrivalTime(c);\n          let p = sortedPath[i].arrivalPressure(levelTimeProgression.info.initialSPL, levelTimeProgression.info.frequency, this.temperature);\n          if(consoleOutput){\n            console.log(\"Arrival: \" + (i+1) + \" | Arrival Time: (s) \" + t + \" | Arrival Pressure(1000Hz): \" + p + \" | Order \" + sortedPath[i].order);\n          }\n\n          levelTimeProgression.data.push({\n            time: t,\n            pressure: ac.P2Lp(p) as number[],\n            arrival: i+1,\n            order: sortedPath[i].order,\n            uuid: sortedPath[i].uuid\n          })\n        }\n      }\n\n      emit(\"UPDATE_RESULT\", { uuid: this.levelTimeProgression, result: levelTimeProgression });\n    }\n\n    getPathsOfOrder(order: number): ImageSourcePath[]{\n      let rayPathsOfOrder: ImageSourcePath[] = [];\n      if(this.validRayPaths !== null){\n        for(let i = 0; i<this.validRayPaths?.length; i++){\n          if(this.validRayPaths[i].order === order){\n            rayPathsOfOrder.push(this.validRayPaths[i]);\n          }\n        }\n      }\n      return rayPathsOfOrder; \n    }\n\n    test(){\n\n      // debugging\n\n        // get source\n        let source: Source = messenger.postMessage(\"FETCH_SOURCE\",this.sourceIDs[0])[0];\n\n        // assign base image source\n        let is_params: ImageSourceParams = {\n          baseSource: source.clone(),\n          position: source.position.clone(),\n          room: this.room,\n          reflector: null,\n          parent: null, \n          order: 0, \n        };\n\n        let is: ImageSource = new ImageSource(is_params);\n        \n        let maxOrder = 1; \n        let is_2 = computeImageSources(is,maxOrder); \n        is_2?.markup(); \n        console.log(is_2); \n\n        let receiver: Receiver = this.receivers[0];\n        console.log(receiver);\n\n        let paths: ImageSourcePath[];\n        if(is_2 !== null){\n          paths = is_2.constructPathsForAllDescendents(receiver);\n\n          let f = [125, 250, 500, 1000, 2000, 4000];\n          let initialSPL = [100,100,100,100,100,100]; \n\n          let validCount = 0; \n          for(let i = 0; i<paths.length; i++){\n            if(paths[i].isvalid(this.room.allSurfaces as Surface[])){\n              paths[i].markup(); \n              console.log(paths[i]);\n              console.log(paths[i].totalLength)\n              console.log(paths[i].arrivalTime(this.c));\n              console.log(ac.Lp2P(initialSPL));\n              //console.log(paths[i].arrivalPressure(initialSPL,f))\n              validCount++; \n            }\n          }\n          console.log(validCount + \" out of \" + paths.length + \" paths are valid\"); \n        } \n    }\n\n    clearLevelTimeProgressionData(){\n      const levelTimeProgression = { ...useResult.getState().results[this.levelTimeProgression] };\n      levelTimeProgression.data = [];\n      emit(\"UPDATE_RESULT\", { uuid: this.levelTimeProgression, result: levelTimeProgression });\n    }\n    \n    reset(){\n      this.rootImageSource = null;\n      this.allRayPaths = null;  \n      this.validRayPaths = null; \n      this.plotOrders = (this.possibleOrders).map((e)=>e.value); \n      (this.selectedImageSourcePath.geometry as unknown as MeshLine).setPoints(new Float32Array(0));\n      this.clearImageSources(); \n      this.clearRayPaths(); \n      this.clearLevelTimeProgressionData();\n    }\n\n    // plot functions\n    drawImageSources(){\n      this.clearImageSources(); \n      for(let i = 0; i<this.plotOrders.length; i++){\n        let is = this.rootImageSource?.getChildrenOfOrder(this.plotOrders[i]) as ImageSource[];   \n        for(let j = 0; j<is?.length; j++){\n          is[j].markup(); \n        }\n      }\n    }\n\n    clearImageSources(){\n      // placeholder\n      renderer.markup.clearPoints(); \n    }\n\n    drawRayPaths(orders?:number[]){\n      this.clearRayPaths(); \n      for(let i = 0; i<this.plotOrders.length; i++){\n        let is_paths = this.getPathsOfOrder(this.plotOrders[i]) as ImageSourcePath[]; \n        for(let j = 0; j<is_paths.length; j++){\n          is_paths[j].markup(); \n        }\n      }\n    }\n\n    clearRayPaths(){\n      // placeholder\n      renderer.markup.clearLines(); \n    }\n\n    toggleRayPathHighlight(rayPathUUID: string){\n      if(this.validRayPaths != null){\n        for(let i = 0; i<this.validRayPaths.length; i++){\n          if(rayPathUUID === this.validRayPaths[i].uuid){\n            this.updateSelectedImageSourcePath(this.validRayPaths[i])\n            console.log(\"WILL HIGHLIGHT RAY PATH WITH ARRIVAL SPL \" + ac.P2Lp(this.validRayPaths[i].arrivalPressure([100], [1000], this.temperature)) + \" AND ARRIVAL TIME \" + this.validRayPaths[i].arrivalTime(this.c));\n            break;\n          }\n        }\n      }\n\n    }\n\n    async calculateImpulseResponse(){\n      const initialSPL = 100; //PLACEHOLDER\n      const freqs = this.frequencies;\n      const sampleRate = 44100;\n      const spls = Array(freqs.length).fill(initialSPL);\n\n      if(this.receiverIDs.length === 0) throw Error(\"No receivers have been assigned to the raytracer\");\n      if(this.sourceIDs.length === 0) throw Error(\"No sources have been assigned to the raytracer\");\n      if(this.validRayPaths?.length === 0) throw Error(\"No rays have been traced yet\");\n\n      const c = this.c;\n      let sortedPath: ImageSourcePath[] | null = this.validRayPaths;\n      sortedPath?.sort((a, b) => (a.arrivalTime(c) > b.arrivalTime(c)) ? 1 : -1);\n\n      console.log(sortedPath);\n\n      if(sortedPath != null){\n        const endTime = sortedPath[sortedPath.length - 1].arrivalTime(c)+0.05;\n        const endSample = sampleRate*endTime;\n\n        let samples: Float32Array[] = [];\n        for(let f = 0; f<this.frequencies.length; f++){\n          samples.push(new Float32Array(Math.floor(endSample)));\n        }\n\n        for(let i = 0; i<sortedPath.length; i++){\n          let t = sortedPath[i].arrivalTime(c);\n          let p = sortedPath[i].arrivalPressure(spls, this.frequencies, this.temperature);\n\n          (Math.random() > 0.5) && (p=p.map(x=>-x)); \n\n          let roundedSample = Math.floor(t*sampleRate);\n\n          for(let f = 0; f<this.frequencies.length; f++){\n            samples[f][roundedSample] += p[f]; \n          }\n        }\n          \n        // samples.forEach((x,i,arr)=>{\n        //   const {b, a} = coefs.get(freqs[i])!;\n        //   arr[i] = filter(b,a,x);\n        // });\n    \n        const offlineContext = audioEngine.createOfflineContext(1, endSample, sampleRate);\n\n        const sources = Array(this.frequencies.length); \n        for(let f = 0; f<this.frequencies.length; f++){\n          sources[f] = audioEngine.createFilteredSource(samples[f],this.frequencies[f],1.414,1,offlineContext); \n        }\n\n        //const sources = samples.map(x => audioEngine.createBufferSource(x, offlineContext));\n\n        console.log(sources);\n\n        const merger = audioEngine.createMerger(sources.length, offlineContext);\n        \n        for(let i = 0; i<sources.length; i++){\n          sources[i].source.connect(merger, 0, i);\n        }\n    \n        merger.connect(offlineContext.destination);\n        sources.forEach(source=>source.source.start());\n\n        this.impulseResponse = await audioEngine.renderContextAsync(offlineContext);\n\n        return this.impulseResponse;\n\n      } \n    }\n\n    async playImpulseResponse(){\n      const result = await sharedPlayIR(\n        this.impulseResponse, () => this.calculateImpulseResponse(), this.uuid, \"IMAGESOURCE_SET_PROPERTY\"\n      );\n      this.impulseResponse = result.impulseResponse;\n    }\n    async downloadImpulseResponse(filename: string, sampleRate = 44100){\n      const result = await sharedDownloadIR(\n        this.impulseResponse, () => this.calculateImpulseResponse(), filename, sampleRate\n      );\n      this.impulseResponse = result.impulseResponse;\n    }\n\n    // getters and setters\n    get sources() {\n      if (this.sourceIDs.length > 0) {\n        return this.sourceIDs.map((x) => useContainer.getState().containers[x]);\n      } else {\n        return [];\n      }\n    }\n    get receivers() {\n      if (this.receiverIDs.length > 0 && Object.keys(useContainer.getState().containers).length > 0) {\n        return this.receiverIDs.map((x) => (useContainer.getState().containers[x] as Receiver));\n      } else return [];\n    }\n\n    get room(): Room {\n      return useContainer.getState().containers[this.roomID] as Room;\n    }\n    \n    get numValidRays(): number {\n      let numValid = this.validRayPaths?.length; \n\n      if(numValid === undefined){\n        return 0; \n      }else{\n        return numValid; \n      }\n    }\n\n    get numTotalRays(): number {\n      let numTotal = this.allRayPaths?.length;\n\n      if(numTotal === undefined){\n        return 0; \n      }else{\n        return numTotal; \n      }\n    }\n\n    set maxReflectionOrderReset(o: number){\n      this.maxReflectionOrder = o; \n      this.reset(); \n    }\n\n    get maxReflectionOrderReset(){\n      return this.maxReflectionOrder; \n    }\n\n    set rayPathsVisible(vis: boolean){\n      if(vis === this._rayPathsVisible){\n        // do nothing\n      }else{\n        if(vis){\n          this.drawRayPaths(); \n        }else{\n          this.clearRayPaths(); \n        }\n      }\n      this._rayPathsVisible = vis; \n    }\n\n    get rayPathsVisible(){\n      return this._rayPathsVisible; \n    }\n\n    set imageSourcesVisible(vis: boolean){\n      if(vis === this._imageSourcesVisible){\n        // do nothing\n      }else{\n        if(vis){\n          this.drawImageSources(); \n        }else{\n          this.clearImageSources(); \n        }\n      }\n      this._imageSourcesVisible = vis; \n    }\n\n    get imageSourcesVisible(){\n      return this._imageSourcesVisible; \n    }\n\n    get possibleOrders(){\n      type OptionType = {\n        value: number;\n        label: any; \n      };\n\n      let o: OptionType[] = []; \n      for(let i = 0; i<=this.maxReflectionOrder; i++){\n        let op: OptionType = {\n          value: i,\n          label: i.toString()\n        }\n        o.push(op); \n      }\n      return o;\n    }\n\n    get selectedPlotOrders(){\n      type OptionType = {\n        value: number;\n        label: any; \n      };\n      let o: OptionType[] = []; \n      for(let i = 0; i<this.plotOrders.length; i++){\n        let op: OptionType = {\n          value: this.plotOrders[i],\n          label: this.plotOrders[i].toString()\n        }\n        o.push(op); \n      }\n      return o;\n    }\n\n    set toggleOrder(order: number){\n      if(order > this.maxReflectionOrder){\n        // do nothing\n      }else if(this.plotOrders.includes(order)){\n        this.plotOrders.splice(this.plotOrders.indexOf(order), 1);\n      }else{\n        this.plotOrders.push(order); \n      }\n      this.clearRayPaths(); \n      this.clearImageSources(); \n      this.drawRayPaths();\n      this.drawImageSources(); \n    }\n\n    get plotOrders(){\n      return this._plotOrders;\n    }\n\n    set plotOrders(orders: number[]) {\n      this._plotOrders = orders;\n      this.clearRayPaths(); \n      this.clearImageSources(); \n      this.rayPathsVisible && this.drawRayPaths();\n      this.imageSourcesVisible && this.drawImageSources(); \n    }\n\n    get temperature(): number {\n      return this.room?.temperature ?? 20;\n    }\n\n    get c(): number {\n      return ac.soundSpeed(this.temperature);\n    }\n\n    set plotFrequency(f: number){\n      this._plotFrequency = f;\n      this.calculateLTP();\n    }\n\n  \n}\n\nexport default ImageSourceSolver;\n\nfunction computeImageSources(is: ImageSource, maxOrder: number): ImageSource | null {\n\n  let surfaces: any[] = is.room.allSurfaces; \n    \n  // end recursion\n  if(maxOrder==0){\n    return null;\n  }\n\n  for(let i=0; i<surfaces.length; i++){\n  \n    // returns true if current image source's previous reflector is either null (direct sound) or not the current reflector.\n    let reflectorCondition: boolean = (is.reflector === null || is.reflector !== surfaces[i]);\n\n    // returns true if reflecting surface is in front of previous surface\n    let inFrontOf: boolean = true; \n\n    // check if facing each other\n    let facingEachOther: boolean;\n    if(is.reflector!==null){\n      facingEachOther = surfacesFacingEachother(surfaces[i], is.reflector);\n    }else{\n      facingEachOther = true;\n    }\n\n    if(reflectorCondition && (inFrontOf && facingEachOther)){\n\n      let is_reflect_params: ImageSourceParams = {\n        baseSource: is.baseSource,\n        position: reflectPointAcrossSurface(is.position.clone(),surfaces[i]).clone(), \n        room: is.room, \n        reflector: surfaces[i],\n        parent: is, \n        order: is.order+1, \n      };\n      \n      let reflectedSource: ImageSource = new ImageSource(is_reflect_params); \n\n      is.children.push(reflectedSource);\n\n      if(maxOrder > 0){\n        computeImageSources(reflectedSource,maxOrder-1);\n      }\n    }\n  }\n  return is; \n}\n\nfunction constructImageSourcePath(is: ImageSource, listener: Receiver): ImageSourcePath | null{\n  // note: will return null if no valid path\n  // otherwise, will return ImageSourcePath object representing path \n\n  let path: IntersectionPoint[] = [];\n\n  let maxOrder = is.order;\n\n  let listenerStart: IntersectionPoint = {\n    point: listener.position.clone(),\n    reflectingSurface: null,\n    angle: null,\n  }\n  path[maxOrder+1] = listenerStart;\n\n  let raycaster = new THREE.Raycaster();\n\n  for(let order = maxOrder; order>=1; order--){\n    let nextPosition: Vector3 = is.position.clone();\n    let lastPosition: Vector3 = (path[order+1]).point.clone();\n\n    let direction: Vector3 = new Vector3(0,0,0); // from current image source to last image source / receiver\n    direction.subVectors(nextPosition, lastPosition);\n    direction.normalize();\n\n    raycaster.set(lastPosition,direction);\n    if(is.reflector === null){\n      return null; // no valid path\n    }\n    const intersections = raycaster.intersectObject(is.reflector.mesh,true);\n\n    if(intersections.length>0){\n\n      let intersect: IntersectionPoint = {\n        point: intersections[0].point,\n        reflectingSurface: is.reflector,\n        angle: direction.clone().multiplyScalar(-1).angleTo(intersections[0].face!.normal),\n      };\n\n      path[order] = intersect;\n    }else{\n      return null; // no valid path\n    }\n\n    if(is.parent !== null){\n      is = is.parent;\n    }\n\n  }\n\n  let sourceEnd: IntersectionPoint = {\n    point: is.position.clone(),\n    reflectingSurface: null,\n    angle: null,\n  };\n\n  path[0] = sourceEnd; \n  let pathObject = new ImageSourcePath(path); \n  return pathObject;\n}\n\nfunction isInFrontOf(surface1: Surface, surface2: Surface): boolean{\n  // figure out how to check this\n  return true; \n}\n\nfunction surfacesFacingEachother(surface1: Surface, surface2: Surface): boolean{\n  let normal1: Vector3 = surface1.normal.clone(); \n  let normal2: Vector3 = surface2.normal.clone(); \n\n  if(normal1.dot(normal2) <= 0){\n    return true;\n  }else{\n    return false; \n  }\n}\n\nfunction reflectPointAcrossSurface(point: Vector3, surface: Surface): Vector3{\n\n  // SEE https://gamedev.stackexchange.com/questions/43615/how-can-i-reflect-a-point-with-respect-to-the-plane\n\n  let a: Vector3 = new Vector3(surface.polygon.vertices[0][0], surface.polygon.vertices[0][1], surface.polygon.vertices[0][2]);\n\n  let a_global: Vector3 = surface.localToWorld(a);\n\n  let normal = surface.normal.clone();\n  let negnormal = normal.clone(); \n  negnormal.multiplyScalar(-1);\n\n  let d = a_global.dot(negnormal);\n  \n  let u = normal.clone(); \n  u.multiplyScalar(point.dot(normal)+d); \n  \n  let v = point.clone(); \n  v.sub(u);\n\n  let mirror = u; \n  mirror.multiplyScalar(-1);\n  mirror.add(v);\n\n  return mirror; \n}\n\n\ndeclare global {\n  interface EventTypes {\n    ADD_IMAGESOURCE: ImageSourceSolver | undefined,\n    REMOVE_IMAGESOURCE: string;\n    IMAGESOURCE_CLEAR_RAYS: string;\n    IMAGESOURCE_SET_PROPERTY: {\n      uuid: string;\n      property: keyof ImageSourceSolver;\n      value: ImageSourceSolver[EventTypes[\"IMAGESOURCE_SET_PROPERTY\"][\"property\"]]; \n    }\n    UPDATE_IMAGESOURCE: string; \n    RESET_IMAGESOURCE: string;\n    CALCULATE_LTP: string; \n    IMAGESOURCE_PLAY_IR: string; \n    IMAGESOURCE_DOWNLOAD_IR: string; \n  }\n}\n\non(\"IMAGESOURCE_SET_PROPERTY\", setSolverProperty);\non(\"REMOVE_IMAGESOURCE\", removeSolver);\non(\"ADD_IMAGESOURCE\", addSolver(ImageSourceSolver));\non(\"UPDATE_IMAGESOURCE\", (uuid: string) => void (useSolver.getState().solvers[uuid] as ImageSourceSolver).updateImageSourceCalculation());\non(\"RESET_IMAGESOURCE\", (uuid: string) => void (useSolver.getState().solvers[uuid] as ImageSourceSolver).reset());\non(\"CALCULATE_LTP\", (uuid: string) => void (useSolver.getState().solvers[uuid] as ImageSourceSolver).calculateLTP());\non(\"IMAGESOURCE_PLAY_IR\", (uuid: string) => void (useSolver.getState().solvers[uuid] as ImageSourceSolver).playImpulseResponse().catch(console.error));\non(\"IMAGESOURCE_DOWNLOAD_IR\", (uuid: string) => {\n  const solver = useSolver.getState().solvers[uuid] as ImageSourceSolver;\n  const containers = useContainer.getState().containers;\n  const sourceName = solver.sourceIDs.length > 0 ? containers[solver.sourceIDs[0]]?.name || 'source' : 'source';\n  const receiverName = solver.receiverIDs.length > 0 ? containers[solver.receiverIDs[0]]?.name || 'receiver' : 'receiver';\n  const filename = `ir-imagesource-${sourceName}-${receiverName}`.replace(/[^a-zA-Z0-9-_]/g, '_');\n  void solver.downloadImpulseResponse(filename).catch(console.error);\n});\n\n\n\n"],"names":["createLine","points","line","MeshLine","material","MeshLineMaterial","THREE","ImageSource","params","uuid","r","constructForThis","paths","thisPath","constructImageSourcePath","i","p","pos","renderer","sum","order","order_children","a","ImageSourcePath","path","p1","p2","room_surfaces","segmentStart","segmentEnd","prevReflector","reflector","j","direction","Vector3","raycaster","intersections","trueIntersections","length","startingPoint","endingPoint","initialSPL","freqs","temperature","intensity","ac.P2I","ac.Lp2P","s","intersection","findex","reflectionCoefficient","arrivalLp","ac.P2Lp","ac.I2P","airAttenuationdB","ac.airAttenuation","f","c","defaults","ImageSourceSolver","Solver","isHybrid","emit","ResultKind","rooms","getRooms","pickProps","imageSourcePath","x","is_params","useContainer","is_base","is_calculated","computeImageSources","valid_paths","initialSPLs","sortedPath","b","result","t","consoleOutput","levelTimeProgression","useResult","rayPathsOfOrder","source","messenger","is","is_2","receiver","validCount","orders","is_paths","rayPathUUID","sampleRate","spls","endTime","endSample","samples","roundedSample","offlineContext","audioEngine","sources","merger","sharedPlayIR","filename","sharedDownloadIR","numValid","numTotal","o","vis","op","ac.soundSpeed","maxOrder","surfaces","reflectorCondition","facingEachOther","surfacesFacingEachother","is_reflect_params","reflectPointAcrossSurface","reflectedSource","listener","listenerStart","nextPosition","lastPosition","intersect","sourceEnd","surface1","surface2","normal1","normal2","point","surface","a_global","normal","negnormal","d","u","v","mirror","on","setSolverProperty","removeSolver","addSolver","useSolver","solver","containers","sourceName","receiverName"],"mappings":"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"}