{"version":3,"file":"audio-engine-BltQIBir.mjs","sources":["../src/compute/acoustics/util/nums.ts","../src/compute/acoustics/bands.ts","../src/compute/acoustics/util/wav.ts","../src/compute/acoustics/util/normalize.ts","../src/common/throwif.ts","../src/audio-engine/audio-engine.ts"],"sourcesContent":["export function nums(f: Function, v: number | number[]): number | number[] {\n  if (typeof v === 'number') {\n    return f(v);\n  } else {\n    return v.map(x => f(x));\n  }\n}\n","import { nums } from './util/nums';\n\nimport { third_octave_all, whole_octave_all } from './std/bands';\n\n/**\n * @description Returns the nominal octave band frequencies between a given range (inclusive)\n * @function Octave\n * @param {number} [start] start frequency\n * @param {number} [end] end frequency\n */\nexport function Octave(start: number, end: number): number[] {\n  return whole_octave_all\n    .map(x => x.Center)\n    .filter(x => x >= Number(start || 0) && x <= Number(end || 20000));\n}\n\n/**\n * @description Returns the nominal third octave band frequencies between a given range (inclusive)\n * @function ThirdOctave\n * @param {number} [start] start frequency\n * @param {number} [end] end frequency\n */\nexport function ThirdOctave(start?: number, end?: number): number[] {\n  return third_octave_all\n    .map(x => x.Center)\n    .filter(x => x >= Number(start || 0) && x <= Number(end || 22000));\n}\n\n/**\n * @description Returns the lower band limit of a frequency band\n * @function Flower\n * @param {number} k inverse fraction (i.e. third = 3, sixth = 6, etc.)\n * @param {number | number[]} fc center frequency\n */\nexport function Flower(k: number, fc: number | number[]) {\n  return nums((f: number) => f / Math.pow(2, 1 / (2 * k)), fc) as typeof fc;\n}\n\n/**\n * @description Returns the upper band limit of a frequency band\n * @function Fupper\n * @param {number} k inverse fraction (i.e. third = 3, sixth = 6, etc.)\n * @param {number | number[]} fc center frequency\n */\nexport function Fupper(k: number, fc: number | number[]) {\n  return nums((f: number) => f * Math.pow(2, 1 / (2 * k)), fc) as typeof fc;\n}\n\n// const Bands = {\n//   Octave: {\n//     Nominal: whole_octave_all.map(x => x.Center),\n//     fromRange: (start: number, end: number): number[] => whole_octave_all.map(x => x.Center).filter(x => x >= Number(start) && x <= Number(end)),\n//     withLimits: whole_octave_all,\n//   },\n//   ThirdOctave: {\n//     Nominal: third_octave_all.map(x => x.Center),\n//     fromRange: (start: number, end: number): number[] => {\n//       return third_octave_all.map(x => x.Center).filter(x => x >= Number(start) && x <= Number(end));\n//     },\n//     withLimits: third_octave_all\n//   },\n//   Flower: (k, fc) => {\n//     if (typeof fc === \"number\")\n//       fc = [fc];\n//     return fc.map(f => f / Math.pow(2, 1 / (2 * k)));\n//   },\n//   Fupper: (k, fc) => {\n//     if (typeof fc === \"number\")\n//       fc = [fc];\n//     return fc.map(f => f * Math.pow(2, 1 / (2 * k)));\n//   }\n// };\n","type DecoderFunction = (buffer: ArrayBuffer, offset: number, output: number[][], channels: number, samples: number) => void;\ntype EncoderFunction = (buffer: ArrayBuffer, offset: number, input: number[][], channels: number, samples: number) => void;\n\nexport const data_decoders: Record<string, DecoderFunction> = {\n  pcm8: (\n    buffer: ArrayBuffer,\n    offset: number,\n    output: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++] - 128;\n        output[ch][i] = data < 0 ? data / 128 : data / 127;\n      }\n    }\n  },\n  pcm16: (\n    buffer: ArrayBuffer,\n    offset: number,\n    output: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let input = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 32768 : data / 32767;\n      }\n    }\n  },\n  pcm24: (\n    buffer: ArrayBuffer,\n    offset: number,\n    output: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let x0 = input[pos++];\n        let x1 = input[pos++];\n        let x2 = input[pos++];\n        let xx = x0 + (x1 << 8) + (x2 << 16);\n        let data = xx > 0x800000 ? xx - 0x1000000 : xx;\n        output[ch][i] = data < 0 ? data / 8388608 : data / 8388607;\n      }\n    }\n  },\n  pcm32: (\n    buffer: ArrayBuffer,\n    offset: number,\n    output: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let input = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 2147483648 : data / 2147483647;\n      }\n    }\n  },\n  pcm32f: (\n    buffer: ArrayBuffer,\n    offset: number,\n    output: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let input = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) output[ch][i] = input[pos++];\n    }\n  },\n  pcm64f: (\n    buffer: ArrayBuffer,\n    offset: number,\n    output: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let input = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) output[ch][i] = input[pos++];\n    }\n  },\n};\n\nexport const data_encoders: Record<string, EncoderFunction> = {\n  pcm8: (\n    buffer: ArrayBuffer,\n    offset: number,\n    input: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v * 0.5 + 0.5) * 255) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm16: (\n    buffer: ArrayBuffer,\n    offset: number,\n    input: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let output = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = (v < 0 ? v * 32768 : v * 32767) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm24: (\n    buffer: ArrayBuffer,\n    offset: number,\n    input: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = (v < 0 ? 0x1000000 + v * 8388608 : v * 8388607) | 0;\n        output[pos++] = (v >> 0) & 0xff;\n        output[pos++] = (v >> 8) & 0xff;\n        output[pos++] = (v >> 16) & 0xff;\n      }\n    }\n  },\n  pcm32: (\n    buffer: ArrayBuffer,\n    offset: number,\n    input: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let output = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = (v < 0 ? v * 2147483648 : v * 2147483647) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm32f: (\n    buffer: ArrayBuffer,\n    offset: number,\n    input: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let output = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm64f: (\n    buffer: ArrayBuffer,\n    offset: number,\n    input: number[][],\n    channels: number,\n    samples: number\n  ): void => {\n    let output = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        output[pos++] = v;\n      }\n    }\n  },\n};\n\nfunction lookupDecoder(bitDepth: number, floatingPoint: boolean): DecoderFunction {\n  const name = 'pcm' + bitDepth + (floatingPoint ? 'f' : '');\n  const fn = data_decoders[name];\n  if (!fn) throw new TypeError('Unsupported data format: ' + name);\n  return fn;\n}\n\nfunction lookupEncoder(bitDepth: number, floatingPoint: boolean): EncoderFunction {\n  const name = 'pcm' + bitDepth + (floatingPoint ? 'f' : '');\n  const fn = data_encoders[name];\n  if (!fn) throw new TypeError('Unsupported data format: ' + name);\n  return fn;\n}\n\ninterface DecodeResult {\n  sampleRate: number;\n  channelData: Float32Array[];\n}\n\nexport function decode(buffer: ArrayBuffer | { buffer: ArrayBuffer; byteOffset: number; length: number }): DecodeResult | undefined {\n  let pos = 0,\n    end = 0;\n  let arrayBuffer: ArrayBuffer;\n  if ('buffer' in buffer) {\n    // If we are handed a typed array or a buffer, then we have to consider the\n    // offset and length into the underlying array buffer.\n    pos = buffer.byteOffset;\n    end = buffer.length;\n    arrayBuffer = buffer.buffer;\n  } else {\n    // If we are handed a straight up array buffer, start at offset 0 and use\n    // the full length of the buffer.\n    pos = 0;\n    end = buffer.byteLength;\n    arrayBuffer = buffer;\n  }\n\n  const v = new DataView(arrayBuffer);\n\n  function u8() {\n    let x = v.getUint8(pos);\n    pos++;\n    return x;\n  }\n\n  function u16() {\n    let x = v.getUint16(pos, true);\n    pos += 2;\n    return x;\n  }\n\n  function u32() {\n    let x = v.getUint32(pos, true);\n    pos += 4;\n    return x;\n  }\n\n  function string(len: number) {\n    let str = '';\n    for (let i = 0; i < len; ++i) str += String.fromCharCode(u8());\n    return str;\n  }\n\n  if (string(4) !== 'RIFF') throw new TypeError('Invalid WAV file');\n  u32();\n  if (string(4) !== 'WAVE') throw new TypeError('Invalid WAV file');\n\n  let fmt;\n\n  while (pos < end) {\n    let type = string(4);\n    let size = u32();\n    let next = pos + size;\n    switch (type) {\n      case 'fmt ':\n        let formatId = u16();\n        if (formatId !== 0x0001 && formatId !== 0x0003)\n          throw new TypeError(\n            'Unsupported format in WAV file: ' + formatId.toString(16)\n          );\n        fmt = {\n          format: 'lpcm',\n          floatingPoint: formatId === 0x0003,\n          channels: u16(),\n          sampleRate: u32(),\n          byteRate: u32(),\n          blockSize: u16(),\n          bitDepth: u16(),\n        };\n        break;\n      case 'data':\n        if (!fmt) throw new TypeError('Missing \"fmt \" chunk.');\n        const samples = Math.floor(size / fmt.blockSize);\n        const channels = fmt.channels;\n        const sampleRate = fmt.sampleRate;\n        const channelData: Float32Array[] = [];\n        for (let ch = 0; ch < channels; ++ch)\n          channelData[ch] = new Float32Array(samples);\n        lookupDecoder(fmt.bitDepth, fmt.floatingPoint)(\n          arrayBuffer,\n          pos,\n          channelData as unknown as number[][],\n          channels,\n          samples\n        );\n        return {\n          sampleRate,\n          channelData,\n        };\n    }\n    pos = next;\n  }\n}\nexport interface encodeParams {\n  sampleRate: number;\n  floatingPoint?: boolean;\n  float?: boolean;\n  bitDepth: number;\n  channels: number;\n}\nexport function encode(channelData: number[][] | Float32Array[], opts: encodeParams): Uint8Array {\n  const sampleRate = opts.sampleRate || 48000;\n  const floatingPoint = Boolean(opts.float || opts.floatingPoint);\n  const bitDepth = floatingPoint ? 32 : opts.bitDepth | 0 || 16;\n  const channels = channelData.length;\n  const samples = channelData[0].length;\n  const buffer = new ArrayBuffer(44 + samples * channels * (bitDepth >> 3));\n\n  const v = new DataView(buffer);\n  let pos = 0;\n\n  function u8(x: number) {\n    v.setUint8(pos++, x);\n  }\n\n  function u16(x: number) {\n    v.setUint16(pos, x, true);\n    pos += 2;\n  }\n\n  function u32(x: number) {\n    v.setUint32(pos, x, true);\n    pos += 4;\n  }\n\n  function string(s: string) {\n    for (var i = 0; i < s.length; ++i) u8(s.charCodeAt(i));\n  }\n\n  // write header\n  string('RIFF');\n  u32(buffer.byteLength - 8);\n  string('WAVE');\n\n  // write 'fmt ' chunk\n  string('fmt ');\n  u32(16);\n  u16(floatingPoint ? 0x0003 : 0x0001);\n  u16(channels);\n  u32(sampleRate);\n  u32(sampleRate * channels * (bitDepth >> 3));\n  u16(channels * (bitDepth >> 3));\n  u16(bitDepth);\n\n  // write 'data' chunk\n  string('data');\n  u32(buffer.byteLength - 44);\n  lookupEncoder(bitDepth, floatingPoint)(\n    buffer,\n    pos,\n    channelData as number[][],\n    channels,\n    samples\n  );\n  \n  return new Uint8Array(buffer);\n}\n\nexport function wavAsBlob(data: Float32Array[], {sampleRate = 44100, bitDepth = 16 }: { sampleRate: number, bitDepth: number }): Blob {\n  const encoded = encode(data, {\n    channels: data.length,\n    sampleRate,\n    bitDepth\n  });\n  return new Blob([encoded.buffer as ArrayBuffer], {type: \"audio/wav\"});\n}\n","\nexport function normalize<T extends ArrayLike<number> & { [index: number]: number }>(arr: T): T {\n  let _max = Math.abs(arr[0]);\n  for (let i = 1; i < arr.length; i++){\n    if (Math.abs(arr[i]) > _max) {\n      _max = Math.abs(arr[i]);\n    }\n  }\n  if (_max !== 0) {\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = arr[i] / _max;\n    }\n  }\n  return arr;\n}\n","\n/**\n * utility function for more consise error handling\n * @param condition condition to test\n * @param message message to throw if failed\n */\n export function throwif(condition: boolean, message: string) {\n  if(!condition) throw Error(message);\n}\n","import { normalize, wavAsBlob } from '../compute/acoustics';\nimport {saveAs} from 'file-saver';\nimport {Flower, Fupper} from '../compute/acoustics';\nimport{throwif} from '../common/throwif';\n\n\ntype BiquadFilterType = \"bandpass\"|\"lowpass\"|\"highpass\"| \"lowshelf\"|\"highshelf\"|\"peaking\"|\"notch\"|\"allpass\";\n\nexport type FilteredSource = {\n  source: AudioBufferSourceNode;\n  lowpass: BiquadFilterNode;\n  highpass: BiquadFilterNode;\n  gain: GainNode;\n}\n\n//@ts-ignore\nconst AudioContext = (window.AudioContext || window.webkitAudioContext);\n//@ts-ignore\nconst OfflineAudioContext = (window.OfflineAudioContext || window.webkitOfflineAudioContext);\n\nexport class AudioEngine {\n  context: AudioContext\n  constructor(){\n    this.context = new AudioContext();\n  }\n\n  /**\n   * Creates an offline audio context for faster rendering\n   * @param numberOfChannels number of channels for this context\n   * @param length length of the context in samples\n   * @param sampleRate sample rate in samples / second\n   */\n  public createOfflineContext(numberOfChannels: number, length: number, sampleRate: number){\n    return new OfflineAudioContext(numberOfChannels, length, sampleRate);\n  }\n\n  /**\n   * Renders an offline audio context in a more browser agnostic way.\n   * neither Safari or Edge like `await context.startRendering()`\n   * @param context offline audio context\n   * @returns {Promise<AudioBuffer>} the rendered buffer\n   */\n  public async renderContextAsync(context: OfflineAudioContext): Promise<AudioBuffer> {\n    return new Promise((resolve, reject) => {\n      context.oncomplete = function(event: OfflineAudioCompletionEvent) {\n        if(!event.renderedBuffer){\n          reject(\"failed to get renderedBuffer after context completed rendering\");\n        } else {\n          resolve(event.renderedBuffer);\n        }\n      };\n      context.startRendering();\n    });\n  }\n\n  /**\n   * Creates a buffer source node filled with the supplied data\n   * @param buffer The buffer of samples in a Float32Array\n   * @param context audio context to use\n   * @returns the buffer source\n   */\n  public createBufferSource(buffer: Float32Array, context: AudioContext|OfflineAudioContext = this.context){\n    const source = context.createBufferSource();\n    source.buffer = context.createBuffer(1, buffer.length, this.context.sampleRate);\n    const sourceBuffer = source.buffer.getChannelData(0);\n    sourceBuffer.set(buffer, 0);\n    return source;\n  }\n\n  /**\n   * Creates a bandpass filter node\n   * @param freq center frequency\n   * @param Q Q-factor (reciprocal of the fractional bandwidth)\n   * @param context audio context to use\n   * @returns a bandpass filter\n   */\n  public createBandpassFilter(freq: number, Q: number = 1.414, context: AudioContext|OfflineAudioContext = this.context){\n    const filter = context.createBiquadFilter();\n    filter.type = \"bandpass\";\n    filter.Q.value = Q;\n    filter.frequency.value = freq;\n    return filter;\n  }\n\n  /**\n   * Creates a bandpass filter node\n   * @param freq center frequency\n   * @param Q Q-factor (reciprocal of the fractional bandwidth)\n   * @param context audio context to use\n   * @returns a bandpass filter\n   */\n  public createBiquadFilter(type: BiquadFilterType, freq: number, Q: number = 1.414, gain: number = 1, context: AudioContext|OfflineAudioContext = this.context){\n    const filter = context.createBiquadFilter();\n    filter.type = type;\n    filter.Q.value = Q;\n    filter.frequency.value = freq;\n    filter.gain.value = gain;\n    return filter;\n  }\n\n  /**\n   * Creates a gain node\n   * @param value the gain value\n   * @param context audio context to use\n   * @returns a gain node\n   */\n  public createGainNode(value: number, context: AudioContext|OfflineAudioContext = this.context){\n    const gain = context.createGain();\n    gain.gain.value = value;\n    return gain;\n  }\n\n  \n  /**\n   * Creates a channel merger node\n   * @param count number of input channels to merge\n   * @param context audio context to use\n   * @returns a channel merger node\n   */\n  public createMerger(count: number, context: AudioContext|OfflineAudioContext = this.context){\n    return context.createChannelMerger(count);\n  }\n\n  /**\n   * Creates a filtered source node \n   * @param buffer The buffer of samples in a Float32Array\n   * @param freq center frequency\n   * @param Q Q-factor (reciprocal of the fractional bandwidth)\n   * @param gain the gain value\n   * @param context audio context to use\n   * @returns a filtered source node\n   */\n  public createFilteredSource(buffer: Float32Array, freq: number, Q: number = 1.414, gain: number = 1, context: AudioContext|OfflineAudioContext = this.context){\n    const lower = Flower(1, freq) as number;\n    const upper = Fupper(1, freq) as number;\n    const filteredSource = {\n      source: this.createBufferSource(buffer, context),\n      lowpass: this.createBiquadFilter(\"lowpass\", upper, Q, 1, context),\n      highpass: this.createBiquadFilter(\"highpass\", lower, Q, 1, context),\n      gain: this.createGainNode(gain, context)\n    }\n    filteredSource.source.connect(filteredSource.lowpass);\n    filteredSource.lowpass.connect(filteredSource.highpass);\n    filteredSource.highpass.connect(filteredSource.gain);\n    // filteredSource.gain.connect(context.destination);\n    return filteredSource as FilteredSource;\n  }\n\n  /**\n   * Creates an array of filtered source nodes\n   * @param dataBuffers an array of sample buffers\n   * @param frequencies an array of frequencies\n   * @param context audio context to use\n   * @returns an array of filtered source nodes\n   */\n  public createFilteredSources(dataBuffers: Float32Array[], frequencies: number[], context: AudioContext|OfflineAudioContext = this.context) {\n    throwif(dataBuffers.length === frequencies.length, \"There should be exactly one frequency for each data buffer.\");\n    const sources = [] as FilteredSource[];\n\n    for(let i = 0; i < frequencies.length; i++){\n      sources.push(this.createFilteredSource(dataBuffers[i], frequencies[i], 0.707, 1, context));\n    }\n    return sources;\n  }\n\n  public diracDelta(length: number = 8192, offset: number = 0){\n    const samples = new Float32Array(Array(length).fill(0)); \n    samples[offset] = 1;\n    return samples;\n  }\n\n  async testFilters(frequencies: number[], sampleRate=44100) {\n\n    const samples = Array(frequencies.length).fill(0).map(x=>this.diracDelta());\n    const offlineContext = this.createOfflineContext(1, samples[0].length, sampleRate);\n    const sources = this.createFilteredSources(samples, frequencies, offlineContext);\n    const merger = this.createMerger(sources.length, offlineContext);\n    \n    for(let i = 0; i<sources.length; i++){\n      sources[i].gain.connect(merger, 0, i);\n    }\n\n    merger.connect(offlineContext.destination);\n    sources.forEach(source => source.source.start());\n    const impulseResponse = await this.renderContextAsync(offlineContext);\n    const blob = wavAsBlob([normalize(impulseResponse.getChannelData(0))], { sampleRate, bitDepth: 32 });\n    saveAs(blob, \"testFilters.wav\");\n\n    // this.impulseResponse = audioEngine.context.createBufferSource(); \n  }\n\n  public get sampleRate(){\n    return this.context.sampleRate;\n  }\n\n\n\n\n\n\n}\n\nexport const audioEngine = new AudioEngine();\n\n\n// function sig = filterit(order, lowfreq, highfreq)\n//   y=zeros(44100,1);\n//   y(1)=1;\n//   [b,a]=butter(order, [lowfreq/44100, highfreq/44100]);\n//   filtered=filter(b,a,y);\n//   sig = filtered;\n// end\n\n\n\n"],"names":["nums","f","v","x","Octave","start","end","whole_octave_all","Flower","k","fc","Fupper","data_encoders","buffer","offset","input","channels","samples","output","pos","i","ch","lookupEncoder","bitDepth","floatingPoint","name","fn","encode","channelData","opts","sampleRate","u8","u16","u32","string","s","wavAsBlob","data","encoded","normalize","arr","_max","throwif","condition","message","AudioContext","OfflineAudioContext","AudioEngine","numberOfChannels","length","context","resolve","reject","event","source","freq","Q","filter","type","gain","value","count","lower","upper","filteredSource","dataBuffers","frequencies","sources","offlineContext","merger","impulseResponse","blob","saveAs","audioEngine"],"mappings":"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"}