{"version":3,"file":"filter.worker-CKhUfGRZ.js","sources":["../src/audio-engine/filter.worker.ts"],"sourcesContent":["const ctx: Worker = self as any;\n\nexport {};\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function.\n */\nfunction transform(\n  real: Array<number> | Float32Array,\n  imag: Array<number> | Float32Array\n): void {\n  const n: number = real.length;\n  if (n != imag.length) throw 'Mismatched lengths';\n  if (n == 0) return;\n  else if ((n & (n - 1)) == 0)\n    // Is power of 2\n    transformRadix2(real, imag);\n  // More complicated algorithm for arbitrary sizes\n  else transformBluestein(real, imag);\n}\n\n/*\n * Computes the inverse discrete Fourier transform (IDFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function. This transform does not perform scaling, so the inverse is not a true inverse.\n */\nfunction inverseTransform(\n  real: Array<number> | Float32Array,\n  imag: Array<number> | Float32Array\n): void {\n  transform(imag, real);\n}\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector's length must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.\n */\nfunction transformRadix2(\n  real: Array<number> | Float32Array,\n  imag: Array<number> | Float32Array\n): void {\n  // Length variables\n  const n: number = real.length;\n  if (n != imag.length) throw 'Mismatched lengths';\n  if (n == 1)\n    // Trivial transform\n    return;\n  let levels: number = -1;\n  for (let i = 0; i < 32; i++) {\n    if (1 << i == n) levels = i; // Equal to log2(n)\n  }\n  if (levels == -1) throw 'Length is not a power of 2';\n\n  // Trigonometric tables\n  let cosTable = new Array<number>(n / 2);\n  let sinTable = new Array<number>(n / 2);\n  for (let i = 0; i < n / 2; i++) {\n    cosTable[i] = Math.cos((2 * Math.PI * i) / n);\n    sinTable[i] = Math.sin((2 * Math.PI * i) / n);\n  }\n\n  // Bit-reversed addressing permutation\n  for (let i = 0; i < n; i++) {\n    const j: number = reverseBits(i, levels);\n    if (j > i) {\n      let temp: number = real[i];\n      real[i] = real[j];\n      real[j] = temp;\n      temp = imag[i];\n      imag[i] = imag[j];\n      imag[j] = temp;\n    }\n  }\n\n  // Cooley-Tukey decimation-in-time radix-2 FFT\n  for (let size = 2; size <= n; size *= 2) {\n    const halfsize: number = size / 2;\n    const tablestep: number = n / size;\n    for (let i = 0; i < n; i += size) {\n      for (let j = i, k = 0; j < i + halfsize; j++, k += tablestep) {\n        const l: number = j + halfsize;\n        const tpre: number = real[l] * cosTable[k] + imag[l] * sinTable[k];\n        const tpim: number = -real[l] * sinTable[k] + imag[l] * cosTable[k];\n        real[l] = real[j] - tpre;\n        imag[l] = imag[j] - tpim;\n        real[j] += tpre;\n        imag[j] += tpim;\n      }\n    }\n  }\n\n  // Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.\n  function reverseBits(x: number, bits: number): number {\n    let y: number = 0;\n    for (let i = 0; i < bits; i++) {\n      y = (y << 1) | (x & 1);\n      x >>>= 1;\n    }\n    return y;\n  }\n}\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This requires the convolution function, which in turn requires the radix-2 FFT function.\n * Uses Bluestein's chirp z-transform algorithm.\n */\nfunction transformBluestein(\n  real: Array<number> | Float32Array,\n  imag: Array<number> | Float32Array\n): void {\n  // Find a power-of-2 convolution length m such that m >= n * 2 + 1\n  const n: number = real.length;\n  if (n != imag.length) throw 'Mismatched lengths';\n  let m: number = 1;\n  while (m < n * 2 + 1) m *= 2;\n\n  // Trignometric tables\n  let cosTable = new Array<number>(n);\n  let sinTable = new Array<number>(n);\n  for (let i = 0; i < n; i++) {\n    const j: number = (i * i) % (n * 2); // This is more accurate than j = i * i\n    cosTable[i] = Math.cos((Math.PI * j) / n);\n    sinTable[i] = Math.sin((Math.PI * j) / n);\n  }\n\n  // Temporary vectors and preprocessing\n  let areal: Array<number> = newArrayOfZeros(m);\n  let aimag: Array<number> = newArrayOfZeros(m);\n  for (let i = 0; i < n; i++) {\n    areal[i] = real[i] * cosTable[i] + imag[i] * sinTable[i];\n    aimag[i] = -real[i] * sinTable[i] + imag[i] * cosTable[i];\n  }\n  let breal: Array<number> = newArrayOfZeros(m);\n  let bimag: Array<number> = newArrayOfZeros(m);\n  breal[0] = cosTable[0];\n  bimag[0] = sinTable[0];\n  for (let i = 1; i < n; i++) {\n    breal[i] = breal[m - i] = cosTable[i];\n    bimag[i] = bimag[m - i] = sinTable[i];\n  }\n\n  // Convolution\n  let creal = new Array<number>(m);\n  let cimag = new Array<number>(m);\n  convolveComplex(areal, aimag, breal, bimag, creal, cimag);\n\n  // Postprocessing\n  for (let i = 0; i < n; i++) {\n    real[i] = creal[i] * cosTable[i] + cimag[i] * sinTable[i];\n    imag[i] = -creal[i] * sinTable[i] + cimag[i] * cosTable[i];\n  }\n}\n\n/*\n * Computes the circular convolution of the given real vectors. Each vector's length must be the same.\n */\nfunction convolveReal(\n  x: Array<number> | Float32Array,\n  y: Array<number> | Float32Array,\n  out: Array<number> | Float32Array\n): void {\n  const n: number = x.length;\n  if (n != y.length || n != out.length) throw 'Mismatched lengths';\n  convolveComplex(\n    x,\n    newArrayOfZeros(n),\n    y,\n    newArrayOfZeros(n),\n    out,\n    newArrayOfZeros(n)\n  );\n}\n\n/*\n * Computes the circular convolution of the given complex vectors. Each vector's length must be the same.\n */\nfunction convolveComplex(\n  xreal: Array<number> | Float32Array,\n  ximag: Array<number> | Float32Array,\n  yreal: Array<number> | Float32Array,\n  yimag: Array<number> | Float32Array,\n  outreal: Array<number> | Float32Array,\n  outimag: Array<number> | Float32Array\n): void {\n  const n: number = xreal.length;\n  if (\n    n != ximag.length ||\n    n != yreal.length ||\n    n != yimag.length ||\n    n != outreal.length ||\n    n != outimag.length\n  )\n    throw 'Mismatched lengths';\n\n  xreal = xreal.slice();\n  ximag = ximag.slice();\n  yreal = yreal.slice();\n  yimag = yimag.slice();\n  transform(xreal, ximag);\n  transform(yreal, yimag);\n\n  for (let i = 0; i < n; i++) {\n    const temp: number = xreal[i] * yreal[i] - ximag[i] * yimag[i];\n    ximag[i] = ximag[i] * yreal[i] + xreal[i] * yimag[i];\n    xreal[i] = temp;\n  }\n  inverseTransform(xreal, ximag);\n\n  for (let i = 0; i < n; i++) {\n    // Scaling (because this FFT implementation omits it)\n    outreal[i] = xreal[i] / n;\n    outimag[i] = ximag[i] / n;\n  }\n}\n\nfunction newArrayOfZeros(n: number): Array<number> {\n  let result: Array<number> = [];\n  for (let i = 0; i < n; i++) result.push(0);\n  return result;\n}\n\n\nfunction max_width_factor(r: [number, number], step: number) {\n\n    const base = Math.pow(Math.max(r[0], r[1]) / Math.min(r[0], r[1]), step);\n    return (base - 1) / (base + 1);\n}\n\nfunction width_factor(r: [number, number], bands: number, overlap: number) {\n    if (overlap < 0 || 1 < overlap) {\n        throw new Error(\"Overlap must be in the range 0-1.\");\n    }\n    return max_width_factor(r, 1.0 / bands) * overlap;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// p = relative frequency\n/// P = relative width\n/// l = steepness\n\nfunction band_edge_impl(p: number, P: number, l: number): number {\n    return l != 0 ? Math.sin(Math.PI * band_edge_impl(p, P, l - 1) / 2)\n                  : (((p / P) + 1) / 2);\n}\n\nfunction lower_band_edge(p: number, P: number, l: number) {\n    if (P < 0) {\n        throw new Error(\"P must be greater or equal to 0.\");\n    }\n    if (P == 0) {\n        return 0 <= p ? 1.0 : 0.0;\n    }\n    return Math.pow(Math.sin(Math.PI * band_edge_impl(p, P, l) / 2), 2.0);\n}\n\nfunction upper_band_edge(p: number, P: number, l: number) {\n    if (P < 0) {\n        throw new Error(\"P must be greater or equal to 0.\");\n    }\n    if (P == 0) {\n        return p < 0 ? 1.0 : 0.0;\n    }\n    return Math.pow(Math.cos(Math.PI * band_edge_impl(p, P, l) / 2), 2.0);\n}\n\nfunction band_edge_frequency(band: number, bands: number, r: [number, number]) {\n    const r0 = Math.min(r[0], r[1]);\n    const r1 = Math.max(r[0], r[1]);\n    return r0 * Math.pow(r1 / r0, band / bands);\n}\n\nfunction band_centre_frequency(band: number, bands: number, r: [number, number]) {\n    return band_edge_frequency(band * 2 + 1, bands * 2, r);\n}\n\nfunction compute_bandpass_magnitude(frequency: number,\n                                  r: [number, number],\n                                  width_factor: number,\n                                  l: number) {\n    if (width_factor < 0 || 1 < width_factor) {\n        throw new Error(\"Width_factor must be between 0 and 1.\");\n    }\n\n    return compute_lopass_magnitude(frequency, Math.max(r[0], r[1]), width_factor, l) *\n           compute_hipass_magnitude(frequency, Math.min(r[0], r[1]), width_factor, l);\n}\n\nfunction compute_lopass_magnitude(frequency: number,\n                                edge: number,\n                                width_factor: number,\n                                l: number) {\n    if (width_factor < 0 || 1 < width_factor) {\n        throw new Error(\"Width_factor must be between 0 and 1.\");\n    }\n\n    const absolute_width = edge * width_factor;\n    if (frequency < edge - absolute_width) {\n        return 1;\n    }\n    if (frequency < edge + absolute_width) {\n        return upper_band_edge(frequency - edge, absolute_width, l);\n    }\n    return 0;\n}\n\nfunction compute_hipass_magnitude(frequency: number,\n                                edge: number,\n                                width_factor: number,\n                                l: number) {\n    if (width_factor < 0 || 1 < width_factor) {\n        throw new Error(\"Width_factor must be between 0 and 1.\");\n    }\n\n    const absolute_width = edge * width_factor;\n    if (frequency < edge - absolute_width) {\n        return 0;\n    }\n    if (frequency < edge + absolute_width) {\n        return lower_band_edge(frequency - edge, absolute_width, l);\n    }\n    return 1;\n}\n\n\nfunction diracDelta(length: number = 8192, offset: number = 0){\n  const samples = new Float32Array(Array(length).fill(0)); \n  samples[offset] = 1;\n  return samples;\n}\n\nconst range = (n: number) => [...Array(n)].map((_,i)=>i);\n\n\n/**\n * Perfect reconstruction filter for banded signals\n * @param samples banded signals\n * @returns \n */\nfunction filterSignals(samples: Float32Array[]) {\n\n    const bands = samples.length;\n    const samplerate = 48000;\n    const minf = 63;\n    const maxf = 16000;\n    const band_edges = range(bands+1).map(band => band_edge_frequency(band, bands, [minf, maxf])) \n    const lower_edges = band_edges.slice(0,-1);\n    const upper_edges = band_edges.slice(1);\n    \n    const wf = width_factor([minf, maxf], bands, 1.0);\n    const frequencies = range(samples[0].length).map(x=>x*samplerate/samples[0].length) \n    const filters = [] as any[];\n    for(let i = 0; i<bands; i++){\n        const filter = frequencies.map(f=>compute_bandpass_magnitude(f, [lower_edges[i], upper_edges[i]], wf, 0));\n        const reflectedFilter = [\n            ...filter.slice(0,filter.length>>1), \n            ...filter.slice(0,Math.floor(filter.length/2)).reverse(),\n        ];\n        // filters.push(reflectedFilter)\n        filters.push(filter)\n    }\n\n    const filteredSamples = [] as any[];\n    for(let i = 0; i<samples.length; i++){\n        const real = new Float32Array(samples[i]);\n        const imag = newArrayOfZeros(samples[i].length)\n        transform(real, imag);\n\n        for(let j = 0; j<real.length; j++){\n            real[j]*=filters[i][j];\n            imag[j]*=filters[i][j];\n        }\n\n        inverseTransform(real, imag);\n        filteredSamples.push(real);\n    }\n\n    return filteredSamples;\n}\n\n\n\nctx.addEventListener(\"message\", (event) => {\n    const samples = event.data.samples as Float32Array[];\n    const filteredSamples = filterSignals(samples);\n    ctx.postMessage({ samples: filteredSamples });\n});"],"names":["ctx","transform","real","imag","n","transformRadix2","transformBluestein","inverseTransform","levels","i","cosTable","sinTable","j","reverseBits","temp","size","halfsize","tablestep","k","l","tpre","tpim","x","bits","y","m","areal","newArrayOfZeros","aimag","breal","bimag","creal","cimag","convolveComplex","xreal","ximag","yreal","yimag","outreal","outimag","result","max_width_factor","r","step","base","width_factor","bands","overlap","band_edge_impl","p","P","lower_band_edge","upper_band_edge","band_edge_frequency","band","r0","r1","compute_bandpass_magnitude","frequency","compute_lopass_magnitude","compute_hipass_magnitude","edge","absolute_width","range","_","filterSignals","samples","samplerate","minf","maxf","band_edges","lower_edges","upper_edges","wf","frequencies","filters","filter","f","filteredSamples","event"],"mappings":"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"}