{"version":3,"file":"audio-engine-BLz__Bcb.mjs","sources":["../src/compute/acoustics/util/nums.ts","../src/compute/acoustics/bands.ts","../src/compute/acoustics/util/wav.ts","../src/compute/acoustics/util/normalize.ts","../src/common/throwif.ts","../src/audio-engine/audio-engine.ts"],"sourcesContent":["export function nums(f: Function, v: number | number[]): number | number[] {\r\n  if (typeof v === 'number') {\r\n    return f(v);\r\n  } else {\r\n    return v.map(x => f(x));\r\n  }\r\n}\r\n","import { nums } from './util/nums';\r\n\r\nimport { third_octave_all, whole_octave_all } from './std/bands';\r\n\r\n/**\r\n * @description Returns the nominal octave band frequencies between a given range (inclusive)\r\n * @function Octave\r\n * @param {number} [start] start frequency\r\n * @param {number} [end] end frequency\r\n */\r\nexport function Octave(start: number, end: number): number[] {\r\n  return whole_octave_all\r\n    .map(x => x.Center)\r\n    .filter(x => x >= Number(start || 0) && x <= Number(end || 20000));\r\n}\r\n\r\n/**\r\n * @description Returns the nominal third octave band frequencies between a given range (inclusive)\r\n * @function ThirdOctave\r\n * @param {number} [start] start frequency\r\n * @param {number} [end] end frequency\r\n */\r\nexport function ThirdOctave(start?: number, end?: number): number[] {\r\n  return third_octave_all\r\n    .map(x => x.Center)\r\n    .filter(x => x >= Number(start || 0) && x <= Number(end || 22000));\r\n}\r\n\r\n/**\r\n * @description Returns the lower band limit of a frequency band\r\n * @function Flower\r\n * @param {number} k inverse fraction (i.e. third = 3, sixth = 6, etc.)\r\n * @param {number | number[]} fc center frequency\r\n */\r\nexport function Flower(k: number, fc: number | number[]) {\r\n  return nums((f: number) => f / Math.pow(2, 1 / (2 * k)), fc) as typeof fc;\r\n}\r\n\r\n/**\r\n * @description Returns the upper band limit of a frequency band\r\n * @function Fupper\r\n * @param {number} k inverse fraction (i.e. third = 3, sixth = 6, etc.)\r\n * @param {number | number[]} fc center frequency\r\n */\r\nexport function Fupper(k: number, fc: number | number[]) {\r\n  return nums((f: number) => f * Math.pow(2, 1 / (2 * k)), fc) as typeof fc;\r\n}\r\n\r\n// const Bands = {\r\n//   Octave: {\r\n//     Nominal: whole_octave_all.map(x => x.Center),\r\n//     fromRange: (start: number, end: number): number[] => whole_octave_all.map(x => x.Center).filter(x => x >= Number(start) && x <= Number(end)),\r\n//     withLimits: whole_octave_all,\r\n//   },\r\n//   ThirdOctave: {\r\n//     Nominal: third_octave_all.map(x => x.Center),\r\n//     fromRange: (start: number, end: number): number[] => {\r\n//       return third_octave_all.map(x => x.Center).filter(x => x >= Number(start) && x <= Number(end));\r\n//     },\r\n//     withLimits: third_octave_all\r\n//   },\r\n//   Flower: (k, fc) => {\r\n//     if (typeof fc === \"number\")\r\n//       fc = [fc];\r\n//     return fc.map(f => f / Math.pow(2, 1 / (2 * k)));\r\n//   },\r\n//   Fupper: (k, fc) => {\r\n//     if (typeof fc === \"number\")\r\n//       fc = [fc];\r\n//     return fc.map(f => f * Math.pow(2, 1 / (2 * k)));\r\n//   }\r\n// };\r\n","type DecoderFunction = (buffer: ArrayBuffer, offset: number, output: number[][], channels: number, samples: number) => void;\r\ntype EncoderFunction = (buffer: ArrayBuffer, offset: number, input: number[][], channels: number, samples: number) => void;\r\n\r\nexport const data_decoders: Record<string, DecoderFunction> = {\r\n  pcm8: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    output: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let input = new Uint8Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let data = input[pos++] - 128;\r\n        output[ch][i] = data < 0 ? data / 128 : data / 127;\r\n      }\r\n    }\r\n  },\r\n  pcm16: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    output: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let input = new Int16Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let data = input[pos++];\r\n        output[ch][i] = data < 0 ? data / 32768 : data / 32767;\r\n      }\r\n    }\r\n  },\r\n  pcm24: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    output: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let input = new Uint8Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let x0 = input[pos++];\r\n        let x1 = input[pos++];\r\n        let x2 = input[pos++];\r\n        let xx = x0 + (x1 << 8) + (x2 << 16);\r\n        let data = xx > 0x800000 ? xx - 0x1000000 : xx;\r\n        output[ch][i] = data < 0 ? data / 8388608 : data / 8388607;\r\n      }\r\n    }\r\n  },\r\n  pcm32: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    output: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let input = new Int32Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let data = input[pos++];\r\n        output[ch][i] = data < 0 ? data / 2147483648 : data / 2147483647;\r\n      }\r\n    }\r\n  },\r\n  pcm32f: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    output: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let input = new Float32Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) output[ch][i] = input[pos++];\r\n    }\r\n  },\r\n  pcm64f: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    output: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let input = new Float64Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) output[ch][i] = input[pos++];\r\n    }\r\n  },\r\n};\r\n\r\nexport const data_encoders: Record<string, EncoderFunction> = {\r\n  pcm8: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    input: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let output = new Uint8Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\r\n        v = ((v * 0.5 + 0.5) * 255) | 0;\r\n        output[pos++] = v;\r\n      }\r\n    }\r\n  },\r\n  pcm16: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    input: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let output = new Int16Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\r\n        v = (v < 0 ? v * 32768 : v * 32767) | 0;\r\n        output[pos++] = v;\r\n      }\r\n    }\r\n  },\r\n  pcm24: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    input: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let output = new Uint8Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\r\n        v = (v < 0 ? 0x1000000 + v * 8388608 : v * 8388607) | 0;\r\n        output[pos++] = (v >> 0) & 0xff;\r\n        output[pos++] = (v >> 8) & 0xff;\r\n        output[pos++] = (v >> 16) & 0xff;\r\n      }\r\n    }\r\n  },\r\n  pcm32: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    input: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let output = new Int32Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\r\n        v = (v < 0 ? v * 2147483648 : v * 2147483647) | 0;\r\n        output[pos++] = v;\r\n      }\r\n    }\r\n  },\r\n  pcm32f: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    input: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let output = new Float32Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\r\n        output[pos++] = v;\r\n      }\r\n    }\r\n  },\r\n  pcm64f: (\r\n    buffer: ArrayBuffer,\r\n    offset: number,\r\n    input: number[][],\r\n    channels: number,\r\n    samples: number\r\n  ): void => {\r\n    let output = new Float64Array(buffer, offset);\r\n    let pos = 0;\r\n    for (let i = 0; i < samples; ++i) {\r\n      for (let ch = 0; ch < channels; ++ch) {\r\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\r\n        output[pos++] = v;\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nfunction lookupDecoder(bitDepth: number, floatingPoint: boolean): DecoderFunction {\r\n  const name = 'pcm' + bitDepth + (floatingPoint ? 'f' : '');\r\n  const fn = data_decoders[name];\r\n  if (!fn) throw new TypeError('Unsupported data format: ' + name);\r\n  return fn;\r\n}\r\n\r\nfunction lookupEncoder(bitDepth: number, floatingPoint: boolean): EncoderFunction {\r\n  const name = 'pcm' + bitDepth + (floatingPoint ? 'f' : '');\r\n  const fn = data_encoders[name];\r\n  if (!fn) throw new TypeError('Unsupported data format: ' + name);\r\n  return fn;\r\n}\r\n\r\ninterface DecodeResult {\r\n  sampleRate: number;\r\n  channelData: Float32Array[];\r\n}\r\n\r\nexport function decode(buffer: ArrayBuffer | { buffer: ArrayBuffer; byteOffset: number; length: number }): DecodeResult | undefined {\r\n  let pos = 0,\r\n    end = 0;\r\n  let arrayBuffer: ArrayBuffer;\r\n  if ('buffer' in buffer) {\r\n    // If we are handed a typed array or a buffer, then we have to consider the\r\n    // offset and length into the underlying array buffer.\r\n    pos = buffer.byteOffset;\r\n    end = buffer.length;\r\n    arrayBuffer = buffer.buffer;\r\n  } else {\r\n    // If we are handed a straight up array buffer, start at offset 0 and use\r\n    // the full length of the buffer.\r\n    pos = 0;\r\n    end = buffer.byteLength;\r\n    arrayBuffer = buffer;\r\n  }\r\n\r\n  const v = new DataView(arrayBuffer);\r\n\r\n  function u8() {\r\n    let x = v.getUint8(pos);\r\n    pos++;\r\n    return x;\r\n  }\r\n\r\n  function u16() {\r\n    let x = v.getUint16(pos, true);\r\n    pos += 2;\r\n    return x;\r\n  }\r\n\r\n  function u32() {\r\n    let x = v.getUint32(pos, true);\r\n    pos += 4;\r\n    return x;\r\n  }\r\n\r\n  function string(len: number) {\r\n    let str = '';\r\n    for (let i = 0; i < len; ++i) str += String.fromCharCode(u8());\r\n    return str;\r\n  }\r\n\r\n  if (string(4) !== 'RIFF') throw new TypeError('Invalid WAV file');\r\n  u32();\r\n  if (string(4) !== 'WAVE') throw new TypeError('Invalid WAV file');\r\n\r\n  let fmt;\r\n\r\n  while (pos < end) {\r\n    let type = string(4);\r\n    let size = u32();\r\n    let next = pos + size;\r\n    switch (type) {\r\n      case 'fmt ':\r\n        let formatId = u16();\r\n        if (formatId !== 0x0001 && formatId !== 0x0003)\r\n          throw new TypeError(\r\n            'Unsupported format in WAV file: ' + formatId.toString(16)\r\n          );\r\n        fmt = {\r\n          format: 'lpcm',\r\n          floatingPoint: formatId === 0x0003,\r\n          channels: u16(),\r\n          sampleRate: u32(),\r\n          byteRate: u32(),\r\n          blockSize: u16(),\r\n          bitDepth: u16(),\r\n        };\r\n        break;\r\n      case 'data':\r\n        if (!fmt) throw new TypeError('Missing \"fmt \" chunk.');\r\n        const samples = Math.floor(size / fmt.blockSize);\r\n        const channels = fmt.channels;\r\n        const sampleRate = fmt.sampleRate;\r\n        const channelData: Float32Array[] = [];\r\n        for (let ch = 0; ch < channels; ++ch)\r\n          channelData[ch] = new Float32Array(samples);\r\n        lookupDecoder(fmt.bitDepth, fmt.floatingPoint)(\r\n          arrayBuffer,\r\n          pos,\r\n          channelData as unknown as number[][],\r\n          channels,\r\n          samples\r\n        );\r\n        return {\r\n          sampleRate,\r\n          channelData,\r\n        };\r\n    }\r\n    pos = next;\r\n  }\r\n}\r\nexport interface encodeParams {\r\n  sampleRate: number;\r\n  floatingPoint?: boolean;\r\n  float?: boolean;\r\n  bitDepth: number;\r\n  channels: number;\r\n}\r\nexport function encode(channelData: number[][] | Float32Array[], opts: encodeParams): Uint8Array {\r\n  const sampleRate = opts.sampleRate || 48000;\r\n  const floatingPoint = Boolean(opts.float || opts.floatingPoint);\r\n  const bitDepth = floatingPoint ? 32 : opts.bitDepth | 0 || 16;\r\n  const channels = channelData.length;\r\n  const samples = channelData[0].length;\r\n  const buffer = new ArrayBuffer(44 + samples * channels * (bitDepth >> 3));\r\n\r\n  const v = new DataView(buffer);\r\n  let pos = 0;\r\n\r\n  function u8(x: number) {\r\n    v.setUint8(pos++, x);\r\n  }\r\n\r\n  function u16(x: number) {\r\n    v.setUint16(pos, x, true);\r\n    pos += 2;\r\n  }\r\n\r\n  function u32(x: number) {\r\n    v.setUint32(pos, x, true);\r\n    pos += 4;\r\n  }\r\n\r\n  function string(s: string) {\r\n    for (var i = 0; i < s.length; ++i) u8(s.charCodeAt(i));\r\n  }\r\n\r\n  // write header\r\n  string('RIFF');\r\n  u32(buffer.byteLength - 8);\r\n  string('WAVE');\r\n\r\n  // write 'fmt ' chunk\r\n  string('fmt ');\r\n  u32(16);\r\n  u16(floatingPoint ? 0x0003 : 0x0001);\r\n  u16(channels);\r\n  u32(sampleRate);\r\n  u32(sampleRate * channels * (bitDepth >> 3));\r\n  u16(channels * (bitDepth >> 3));\r\n  u16(bitDepth);\r\n\r\n  // write 'data' chunk\r\n  string('data');\r\n  u32(buffer.byteLength - 44);\r\n  lookupEncoder(bitDepth, floatingPoint)(\r\n    buffer,\r\n    pos,\r\n    channelData as number[][],\r\n    channels,\r\n    samples\r\n  );\r\n  \r\n  return new Uint8Array(buffer);\r\n}\r\n\r\nexport function wavAsBlob(data: Float32Array[], {sampleRate = 44100, bitDepth = 16 }: { sampleRate: number, bitDepth: number }): Blob {\r\n  const encoded = encode(data, {\r\n    channels: data.length,\r\n    sampleRate,\r\n    bitDepth\r\n  });\r\n  return new Blob([encoded.buffer as ArrayBuffer], {type: \"audio/wav\"});\r\n}\r\n","\r\nexport function normalize<T extends ArrayLike<number> & { [index: number]: number }>(arr: T): T {\r\n  let _max = Math.abs(arr[0]);\r\n  for (let i = 1; i < arr.length; i++){\r\n    if (Math.abs(arr[i]) > _max) {\r\n      _max = Math.abs(arr[i]);\r\n    }\r\n  }\r\n  if (_max !== 0) {\r\n    for (let i = 0; i < arr.length; i++) {\r\n      arr[i] = arr[i] / _max;\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n","\r\n/**\r\n * utility function for more consise error handling\r\n * @param condition condition to test\r\n * @param message message to throw if failed\r\n */\r\n export function throwif(condition: boolean, message: string) {\r\n  if(!condition) throw Error(message);\r\n}\r\n","import { normalize, wavAsBlob } from '../compute/acoustics';\r\nimport {saveAs} from 'file-saver';\r\nimport {Flower, Fupper} from '../compute/acoustics';\r\nimport{throwif} from '../common/throwif';\r\n\r\n\r\ntype BiquadFilterType = \"bandpass\"|\"lowpass\"|\"highpass\"| \"lowshelf\"|\"highshelf\"|\"peaking\"|\"notch\"|\"allpass\";\r\n\r\nexport type FilteredSource = {\r\n  source: AudioBufferSourceNode;\r\n  lowpass: BiquadFilterNode;\r\n  highpass: BiquadFilterNode;\r\n  gain: GainNode;\r\n}\r\n\r\n//@ts-ignore\r\nconst AudioContext = (window.AudioContext || window.webkitAudioContext);\r\n//@ts-ignore\r\nconst OfflineAudioContext = (window.OfflineAudioContext || window.webkitOfflineAudioContext);\r\n\r\nexport class AudioEngine {\r\n  context: AudioContext\r\n  constructor(){\r\n    this.context = new AudioContext();\r\n  }\r\n\r\n  /**\r\n   * Creates an offline audio context for faster rendering\r\n   * @param numberOfChannels number of channels for this context\r\n   * @param length length of the context in samples\r\n   * @param sampleRate sample rate in samples / second\r\n   */\r\n  public createOfflineContext(numberOfChannels: number, length: number, sampleRate: number){\r\n    return new OfflineAudioContext(numberOfChannels, length, sampleRate);\r\n  }\r\n\r\n  /**\r\n   * Renders an offline audio context in a more browser agnostic way.\r\n   * neither Safari or Edge like `await context.startRendering()`\r\n   * @param context offline audio context\r\n   * @returns {Promise<AudioBuffer>} the rendered buffer\r\n   */\r\n  public async renderContextAsync(context: OfflineAudioContext): Promise<AudioBuffer> {\r\n    return new Promise((resolve, reject) => {\r\n      context.oncomplete = function(event: OfflineAudioCompletionEvent) {\r\n        if(!event.renderedBuffer){\r\n          reject(\"failed to get renderedBuffer after context completed rendering\");\r\n        } else {\r\n          resolve(event.renderedBuffer);\r\n        }\r\n      };\r\n      context.startRendering();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a buffer source node filled with the supplied data\r\n   * @param buffer The buffer of samples in a Float32Array\r\n   * @param context audio context to use\r\n   * @returns the buffer source\r\n   */\r\n  public createBufferSource(buffer: Float32Array, context: AudioContext|OfflineAudioContext = this.context){\r\n    const source = context.createBufferSource();\r\n    source.buffer = context.createBuffer(1, buffer.length, this.context.sampleRate);\r\n    const sourceBuffer = source.buffer.getChannelData(0);\r\n    sourceBuffer.set(buffer, 0);\r\n    return source;\r\n  }\r\n\r\n  /**\r\n   * Creates a bandpass filter node\r\n   * @param freq center frequency\r\n   * @param Q Q-factor (reciprocal of the fractional bandwidth)\r\n   * @param context audio context to use\r\n   * @returns a bandpass filter\r\n   */\r\n  public createBandpassFilter(freq: number, Q: number = 1.414, context: AudioContext|OfflineAudioContext = this.context){\r\n    const filter = context.createBiquadFilter();\r\n    filter.type = \"bandpass\";\r\n    filter.Q.value = Q;\r\n    filter.frequency.value = freq;\r\n    return filter;\r\n  }\r\n\r\n  /**\r\n   * Creates a bandpass filter node\r\n   * @param freq center frequency\r\n   * @param Q Q-factor (reciprocal of the fractional bandwidth)\r\n   * @param context audio context to use\r\n   * @returns a bandpass filter\r\n   */\r\n  public createBiquadFilter(type: BiquadFilterType, freq: number, Q: number = 1.414, gain: number = 1, context: AudioContext|OfflineAudioContext = this.context){\r\n    const filter = context.createBiquadFilter();\r\n    filter.type = type;\r\n    filter.Q.value = Q;\r\n    filter.frequency.value = freq;\r\n    filter.gain.value = gain;\r\n    return filter;\r\n  }\r\n\r\n  /**\r\n   * Creates a gain node\r\n   * @param value the gain value\r\n   * @param context audio context to use\r\n   * @returns a gain node\r\n   */\r\n  public createGainNode(value: number, context: AudioContext|OfflineAudioContext = this.context){\r\n    const gain = context.createGain();\r\n    gain.gain.value = value;\r\n    return gain;\r\n  }\r\n\r\n  \r\n  /**\r\n   * Creates a channel merger node\r\n   * @param count number of input channels to merge\r\n   * @param context audio context to use\r\n   * @returns a channel merger node\r\n   */\r\n  public createMerger(count: number, context: AudioContext|OfflineAudioContext = this.context){\r\n    return context.createChannelMerger(count);\r\n  }\r\n\r\n  /**\r\n   * Creates a filtered source node \r\n   * @param buffer The buffer of samples in a Float32Array\r\n   * @param freq center frequency\r\n   * @param Q Q-factor (reciprocal of the fractional bandwidth)\r\n   * @param gain the gain value\r\n   * @param context audio context to use\r\n   * @returns a filtered source node\r\n   */\r\n  public createFilteredSource(buffer: Float32Array, freq: number, Q: number = 1.414, gain: number = 1, context: AudioContext|OfflineAudioContext = this.context){\r\n    const lower = Flower(1, freq) as number;\r\n    const upper = Fupper(1, freq) as number;\r\n    const filteredSource = {\r\n      source: this.createBufferSource(buffer, context),\r\n      lowpass: this.createBiquadFilter(\"lowpass\", upper, Q, 1, context),\r\n      highpass: this.createBiquadFilter(\"highpass\", lower, Q, 1, context),\r\n      gain: this.createGainNode(gain, context)\r\n    }\r\n    filteredSource.source.connect(filteredSource.lowpass);\r\n    filteredSource.lowpass.connect(filteredSource.highpass);\r\n    filteredSource.highpass.connect(filteredSource.gain);\r\n    // filteredSource.gain.connect(context.destination);\r\n    return filteredSource as FilteredSource;\r\n  }\r\n\r\n  /**\r\n   * Creates an array of filtered source nodes\r\n   * @param dataBuffers an array of sample buffers\r\n   * @param frequencies an array of frequencies\r\n   * @param context audio context to use\r\n   * @returns an array of filtered source nodes\r\n   */\r\n  public createFilteredSources(dataBuffers: Float32Array[], frequencies: number[], context: AudioContext|OfflineAudioContext = this.context) {\r\n    throwif(dataBuffers.length === frequencies.length, \"There should be exactly one frequency for each data buffer.\");\r\n    const sources = [] as FilteredSource[];\r\n\r\n    for(let i = 0; i < frequencies.length; i++){\r\n      sources.push(this.createFilteredSource(dataBuffers[i], frequencies[i], 0.707, 1, context));\r\n    }\r\n    return sources;\r\n  }\r\n\r\n  public diracDelta(length: number = 8192, offset: number = 0){\r\n    const samples = new Float32Array(Array(length).fill(0)); \r\n    samples[offset] = 1;\r\n    return samples;\r\n  }\r\n\r\n  async testFilters(frequencies: number[], sampleRate=44100) {\r\n\r\n    const samples = Array(frequencies.length).fill(0).map(x=>this.diracDelta());\r\n    const offlineContext = this.createOfflineContext(1, samples[0].length, sampleRate);\r\n    const sources = this.createFilteredSources(samples, frequencies, offlineContext);\r\n    const merger = this.createMerger(sources.length, offlineContext);\r\n    \r\n    for(let i = 0; i<sources.length; i++){\r\n      sources[i].gain.connect(merger, 0, i);\r\n    }\r\n\r\n    merger.connect(offlineContext.destination);\r\n    sources.forEach(source => source.source.start());\r\n    const impulseResponse = await this.renderContextAsync(offlineContext);\r\n    const blob = wavAsBlob([normalize(impulseResponse.getChannelData(0))], { sampleRate, bitDepth: 32 });\r\n    saveAs(blob, \"testFilters.wav\");\r\n\r\n    // this.impulseResponse = audioEngine.context.createBufferSource(); \r\n  }\r\n\r\n  public get sampleRate(){\r\n    return this.context.sampleRate;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\nexport const audioEngine = new AudioEngine();\r\n\r\n\r\n// function sig = filterit(order, lowfreq, highfreq)\r\n//   y=zeros(44100,1);\r\n//   y(1)=1;\r\n//   [b,a]=butter(order, [lowfreq/44100, highfreq/44100]);\r\n//   filtered=filter(b,a,y);\r\n//   sig = filtered;\r\n// end\r\n\r\n\r\n\r\n"],"names":["nums","f","v","x","Octave","start","end","whole_octave_all","Flower","k","fc","Fupper","data_encoders","buffer","offset","input","channels","samples","output","pos","i","ch","lookupEncoder","bitDepth","floatingPoint","name","fn","encode","channelData","opts","sampleRate","u8","u16","u32","string","s","wavAsBlob","data","encoded","normalize","arr","_max","throwif","condition","message","AudioContext","OfflineAudioContext","AudioEngine","numberOfChannels","length","context","resolve","reject","event","source","freq","Q","filter","type","gain","value","count","lower","upper","filteredSource","dataBuffers","frequencies","sources","offlineContext","merger","impulseResponse","blob","saveAs","audioEngine"],"mappings":";AAAO,SAASA,EAAKC,GAAaC,GAAyC;AACzE,SAAI,OAAOA,KAAM,WACRD,EAAEC,CAAC,IAEHA,EAAE,IAAI,CAAAC,MAAKF,EAAEE,CAAC,CAAC;AAE1B;ACIO,SAASC,EAAOC,GAAeC,GAAuB;AAC3D,SAAOC,EACJ,IAAI,CAAAJ,MAAKA,EAAE,MAAM,EACjB,OAAO,CAAAA,MAAKA,KAAK,OAAOE,KAAS,CAAC,KAAKF,KAAK,OAAOG,KAAO,GAAK,CAAC;AACrE;AAoBO,SAASE,EAAOC,GAAWC,GAAuB;AACvD,SAAOV,EAAK,CAACC,MAAcA,IAAI,KAAK,IAAI,GAAG,KAAK,IAAIQ,EAAE,GAAGC,CAAE;AAC7D;AAQO,SAASC,EAAOF,GAAWC,GAAuB;AACvD,SAAOV,EAAK,CAACC,MAAcA,IAAI,KAAK,IAAI,GAAG,KAAK,IAAIQ,EAAE,GAAGC,CAAE;AAC7D;ACsDO,MAAME,IAAiD;AAAA,EAC5D,MAAM,CACJC,GACAC,GACAC,GACAC,GACAC,MACS;AACT,QAAIC,IAAS,IAAI,WAAWL,GAAQC,CAAM,GACtCK,IAAM;AACV,aAASC,IAAI,GAAGA,IAAIH,GAAS,EAAEG;AAC7B,eAASC,IAAK,GAAGA,IAAKL,GAAU,EAAEK,GAAI;AACpC,YAAInB,IAAI,KAAK,IAAI,IAAI,KAAK,IAAIa,EAAMM,CAAE,EAAED,CAAC,GAAG,CAAC,CAAC;AAC9C,QAAAlB,KAAMA,IAAI,MAAM,OAAO,MAAO,GAC9BgB,EAAOC,GAAK,IAAIjB;AAAA,MAClB;AAAA,EAEJ;AAAA,EACA,OAAO,CACLW,GACAC,GACAC,GACAC,GACAC,MACS;AACT,QAAIC,IAAS,IAAI,WAAWL,GAAQC,CAAM,GACtCK,IAAM;AACV,aAASC,IAAI,GAAGA,IAAIH,GAAS,EAAEG;AAC7B,eAASC,IAAK,GAAGA,IAAKL,GAAU,EAAEK,GAAI;AACpC,YAAInB,IAAI,KAAK,IAAI,IAAI,KAAK,IAAIa,EAAMM,CAAE,EAAED,CAAC,GAAG,CAAC,CAAC;AAC9C,QAAAlB,KAAKA,IAAI,IAAIA,IAAI,QAAQA,IAAI,SAAS,GACtCgB,EAAOC,GAAK,IAAIjB;AAAA,MAClB;AAAA,EAEJ;AAAA,EACA,OAAO,CACLW,GACAC,GACAC,GACAC,GACAC,MACS;AACT,QAAIC,IAAS,IAAI,WAAWL,GAAQC,CAAM,GACtCK,IAAM;AACV,aAASC,IAAI,GAAGA,IAAIH,GAAS,EAAEG;AAC7B,eAASC,IAAK,GAAGA,IAAKL,GAAU,EAAEK,GAAI;AACpC,YAAInB,IAAI,KAAK,IAAI,IAAI,KAAK,IAAIa,EAAMM,CAAE,EAAED,CAAC,GAAG,CAAC,CAAC;AAC9C,QAAAlB,KAAKA,IAAI,IAAI,WAAYA,IAAI,UAAUA,IAAI,WAAW,GACtDgB,EAAOC,GAAK,IAAKjB,KAAK,IAAK,KAC3BgB,EAAOC,GAAK,IAAKjB,KAAK,IAAK,KAC3BgB,EAAOC,GAAK,IAAKjB,KAAK,KAAM;AAAA,MAC9B;AAAA,EAEJ;AAAA,EACA,OAAO,CACLW,GACAC,GACAC,GACAC,GACAC,MACS;AACT,QAAIC,IAAS,IAAI,WAAWL,GAAQC,CAAM,GACtCK,IAAM;AACV,aAASC,IAAI,GAAGA,IAAIH,GAAS,EAAEG;AAC7B,eAASC,IAAK,GAAGA,IAAKL,GAAU,EAAEK,GAAI;AACpC,YAAInB,IAAI,KAAK,IAAI,IAAI,KAAK,IAAIa,EAAMM,CAAE,EAAED,CAAC,GAAG,CAAC,CAAC;AAC9C,QAAAlB,KAAKA,IAAI,IAAIA,IAAI,aAAaA,IAAI,cAAc,GAChDgB,EAAOC,GAAK,IAAIjB;AAAA,MAClB;AAAA,EAEJ;AAAA,EACA,QAAQ,CACNW,GACAC,GACAC,GACAC,GACAC,MACS;AACT,QAAIC,IAAS,IAAI,aAAaL,GAAQC,CAAM,GACxCK,IAAM;AACV,aAASC,IAAI,GAAGA,IAAIH,GAAS,EAAEG;AAC7B,eAASC,IAAK,GAAGA,IAAKL,GAAU,EAAEK,GAAI;AACpC,YAAInB,IAAI,KAAK,IAAI,IAAI,KAAK,IAAIa,EAAMM,CAAE,EAAED,CAAC,GAAG,CAAC,CAAC;AAC9C,QAAAF,EAAOC,GAAK,IAAIjB;AAAA,MAClB;AAAA,EAEJ;AAAA,EACA,QAAQ,CACNW,GACAC,GACAC,GACAC,GACAC,MACS;AACT,QAAIC,IAAS,IAAI,aAAaL,GAAQC,CAAM,GACxCK,IAAM;AACV,aAASC,IAAI,GAAGA,IAAIH,GAAS,EAAEG;AAC7B,eAASC,IAAK,GAAGA,IAAKL,GAAU,EAAEK,GAAI;AACpC,YAAInB,IAAI,KAAK,IAAI,IAAI,KAAK,IAAIa,EAAMM,CAAE,EAAED,CAAC,GAAG,CAAC,CAAC;AAC9C,QAAAF,EAAOC,GAAK,IAAIjB;AAAA,MAClB;AAAA,EAEJ;AACF;AASA,SAASoB,EAAcC,GAAkBC,GAAyC;AAChF,QAAMC,IAAO,QAAQF,KAAYC,IAAgB,MAAM,KACjDE,IAAKd,EAAca,CAAI;AAC7B,MAAI,CAACC,EAAI,OAAM,IAAI,UAAU,8BAA8BD,CAAI;AAC/D,SAAOC;AACT;AA4GO,SAASC,EAAOC,GAA0CC,GAAgC;AAC/F,QAAMC,IAAaD,EAAK,cAAc,MAChCL,IAAgB,GAAQK,EAAK,SAASA,EAAK,gBAC3CN,IAAWC,IAAgB,KAAKK,EAAK,WAAW,KAAK,IACrDb,IAAWY,EAAY,QACvBX,IAAUW,EAAY,CAAC,EAAE,QACzBf,IAAS,IAAI,YAAY,KAAKI,IAAUD,KAAYO,KAAY,EAAE,GAElErB,IAAI,IAAI,SAASW,CAAM;AAC7B,MAAIM,IAAM;AAEV,WAASY,EAAG5B,GAAW;AACrB,IAAAD,EAAE,SAASiB,KAAOhB,CAAC;AAAA,EACrB;AAEA,WAAS6B,EAAI7B,GAAW;AACtB,IAAAD,EAAE,UAAUiB,GAAKhB,GAAG,EAAI,GACxBgB,KAAO;AAAA,EACT;AAEA,WAASc,EAAI9B,GAAW;AACtB,IAAAD,EAAE,UAAUiB,GAAKhB,GAAG,EAAI,GACxBgB,KAAO;AAAA,EACT;AAEA,WAASe,EAAOC,GAAW;AACzB,aAASf,IAAI,GAAGA,IAAIe,EAAE,QAAQ,EAAEf,EAAG,CAAAW,EAAGI,EAAE,WAAWf,CAAC,CAAC;AAAA,EACvD;AAGA,SAAAc,EAAO,MAAM,GACbD,EAAIpB,EAAO,aAAa,CAAC,GACzBqB,EAAO,MAAM,GAGbA,EAAO,MAAM,GACbD,EAAI,EAAE,GACND,EAAIR,IAAgB,IAAS,CAAM,GACnCQ,EAAIhB,CAAQ,GACZiB,EAAIH,CAAU,GACdG,EAAIH,IAAad,KAAYO,KAAY,EAAE,GAC3CS,EAAIhB,KAAYO,KAAY,EAAE,GAC9BS,EAAIT,CAAQ,GAGZW,EAAO,MAAM,GACbD,EAAIpB,EAAO,aAAa,EAAE,GAC1BS,EAAcC,GAAUC,CAAa;AAAA,IACnCX;AAAA,IACAM;AAAA,IACAS;AAAA,IACAZ;AAAA,IACAC;AAAA,EAAA,GAGK,IAAI,WAAWJ,CAAM;AAC9B;AAEO,SAASuB,EAAUC,GAAsB,EAAC,YAAAP,IAAa,OAAO,UAAAP,IAAW,MAAsD;AACpI,QAAMe,IAAUX,EAAOU,GAAM;AAAA,IAC3B,UAAUA,EAAK;AAAA,IACf,YAAAP;AAAA,IACA,UAAAP;AAAA,EAAA,CACD;AACD,SAAO,IAAI,KAAK,CAACe,EAAQ,MAAqB,GAAG,EAAC,MAAM,aAAY;AACtE;ACrYO,SAASC,EAAqEC,GAAW;AAC9F,MAAIC,IAAO,KAAK,IAAID,EAAI,CAAC,CAAC;AAC1B,WAASpB,IAAI,GAAGA,IAAIoB,EAAI,QAAQpB;AAC9B,IAAI,KAAK,IAAIoB,EAAIpB,CAAC,CAAC,IAAIqB,MACrBA,IAAO,KAAK,IAAID,EAAIpB,CAAC,CAAC;AAG1B,MAAIqB,MAAS;AACX,aAASrB,IAAI,GAAGA,IAAIoB,EAAI,QAAQpB;AAC9B,MAAAoB,EAAIpB,CAAC,IAAIoB,EAAIpB,CAAC,IAAIqB;AAGtB,SAAOD;AACT;ACRQ,SAASE,EAAQC,GAAoBC,GAAiB;AAC5D,MAAG,CAACD,EAAW,OAAM,MAAMC,CAAO;AACpC;ACQA,MAAMC,IAAgB,OAAO,gBAAgB,OAAO,oBAE9CC,IAAuB,OAAO,uBAAuB,OAAO;AAE3D,MAAMC,EAAY;AAAA,EACvB;AAAA,EACA,cAAa;AACX,SAAK,UAAU,IAAIF,EAAA;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,qBAAqBG,GAA0BC,GAAgBnB,GAAmB;AACvF,WAAO,IAAIgB,EAAoBE,GAAkBC,GAAQnB,CAAU;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,mBAAmBoB,GAAoD;AAClF,WAAO,IAAI,QAAQ,CAACC,GAASC,MAAW;AACtC,MAAAF,EAAQ,aAAa,SAASG,GAAoC;AAChE,QAAIA,EAAM,iBAGRF,EAAQE,EAAM,cAAc,IAF5BD,EAAO,gEAAgE;AAAA,MAI3E,GACAF,EAAQ,eAAA;AAAA,IACV,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,mBAAmBrC,GAAsBqC,IAA4C,KAAK,SAAQ;AACvG,UAAMI,IAASJ,EAAQ,mBAAA;AACvB,WAAAI,EAAO,SAASJ,EAAQ,aAAa,GAAGrC,EAAO,QAAQ,KAAK,QAAQ,UAAU,GACzDyC,EAAO,OAAO,eAAe,CAAC,EACtC,IAAIzC,GAAQ,CAAC,GACnByC;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,qBAAqBC,GAAcC,IAAY,OAAON,IAA4C,KAAK,SAAQ;AACpH,UAAMO,IAASP,EAAQ,mBAAA;AACvB,WAAAO,EAAO,OAAO,YACdA,EAAO,EAAE,QAAQD,GACjBC,EAAO,UAAU,QAAQF,GAClBE;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,mBAAmBC,GAAwBH,GAAcC,IAAY,OAAOG,IAAe,GAAGT,IAA4C,KAAK,SAAQ;AAC5J,UAAMO,IAASP,EAAQ,mBAAA;AACvB,WAAAO,EAAO,OAAOC,GACdD,EAAO,EAAE,QAAQD,GACjBC,EAAO,UAAU,QAAQF,GACzBE,EAAO,KAAK,QAAQE,GACbF;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,eAAeG,GAAeV,IAA4C,KAAK,SAAQ;AAC5F,UAAMS,IAAOT,EAAQ,WAAA;AACrB,WAAAS,EAAK,KAAK,QAAQC,GACXD;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,aAAaE,GAAeX,IAA4C,KAAK,SAAQ;AAC1F,WAAOA,EAAQ,oBAAoBW,CAAK;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWO,qBAAqBhD,GAAsB0C,GAAcC,IAAY,OAAOG,IAAe,GAAGT,IAA4C,KAAK,SAAQ;AAC5J,UAAMY,IAAQtD,EAAO,GAAG+C,CAAI,GACtBQ,IAAQpD,EAAO,GAAG4C,CAAI,GACtBS,IAAiB;AAAA,MACrB,QAAQ,KAAK,mBAAmBnD,GAAQqC,CAAO;AAAA,MAC/C,SAAS,KAAK,mBAAmB,WAAWa,GAAOP,GAAG,GAAGN,CAAO;AAAA,MAChE,UAAU,KAAK,mBAAmB,YAAYY,GAAON,GAAG,GAAGN,CAAO;AAAA,MAClE,MAAM,KAAK,eAAeS,GAAMT,CAAO;AAAA,IAAA;AAEzC,WAAAc,EAAe,OAAO,QAAQA,EAAe,OAAO,GACpDA,EAAe,QAAQ,QAAQA,EAAe,QAAQ,GACtDA,EAAe,SAAS,QAAQA,EAAe,IAAI,GAE5CA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,sBAAsBC,GAA6BC,GAAuBhB,IAA4C,KAAK,SAAS;AACzI,IAAAR,EAAQuB,EAAY,WAAWC,EAAY,QAAQ,6DAA6D;AAChH,UAAMC,IAAU,CAAA;AAEhB,aAAQ/C,IAAI,GAAGA,IAAI8C,EAAY,QAAQ9C;AACrC,MAAA+C,EAAQ,KAAK,KAAK,qBAAqBF,EAAY7C,CAAC,GAAG8C,EAAY9C,CAAC,GAAG,OAAO,GAAG8B,CAAO,CAAC;AAE3F,WAAOiB;AAAA,EACT;AAAA,EAEO,WAAWlB,IAAiB,MAAMnC,IAAiB,GAAE;AAC1D,UAAMG,IAAU,IAAI,aAAa,MAAMgC,CAAM,EAAE,KAAK,CAAC,CAAC;AACtD,WAAAhC,EAAQH,CAAM,IAAI,GACXG;AAAA,EACT;AAAA,EAEA,MAAM,YAAYiD,GAAuBpC,IAAW,OAAO;AAEzD,UAAMb,IAAU,MAAMiD,EAAY,MAAM,EAAE,KAAK,CAAC,EAAE,IAAI,CAAA/D,MAAG,KAAK,WAAA,CAAY,GACpEiE,IAAiB,KAAK,qBAAqB,GAAGnD,EAAQ,CAAC,EAAE,QAAQa,CAAU,GAC3EqC,IAAU,KAAK,sBAAsBlD,GAASiD,GAAaE,CAAc,GACzEC,IAAS,KAAK,aAAaF,EAAQ,QAAQC,CAAc;AAE/D,aAAQhD,IAAI,GAAGA,IAAE+C,EAAQ,QAAQ/C;AAC/B,MAAA+C,EAAQ/C,CAAC,EAAE,KAAK,QAAQiD,GAAQ,GAAGjD,CAAC;AAGtC,IAAAiD,EAAO,QAAQD,EAAe,WAAW,GACzCD,EAAQ,QAAQ,CAAAb,MAAUA,EAAO,OAAO,OAAO;AAC/C,UAAMgB,IAAkB,MAAM,KAAK,mBAAmBF,CAAc,GAC9DG,IAAOnC,EAAU,CAACG,EAAU+B,EAAgB,eAAe,CAAC,CAAC,CAAC,GAAG,EAAE,YAAAxC,GAAY,UAAU,IAAI;AACnG0C,IAAAA,EAAAA,OAAOD,GAAM,iBAAiB;AAAA,EAGhC;AAAA,EAEA,IAAW,aAAY;AACrB,WAAO,KAAK,QAAQ;AAAA,EACtB;AAOF;AAEO,MAAME,IAAc,IAAI1B,EAAA;"}