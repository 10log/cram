import { create } from 'zustand';
import { produce } from 'immer';
import { useShallow } from 'zustand/react/shallow';
import { KeyValuePair } from "../common/key-value-pair";
import { emit, on } from '../messenger';
import { omit } from "../common/helpers";
import useAppStore from "./app-store";
// import { ChartDataSets } from 'chart.js';


export enum ResultKind {
  LevelTimeProgression = "linear-time-progression",
  Default = "default",
  StatisticalRT60 = "statisticalRT60",
  ImpulseResponse = "impulseResponse"
}


export interface ResultTypes {
  [ResultKind.Default]: {
    info: {};
    data: number[];
  };
  [ResultKind.LevelTimeProgression]: {
    info: {
      initialSPL: number[];
      frequency: number[];
      maxOrder: number;
    };
    data: { 
      time: number, 
      pressure: number[], 
      order: number, 
      arrival: number 
      uuid: string
    }[];
  }
  [ResultKind.StatisticalRT60]: {
    info: {
      frequency: number[];
      airabsorption: boolean;
      humidity: number;
      temperature: number;
    };
    data: {
      sabine: number;
      eyring: number;
      ap: number;
      frequency: number;
    }[];
  }
  [ResultKind.ImpulseResponse]: {
    info: {
      sampleRate: number;
      sourceName: string;
      receiverName: string;
      sourceId?: string;
      receiverId?: string;
    };
    data: {
      time: number;
      amplitude: number;
    }[];
  }
}

export interface Result<Kind extends ResultKind> {
  kind: Kind;
  info: ResultTypes[Kind]["info"];
  data: ResultTypes[Kind]["data"];
  name: string;
  uuid: string;
  /**
   * The UUID of the solver that generated this result.
   * Used to link results back to their originating solver for display in solver cards.
   */
  from: string;
}



export type ResultStore = {
  results: KeyValuePair<Result<ResultKind>>;
  openTabIndex: number;
  set: SetFunction<ResultStore>;
}

export const useResult = create<ResultStore>((set)=>({
  results: {},
  openTabIndex: 0,
  set: (fn) => set(produce(fn))
}));

export const getResultKeys = () => Object.keys(useResult.getState().results);

/**
 * Hook to get all results generated by a specific solver.
 * Uses useShallow to prevent infinite re-render loops when the filtered array changes.
 * @param solverUuid - The UUID of the solver
 * @returns Array of results linked to the solver
 */
export const useResultsForSolver = (solverUuid: string): Result<ResultKind>[] => {
  return useResult(
    useShallow((state) =>
      Object.values(state.results).filter((result) => result.from === solverUuid)
    )
  );
};

export interface ResultEvent<Kind extends ResultKind> {
  uuid: string;
  item: ResultTypes[Kind]["data"]
}

declare global {
  interface EventTypes {
    ADD_RESULT: Result<ResultKind>;
    UPDATE_RESULT: { uuid: string, result: Result<ResultKind> };
    REMOVE_RESULT: string;
    RESULT_DATA_CLICKED: ResultEvent<ResultKind>
  }
}

on("ADD_RESULT", (result) => {
  useResult.getState().set((store) => void (store.results[result.uuid] = result));
  if(!useAppStore.getState().resultsPanelOpen) emit("TOGGLE_RESULTS_PANEL", true);
});

on("UPDATE_RESULT", ({ result }) => {
  useResult.getState().set((store) => void (store.results[result.uuid] = result));
  // Don't force-open the panel on updates - only on new results via ADD_RESULT
  // This prevents auto-calculate from disrupting the user's current view
});

on("REMOVE_RESULT", (uuid) => {
  useResult.getState().set((store) => {
    store.results = omit([uuid], store.results)
  });
});

// Update result names when source/receiver names change
const updateResultNamesForContainer = (containerId: string, newName: string, containerType: 'source' | 'receiver') => {
  useResult.getState().set((store) => {
    Object.values(store.results).forEach((result) => {
      if (result.kind === ResultKind.ImpulseResponse) {
        const info = result.info as ResultTypes[ResultKind.ImpulseResponse]["info"];
        if (containerType === 'source' && info.sourceId === containerId) {
          info.sourceName = newName;
          result.name = `IR: ${newName} → ${info.receiverName}`;
        } else if (containerType === 'receiver' && info.receiverId === containerId) {
          info.receiverName = newName;
          result.name = `IR: ${info.sourceName} → ${newName}`;
        }
      }
    });
  });
};

on("SOURCE_SET_PROPERTY", (payload: { uuid: string; property: string; value: any }) => {
  if (payload.property === 'name') {
    updateResultNamesForContainer(payload.uuid, payload.value, 'source');
  }
});

on("RECEIVER_SET_PROPERTY", (payload: { uuid: string; property: string; value: any }) => {
  if (payload.property === 'name') {
    updateResultNamesForContainer(payload.uuid, payload.value, 'receiver');
  }
});

/**
 * Reset the result store to its initial state.
 */
export const resetResultStore = () => {
  // Partial update to preserve methods
  useResult.setState({
    results: {},
    openTabIndex: 0,
  });

  console.log('[ResultStore] Reset complete');
};

