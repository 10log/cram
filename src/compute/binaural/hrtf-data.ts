/**
 * HRTF data loading and caching module.
 *
 * Loads pre-computed ambisonic decoder FIR filters and subject metadata
 * from the public/hrtf/ directory (generated by scripts/preprocess-sadie-hrtf.py).
 */

export interface HRTFSubject {
  id: string;
  name: string;
  description: string;
  maxOrder: number;
  sampleRate: number;
  filterLength: number;
  thumbnailLeft: string;
  thumbnailRight: string;
}

export interface HRTFManifest {
  version: number;
  dataset: string;
  subjects: HRTFSubject[];
}

export interface HRTFDecoderFilters {
  sampleRate: number;
  filterLength: number;
  channelCount: number;
  filtersLeft: Float32Array[];
  filtersRight: Float32Array[];
}

// Cache
let cachedManifest: HRTFManifest | null = null;
const filterCache = new Map<string, HRTFDecoderFilters>();

const HRTF_BASE_PATH = `${process.env.PUBLIC_URL || ""}/hrtf`;

/**
 * Fetch and cache the HRTF manifest containing subject metadata.
 */
export async function getAvailableSubjects(): Promise<HRTFSubject[]> {
  if (cachedManifest) {
    return cachedManifest.subjects;
  }

  const response = await fetch(`${HRTF_BASE_PATH}/manifest.json`);
  if (!response.ok) {
    throw new Error(`Failed to load HRTF manifest: ${response.status} ${response.statusText}`);
  }

  cachedManifest = await response.json() as HRTFManifest;
  return cachedManifest.subjects;
}

/**
 * Load pre-computed decoder FIR filters for a subject at a given ambisonic order.
 *
 * Binary format:
 *   Header: uint32 nChannels, uint32 filterLength, uint32 sampleRate
 *   Data: For each channel (0..nChannels-1):
 *     Float32[filterLength] left ear FIR
 *     Float32[filterLength] right ear FIR
 */
export async function loadDecoderFilters(
  subjectId: string,
  order: number
): Promise<HRTFDecoderFilters> {
  const cacheKey = `${subjectId}_order${order}`;

  const cached = filterCache.get(cacheKey);
  if (cached) {
    return cached;
  }

  const url = `${HRTF_BASE_PATH}/filters/${subjectId}_order${order}.bin`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to load HRTF filters for ${subjectId} order ${order}: ${response.status}`);
  }

  const arrayBuffer = await response.arrayBuffer();
  const result = parseDecoderFilters(arrayBuffer);

  filterCache.set(cacheKey, result);
  return result;
}

/**
 * Parse the binary decoder filter format.
 */
function parseDecoderFilters(buffer: ArrayBuffer): HRTFDecoderFilters {
  const headerView = new DataView(buffer);

  const nChannels = headerView.getUint32(0, true);
  const filterLength = headerView.getUint32(4, true);
  const sampleRate = headerView.getUint32(8, true);

  // Validate
  const headerSize = 12; // 3 x uint32
  const expectedDataSize = nChannels * 2 * filterLength * 4; // float32 = 4 bytes
  if (buffer.byteLength < headerSize + expectedDataSize) {
    throw new Error(
      `Invalid HRTF filter data: expected ${headerSize + expectedDataSize} bytes, got ${buffer.byteLength}`
    );
  }

  const filtersLeft: Float32Array[] = [];
  const filtersRight: Float32Array[] = [];

  let offset = headerSize;
  for (let ch = 0; ch < nChannels; ch++) {
    filtersLeft.push(new Float32Array(buffer, offset, filterLength));
    offset += filterLength * 4;
    filtersRight.push(new Float32Array(buffer, offset, filterLength));
    offset += filterLength * 4;
  }

  return {
    sampleRate,
    filterLength,
    channelCount: nChannels,
    filtersLeft,
    filtersRight,
  };
}

/**
 * Get the thumbnail URL for a subject's ear image.
 */
export function getThumbnailUrl(relativePath: string): string {
  if (!relativePath) return "";
  return `${HRTF_BASE_PATH}/${relativePath}`;
}

/**
 * Clear cached data (useful for testing).
 */
export function clearCache(): void {
  cachedManifest = null;
  filterCache.clear();
}
