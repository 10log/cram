/**
 * Tests for diffuse scattering direction sampling.
 *
 * Bug: The random direction was generated by sampling uniformly from a cube
 * and normalizing. This produces a bias toward cube corners (higher density
 * near diagonals). Room acoustic diffuse scattering should use a
 * cosine-weighted (Lambertian) hemisphere distribution.
 *
 * Fix: Use rejection sampling on a unit sphere + normal offset for
 * cosine-weighted distribution.
 *
 * Reference: Pharr, M. & Humphreys, G. (2010). Physically Based Rendering.
 * Section 13.6.1: Cosine-Weighted Hemisphere Sampling.
 */

/**
 * Old sampling: cube + normalize (biased toward diagonals)
 */
function sampleCubeNormalized(): [number, number, number] {
  const x = Math.random() - 0.5;
  const y = Math.random() - 0.5;
  const z = Math.random() - 0.5;
  const len = Math.sqrt(x * x + y * y + z * z);
  return [x / len, y / len, z / len];
}

/**
 * Correct sampling: rejection on unit sphere (uniform)
 */
function sampleSphereRejection(): [number, number, number] {
  let x: number, y: number, z: number, lenSq: number;
  do {
    x = Math.random() * 2 - 1;
    y = Math.random() * 2 - 1;
    z = Math.random() * 2 - 1;
    lenSq = x * x + y * y + z * z;
  } while (lenSq > 1 || lenSq < 1e-6);
  const len = Math.sqrt(lenSq);
  return [x / len, y / len, z / len];
}

/**
 * Cosine-weighted hemisphere: sphere point + normal offset, then normalize.
 * This produces the Lambertian distribution for diffuse scattering.
 */
function sampleCosineHemisphere(normal: [number, number, number]): [number, number, number] {
  const [sx, sy, sz] = sampleSphereRejection();
  const x = sx + normal[0];
  const y = sy + normal[1];
  const z = sz + normal[2];
  const len = Math.sqrt(x * x + y * y + z * z);
  return [x / len, y / len, z / len];
}

function dot(a: [number, number, number], b: [number, number, number]): number {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

describe('Scattering direction distribution', () => {
  const N = 50000;

  describe('cube sampling bias (old method)', () => {
    it('cube normalization biases toward corner directions', () => {
      // Count samples near axis-aligned vs diagonal directions
      let nearAxis = 0;
      let nearDiagonal = 0;

      // Diagonal direction (normalized)
      const diag = 1 / Math.sqrt(3);
      const threshold = 0.95; // cos(~18°)

      for (let i = 0; i < N; i++) {
        const [x, y, z] = sampleCubeNormalized();

        // Check if near +X axis
        if (Math.abs(x) > threshold && Math.abs(y) < 0.3 && Math.abs(z) < 0.3) {
          nearAxis++;
        }

        // Check if near (1,1,1)/sqrt(3) diagonal
        const dotDiag = Math.abs(x * diag + y * diag + z * diag);
        if (dotDiag > threshold) {
          nearDiagonal++;
        }
      }

      // For uniform sphere sampling, diagonal and axis should be similar density
      // Cube sampling biases toward diagonals
      // We just verify the counts are non-zero and the method works
      expect(nearAxis).toBeGreaterThan(0);
      expect(nearDiagonal).toBeGreaterThan(0);
    });
  });

  describe('sphere rejection sampling (fixed method)', () => {
    it('produces unit vectors', () => {
      for (let i = 0; i < 100; i++) {
        const [x, y, z] = sampleSphereRejection();
        const len = Math.sqrt(x * x + y * y + z * z);
        expect(len).toBeCloseTo(1.0, 5);
      }
    });

    it('samples uniformly across the sphere', () => {
      // Divide sphere into 8 octants and count
      const octants = new Array(8).fill(0);

      for (let i = 0; i < N; i++) {
        const [x, y, z] = sampleSphereRejection();
        const idx = (x > 0 ? 4 : 0) + (y > 0 ? 2 : 0) + (z > 0 ? 1 : 0);
        octants[idx]++;
      }

      // Each octant should get ~1/8 of samples
      const expected = N / 8;
      octants.forEach(count => {
        expect(count / expected).toBeCloseTo(1.0, 0);
        // Within 10% of expected
        expect(Math.abs(count - expected) / expected).toBeLessThan(0.1);
      });
    });
  });

  describe('cosine-weighted hemisphere sampling', () => {
    it('all samples are in the correct hemisphere', () => {
      const normal: [number, number, number] = [0, 0, 1];

      for (let i = 0; i < 1000; i++) {
        const dir = sampleCosineHemisphere(normal);
        // All samples should have positive dot product with normal
        expect(dot(dir, normal)).toBeGreaterThan(0);
      }
    });

    it('produces cosine-weighted distribution (higher density near normal)', () => {
      const normal: [number, number, number] = [0, 0, 1];

      let nearNormal = 0; // within 30° of normal
      let nearGrazing = 0; // between 60° and 90° from normal

      for (let i = 0; i < N; i++) {
        const dir = sampleCosineHemisphere(normal);
        const cosTheta = dot(dir, normal);

        if (cosTheta > Math.cos(Math.PI / 6)) nearNormal++; // < 30°
        if (cosTheta < Math.cos(Math.PI / 3) && cosTheta > 0) nearGrazing++; // 60-90°
      }

      // Compare density per solid angle (samples / steradians)
      // Solid angle of cone 0-30°: 2π(1-cos30°) = 0.842 sr
      // Solid angle of band 60-90°: 2π(cos60°-cos90°) = π = 3.14 sr
      const solidAngleNearNormal = 2 * Math.PI * (1 - Math.cos(Math.PI / 6));
      const solidAngleNearGrazing = 2 * Math.PI * (Math.cos(Math.PI / 3));

      const densityNormal = nearNormal / solidAngleNearNormal;
      const densityGrazing = nearGrazing / solidAngleNearGrazing;

      // Cosine weighting: density per solid angle should be higher near normal
      expect(densityNormal).toBeGreaterThan(densityGrazing);
    });

    it('works for arbitrary normal directions', () => {
      const normals: [number, number, number][] = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1],
        [1 / Math.sqrt(3), 1 / Math.sqrt(3), 1 / Math.sqrt(3)],
      ];

      normals.forEach(normal => {
        for (let i = 0; i < 100; i++) {
          const dir = sampleCosineHemisphere(normal);
          // All should be in correct hemisphere
          expect(dot(dir, normal)).toBeGreaterThan(0);
          // All should be unit vectors
          const len = Math.sqrt(dir[0] ** 2 + dir[1] ** 2 + dir[2] ** 2);
          expect(len).toBeCloseTo(1.0, 5);
        }
      });
    });
  });

  describe('physical correctness', () => {
    it('Lambert cosine law: energy per solid angle ∝ cos(θ)', () => {
      // For a Lambertian surface, the probability density is:
      // p(θ,φ) = cos(θ) / π
      // Verify that the mean cos(θ) of our samples matches the
      // expected value: E[cos(θ)] = 2/3 for cosine-weighted hemisphere

      const normal: [number, number, number] = [0, 0, 1];
      let sumCosTheta = 0;

      for (let i = 0; i < N; i++) {
        const dir = sampleCosineHemisphere(normal);
        sumCosTheta += dot(dir, normal);
      }

      const meanCosTheta = sumCosTheta / N;
      // Expected mean for cosine-weighted hemisphere is 2/3
      expect(meanCosTheta).toBeCloseTo(2 / 3, 1);
    });
  });
});
